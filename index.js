/*! For license information please see index.js.LICENSE.txt */
!function() {
    var t = {
        755: function(t, e) {
            var n;
            !function(e, n) {
                "use strict";
                "object" == typeof t.exports ? t.exports = e.document ? n(e, !0) : function(t) {
                    if (!t.document)
                        throw new Error("jQuery requires a window with a document");
                    return n(t)
                }
                : n(e)
            }("undefined" != typeof window ? window : this, (function(i, r) {
                "use strict";
                var s = []
                  , o = Object.getPrototypeOf
                  , a = s.slice
                  , l = s.flat ? function(t) {
                    return s.flat.call(t)
                }
                : function(t) {
                    return s.concat.apply([], t)
                }
                  , c = s.push
                  , u = s.indexOf
                  , h = {}
                  , d = h.toString
                  , p = h.hasOwnProperty
                  , f = p.toString
                  , m = f.call(Object)
                  , g = {}
                  , v = function(t) {
                    return "function" == typeof t && "number" != typeof t.nodeType && "function" != typeof t.item
                }
                  , y = function(t) {
                    return null != t && t === t.window
                }
                  , x = i.document
                  , _ = {
                    type: !0,
                    src: !0,
                    nonce: !0,
                    noModule: !0
                };
                function b(t, e, n) {
                    var i, r, s = (n = n || x).createElement("script");
                    if (s.text = t,
                    e)
                        for (i in _)
                            (r = e[i] || e.getAttribute && e.getAttribute(i)) && s.setAttribute(i, r);
                    n.head.appendChild(s).parentNode.removeChild(s)
                }
                function w(t) {
                    return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? h[d.call(t)] || "object" : typeof t
                }
                var M = "3.6.0"
                  , S = function(t, e) {
                    return new S.fn.init(t,e)
                };
                function T(t) {
                    var e = !!t && "length"in t && t.length
                      , n = w(t);
                    return !v(t) && !y(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
                }
                S.fn = S.prototype = {
                    jquery: M,
                    constructor: S,
                    length: 0,
                    toArray: function() {
                        return a.call(this)
                    },
                    get: function(t) {
                        return null == t ? a.call(this) : t < 0 ? this[t + this.length] : this[t]
                    },
                    pushStack: function(t) {
                        var e = S.merge(this.constructor(), t);
                        return e.prevObject = this,
                        e
                    },
                    each: function(t) {
                        return S.each(this, t)
                    },
                    map: function(t) {
                        return this.pushStack(S.map(this, (function(e, n) {
                            return t.call(e, n, e)
                        }
                        )))
                    },
                    slice: function() {
                        return this.pushStack(a.apply(this, arguments))
                    },
                    first: function() {
                        return this.eq(0)
                    },
                    last: function() {
                        return this.eq(-1)
                    },
                    even: function() {
                        return this.pushStack(S.grep(this, (function(t, e) {
                            return (e + 1) % 2
                        }
                        )))
                    },
                    odd: function() {
                        return this.pushStack(S.grep(this, (function(t, e) {
                            return e % 2
                        }
                        )))
                    },
                    eq: function(t) {
                        var e = this.length
                          , n = +t + (t < 0 ? e : 0);
                        return this.pushStack(n >= 0 && n < e ? [this[n]] : [])
                    },
                    end: function() {
                        return this.prevObject || this.constructor()
                    },
                    push: c,
                    sort: s.sort,
                    splice: s.splice
                },
                S.extend = S.fn.extend = function() {
                    var t, e, n, i, r, s, o = arguments[0] || {}, a = 1, l = arguments.length, c = !1;
                    for ("boolean" == typeof o && (c = o,
                    o = arguments[a] || {},
                    a++),
                    "object" == typeof o || v(o) || (o = {}),
                    a === l && (o = this,
                    a--); a < l; a++)
                        if (null != (t = arguments[a]))
                            for (e in t)
                                i = t[e],
                                "__proto__" !== e && o !== i && (c && i && (S.isPlainObject(i) || (r = Array.isArray(i))) ? (n = o[e],
                                s = r && !Array.isArray(n) ? [] : r || S.isPlainObject(n) ? n : {},
                                r = !1,
                                o[e] = S.extend(c, s, i)) : void 0 !== i && (o[e] = i));
                    return o
                }
                ,
                S.extend({
                    expando: "jQuery" + (M + Math.random()).replace(/\D/g, ""),
                    isReady: !0,
                    error: function(t) {
                        throw new Error(t)
                    },
                    noop: function() {},
                    isPlainObject: function(t) {
                        var e, n;
                        return !(!t || "[object Object]" !== d.call(t) || (e = o(t)) && ("function" != typeof (n = p.call(e, "constructor") && e.constructor) || f.call(n) !== m))
                    },
                    isEmptyObject: function(t) {
                        var e;
                        for (e in t)
                            return !1;
                        return !0
                    },
                    globalEval: function(t, e, n) {
                        b(t, {
                            nonce: e && e.nonce
                        }, n)
                    },
                    each: function(t, e) {
                        var n, i = 0;
                        if (T(t))
                            for (n = t.length; i < n && !1 !== e.call(t[i], i, t[i]); i++)
                                ;
                        else
                            for (i in t)
                                if (!1 === e.call(t[i], i, t[i]))
                                    break;
                        return t
                    },
                    makeArray: function(t, e) {
                        var n = e || [];
                        return null != t && (T(Object(t)) ? S.merge(n, "string" == typeof t ? [t] : t) : c.call(n, t)),
                        n
                    },
                    inArray: function(t, e, n) {
                        return null == e ? -1 : u.call(e, t, n)
                    },
                    merge: function(t, e) {
                        for (var n = +e.length, i = 0, r = t.length; i < n; i++)
                            t[r++] = e[i];
                        return t.length = r,
                        t
                    },
                    grep: function(t, e, n) {
                        for (var i = [], r = 0, s = t.length, o = !n; r < s; r++)
                            !e(t[r], r) !== o && i.push(t[r]);
                        return i
                    },
                    map: function(t, e, n) {
                        var i, r, s = 0, o = [];
                        if (T(t))
                            for (i = t.length; s < i; s++)
                                null != (r = e(t[s], s, n)) && o.push(r);
                        else
                            for (s in t)
                                null != (r = e(t[s], s, n)) && o.push(r);
                        return l(o)
                    },
                    guid: 1,
                    support: g
                }),
                "function" == typeof Symbol && (S.fn[Symbol.iterator] = s[Symbol.iterator]),
                S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function(t, e) {
                    h["[object " + e + "]"] = e.toLowerCase()
                }
                ));
                var E = function(t) {
                    var e, n, i, r, s, o, a, l, c, u, h, d, p, f, m, g, v, y, x, _ = "sizzle" + 1 * new Date, b = t.document, w = 0, M = 0, S = lt(), T = lt(), E = lt(), A = lt(), C = function(t, e) {
                        return t === e && (h = !0),
                        0
                    }, R = {}.hasOwnProperty, L = [], P = L.pop, D = L.push, I = L.push, O = L.slice, N = function(t, e) {
                        for (var n = 0, i = t.length; n < i; n++)
                            if (t[n] === e)
                                return n;
                        return -1
                    }, k = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", z = "[\\x20\\t\\r\\n\\f]", H = "(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", B = "\\[[\\x20\\t\\r\\n\\f]*(" + H + ")(?:" + z + "*([*^$|!~]?=)" + z + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + H + "))|)" + z + "*\\]", F = ":(" + H + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + B + ")*)|.*)\\)|)", U = new RegExp(z + "+","g"), G = new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$","g"), V = new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"), W = new RegExp("^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"), j = new RegExp(z + "|>"), q = new RegExp(F), X = new RegExp("^" + H + "$"), Y = {
                        ID: new RegExp("^#(" + H + ")"),
                        CLASS: new RegExp("^\\.(" + H + ")"),
                        TAG: new RegExp("^(" + H + "|[*])"),
                        ATTR: new RegExp("^" + B),
                        PSEUDO: new RegExp("^" + F),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)","i"),
                        bool: new RegExp("^(?:" + k + ")$","i"),
                        needsContext: new RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)","i")
                    }, J = /HTML$/i, Z = /^(?:input|select|textarea|button)$/i, K = /^h\d$/i, Q = /^[^{]+\{\s*\[native \w/, $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, tt = /[+~]/, et = new RegExp("\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])","g"), nt = function(t, e) {
                        var n = "0x" + t.slice(1) - 65536;
                        return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                    }, it = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, rt = function(t, e) {
                        return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
                    }, st = function() {
                        d()
                    }, ot = _t((function(t) {
                        return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
                    }
                    ), {
                        dir: "parentNode",
                        next: "legend"
                    });
                    try {
                        I.apply(L = O.call(b.childNodes), b.childNodes),
                        L[b.childNodes.length].nodeType
                    } catch (t) {
                        I = {
                            apply: L.length ? function(t, e) {
                                D.apply(t, O.call(e))
                            }
                            : function(t, e) {
                                for (var n = t.length, i = 0; t[n++] = e[i++]; )
                                    ;
                                t.length = n - 1
                            }
                        }
                    }
                    function at(t, e, i, r) {
                        var s, a, c, u, h, f, v, y = e && e.ownerDocument, b = e ? e.nodeType : 9;
                        if (i = i || [],
                        "string" != typeof t || !t || 1 !== b && 9 !== b && 11 !== b)
                            return i;
                        if (!r && (d(e),
                        e = e || p,
                        m)) {
                            if (11 !== b && (h = $.exec(t)))
                                if (s = h[1]) {
                                    if (9 === b) {
                                        if (!(c = e.getElementById(s)))
                                            return i;
                                        if (c.id === s)
                                            return i.push(c),
                                            i
                                    } else if (y && (c = y.getElementById(s)) && x(e, c) && c.id === s)
                                        return i.push(c),
                                        i
                                } else {
                                    if (h[2])
                                        return I.apply(i, e.getElementsByTagName(t)),
                                        i;
                                    if ((s = h[3]) && n.getElementsByClassName && e.getElementsByClassName)
                                        return I.apply(i, e.getElementsByClassName(s)),
                                        i
                                }
                            if (n.qsa && !A[t + " "] && (!g || !g.test(t)) && (1 !== b || "object" !== e.nodeName.toLowerCase())) {
                                if (v = t,
                                y = e,
                                1 === b && (j.test(t) || W.test(t))) {
                                    for ((y = tt.test(t) && vt(e.parentNode) || e) === e && n.scope || ((u = e.getAttribute("id")) ? u = u.replace(it, rt) : e.setAttribute("id", u = _)),
                                    a = (f = o(t)).length; a--; )
                                        f[a] = (u ? "#" + u : ":scope") + " " + xt(f[a]);
                                    v = f.join(",")
                                }
                                try {
                                    return I.apply(i, y.querySelectorAll(v)),
                                    i
                                } catch (e) {
                                    A(t, !0)
                                } finally {
                                    u === _ && e.removeAttribute("id")
                                }
                            }
                        }
                        return l(t.replace(G, "$1"), e, i, r)
                    }
                    function lt() {
                        var t = [];
                        return function e(n, r) {
                            return t.push(n + " ") > i.cacheLength && delete e[t.shift()],
                            e[n + " "] = r
                        }
                    }
                    function ct(t) {
                        return t[_] = !0,
                        t
                    }
                    function ut(t) {
                        var e = p.createElement("fieldset");
                        try {
                            return !!t(e)
                        } catch (t) {
                            return !1
                        } finally {
                            e.parentNode && e.parentNode.removeChild(e),
                            e = null
                        }
                    }
                    function ht(t, e) {
                        for (var n = t.split("|"), r = n.length; r--; )
                            i.attrHandle[n[r]] = e
                    }
                    function dt(t, e) {
                        var n = e && t
                          , i = n && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
                        if (i)
                            return i;
                        if (n)
                            for (; n = n.nextSibling; )
                                if (n === e)
                                    return -1;
                        return t ? 1 : -1
                    }
                    function pt(t) {
                        return function(e) {
                            return "input" === e.nodeName.toLowerCase() && e.type === t
                        }
                    }
                    function ft(t) {
                        return function(e) {
                            var n = e.nodeName.toLowerCase();
                            return ("input" === n || "button" === n) && e.type === t
                        }
                    }
                    function mt(t) {
                        return function(e) {
                            return "form"in e ? e.parentNode && !1 === e.disabled ? "label"in e ? "label"in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ot(e) === t : e.disabled === t : "label"in e && e.disabled === t
                        }
                    }
                    function gt(t) {
                        return ct((function(e) {
                            return e = +e,
                            ct((function(n, i) {
                                for (var r, s = t([], n.length, e), o = s.length; o--; )
                                    n[r = s[o]] && (n[r] = !(i[r] = n[r]))
                            }
                            ))
                        }
                        ))
                    }
                    function vt(t) {
                        return t && void 0 !== t.getElementsByTagName && t
                    }
                    for (e in n = at.support = {},
                    s = at.isXML = function(t) {
                        var e = t && t.namespaceURI
                          , n = t && (t.ownerDocument || t).documentElement;
                        return !J.test(e || n && n.nodeName || "HTML")
                    }
                    ,
                    d = at.setDocument = function(t) {
                        var e, r, o = t ? t.ownerDocument || t : b;
                        return o != p && 9 === o.nodeType && o.documentElement ? (f = (p = o).documentElement,
                        m = !s(p),
                        b != p && (r = p.defaultView) && r.top !== r && (r.addEventListener ? r.addEventListener("unload", st, !1) : r.attachEvent && r.attachEvent("onunload", st)),
                        n.scope = ut((function(t) {
                            return f.appendChild(t).appendChild(p.createElement("div")),
                            void 0 !== t.querySelectorAll && !t.querySelectorAll(":scope fieldset div").length
                        }
                        )),
                        n.attributes = ut((function(t) {
                            return t.className = "i",
                            !t.getAttribute("className")
                        }
                        )),
                        n.getElementsByTagName = ut((function(t) {
                            return t.appendChild(p.createComment("")),
                            !t.getElementsByTagName("*").length
                        }
                        )),
                        n.getElementsByClassName = Q.test(p.getElementsByClassName),
                        n.getById = ut((function(t) {
                            return f.appendChild(t).id = _,
                            !p.getElementsByName || !p.getElementsByName(_).length
                        }
                        )),
                        n.getById ? (i.filter.ID = function(t) {
                            var e = t.replace(et, nt);
                            return function(t) {
                                return t.getAttribute("id") === e
                            }
                        }
                        ,
                        i.find.ID = function(t, e) {
                            if (void 0 !== e.getElementById && m) {
                                var n = e.getElementById(t);
                                return n ? [n] : []
                            }
                        }
                        ) : (i.filter.ID = function(t) {
                            var e = t.replace(et, nt);
                            return function(t) {
                                var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                                return n && n.value === e
                            }
                        }
                        ,
                        i.find.ID = function(t, e) {
                            if (void 0 !== e.getElementById && m) {
                                var n, i, r, s = e.getElementById(t);
                                if (s) {
                                    if ((n = s.getAttributeNode("id")) && n.value === t)
                                        return [s];
                                    for (r = e.getElementsByName(t),
                                    i = 0; s = r[i++]; )
                                        if ((n = s.getAttributeNode("id")) && n.value === t)
                                            return [s]
                                }
                                return []
                            }
                        }
                        ),
                        i.find.TAG = n.getElementsByTagName ? function(t, e) {
                            return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : n.qsa ? e.querySelectorAll(t) : void 0
                        }
                        : function(t, e) {
                            var n, i = [], r = 0, s = e.getElementsByTagName(t);
                            if ("*" === t) {
                                for (; n = s[r++]; )
                                    1 === n.nodeType && i.push(n);
                                return i
                            }
                            return s
                        }
                        ,
                        i.find.CLASS = n.getElementsByClassName && function(t, e) {
                            if (void 0 !== e.getElementsByClassName && m)
                                return e.getElementsByClassName(t)
                        }
                        ,
                        v = [],
                        g = [],
                        (n.qsa = Q.test(p.querySelectorAll)) && (ut((function(t) {
                            var e;
                            f.appendChild(t).innerHTML = "<a id='" + _ + "'></a><select id='" + _ + "-\r\\' msallowcapture=''><option selected=''></option></select>",
                            t.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),
                            t.querySelectorAll("[selected]").length || g.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|" + k + ")"),
                            t.querySelectorAll("[id~=" + _ + "-]").length || g.push("~="),
                            (e = p.createElement("input")).setAttribute("name", ""),
                            t.appendChild(e),
                            t.querySelectorAll("[name='']").length || g.push("\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),
                            t.querySelectorAll(":checked").length || g.push(":checked"),
                            t.querySelectorAll("a#" + _ + "+*").length || g.push(".#.+[+~]"),
                            t.querySelectorAll("\\\f"),
                            g.push("[\\r\\n\\f]")
                        }
                        )),
                        ut((function(t) {
                            t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                            var e = p.createElement("input");
                            e.setAttribute("type", "hidden"),
                            t.appendChild(e).setAttribute("name", "D"),
                            t.querySelectorAll("[name=d]").length && g.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="),
                            2 !== t.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"),
                            f.appendChild(t).disabled = !0,
                            2 !== t.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"),
                            t.querySelectorAll("*,:x"),
                            g.push(",.*:")
                        }
                        ))),
                        (n.matchesSelector = Q.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && ut((function(t) {
                            n.disconnectedMatch = y.call(t, "*"),
                            y.call(t, "[s!='']:x"),
                            v.push("!=", F)
                        }
                        )),
                        g = g.length && new RegExp(g.join("|")),
                        v = v.length && new RegExp(v.join("|")),
                        e = Q.test(f.compareDocumentPosition),
                        x = e || Q.test(f.contains) ? function(t, e) {
                            var n = 9 === t.nodeType ? t.documentElement : t
                              , i = e && e.parentNode;
                            return t === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(i)))
                        }
                        : function(t, e) {
                            if (e)
                                for (; e = e.parentNode; )
                                    if (e === t)
                                        return !0;
                            return !1
                        }
                        ,
                        C = e ? function(t, e) {
                            if (t === e)
                                return h = !0,
                                0;
                            var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
                            return i || (1 & (i = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !n.sortDetached && e.compareDocumentPosition(t) === i ? t == p || t.ownerDocument == b && x(b, t) ? -1 : e == p || e.ownerDocument == b && x(b, e) ? 1 : u ? N(u, t) - N(u, e) : 0 : 4 & i ? -1 : 1)
                        }
                        : function(t, e) {
                            if (t === e)
                                return h = !0,
                                0;
                            var n, i = 0, r = t.parentNode, s = e.parentNode, o = [t], a = [e];
                            if (!r || !s)
                                return t == p ? -1 : e == p ? 1 : r ? -1 : s ? 1 : u ? N(u, t) - N(u, e) : 0;
                            if (r === s)
                                return dt(t, e);
                            for (n = t; n = n.parentNode; )
                                o.unshift(n);
                            for (n = e; n = n.parentNode; )
                                a.unshift(n);
                            for (; o[i] === a[i]; )
                                i++;
                            return i ? dt(o[i], a[i]) : o[i] == b ? -1 : a[i] == b ? 1 : 0
                        }
                        ,
                        p) : p
                    }
                    ,
                    at.matches = function(t, e) {
                        return at(t, null, null, e)
                    }
                    ,
                    at.matchesSelector = function(t, e) {
                        if (d(t),
                        n.matchesSelector && m && !A[e + " "] && (!v || !v.test(e)) && (!g || !g.test(e)))
                            try {
                                var i = y.call(t, e);
                                if (i || n.disconnectedMatch || t.document && 11 !== t.document.nodeType)
                                    return i
                            } catch (t) {
                                A(e, !0)
                            }
                        return at(e, p, null, [t]).length > 0
                    }
                    ,
                    at.contains = function(t, e) {
                        return (t.ownerDocument || t) != p && d(t),
                        x(t, e)
                    }
                    ,
                    at.attr = function(t, e) {
                        (t.ownerDocument || t) != p && d(t);
                        var r = i.attrHandle[e.toLowerCase()]
                          , s = r && R.call(i.attrHandle, e.toLowerCase()) ? r(t, e, !m) : void 0;
                        return void 0 !== s ? s : n.attributes || !m ? t.getAttribute(e) : (s = t.getAttributeNode(e)) && s.specified ? s.value : null
                    }
                    ,
                    at.escape = function(t) {
                        return (t + "").replace(it, rt)
                    }
                    ,
                    at.error = function(t) {
                        throw new Error("Syntax error, unrecognized expression: " + t)
                    }
                    ,
                    at.uniqueSort = function(t) {
                        var e, i = [], r = 0, s = 0;
                        if (h = !n.detectDuplicates,
                        u = !n.sortStable && t.slice(0),
                        t.sort(C),
                        h) {
                            for (; e = t[s++]; )
                                e === t[s] && (r = i.push(s));
                            for (; r--; )
                                t.splice(i[r], 1)
                        }
                        return u = null,
                        t
                    }
                    ,
                    r = at.getText = function(t) {
                        var e, n = "", i = 0, s = t.nodeType;
                        if (s) {
                            if (1 === s || 9 === s || 11 === s) {
                                if ("string" == typeof t.textContent)
                                    return t.textContent;
                                for (t = t.firstChild; t; t = t.nextSibling)
                                    n += r(t)
                            } else if (3 === s || 4 === s)
                                return t.nodeValue
                        } else
                            for (; e = t[i++]; )
                                n += r(e);
                        return n
                    }
                    ,
                    (i = at.selectors = {
                        cacheLength: 50,
                        createPseudo: ct,
                        match: Y,
                        attrHandle: {},
                        find: {},
                        relative: {
                            ">": {
                                dir: "parentNode",
                                first: !0
                            },
                            " ": {
                                dir: "parentNode"
                            },
                            "+": {
                                dir: "previousSibling",
                                first: !0
                            },
                            "~": {
                                dir: "previousSibling"
                            }
                        },
                        preFilter: {
                            ATTR: function(t) {
                                return t[1] = t[1].replace(et, nt),
                                t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt),
                                "~=" === t[2] && (t[3] = " " + t[3] + " "),
                                t.slice(0, 4)
                            },
                            CHILD: function(t) {
                                return t[1] = t[1].toLowerCase(),
                                "nth" === t[1].slice(0, 3) ? (t[3] || at.error(t[0]),
                                t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])),
                                t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && at.error(t[0]),
                                t
                            },
                            PSEUDO: function(t) {
                                var e, n = !t[6] && t[2];
                                return Y.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && q.test(n) && (e = o(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(0, e),
                                t[2] = n.slice(0, e)),
                                t.slice(0, 3))
                            }
                        },
                        filter: {
                            TAG: function(t) {
                                var e = t.replace(et, nt).toLowerCase();
                                return "*" === t ? function() {
                                    return !0
                                }
                                : function(t) {
                                    return t.nodeName && t.nodeName.toLowerCase() === e
                                }
                            },
                            CLASS: function(t) {
                                var e = S[t + " "];
                                return e || (e = new RegExp("(^|[\\x20\\t\\r\\n\\f])" + t + "(" + z + "|$)")) && S(t, (function(t) {
                                    return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                                }
                                ))
                            },
                            ATTR: function(t, e, n) {
                                return function(i) {
                                    var r = at.attr(i, t);
                                    return null == r ? "!=" === e : !e || (r += "",
                                    "=" === e ? r === n : "!=" === e ? r !== n : "^=" === e ? n && 0 === r.indexOf(n) : "*=" === e ? n && r.indexOf(n) > -1 : "$=" === e ? n && r.slice(-n.length) === n : "~=" === e ? (" " + r.replace(U, " ") + " ").indexOf(n) > -1 : "|=" === e && (r === n || r.slice(0, n.length + 1) === n + "-"))
                                }
                            },
                            CHILD: function(t, e, n, i, r) {
                                var s = "nth" !== t.slice(0, 3)
                                  , o = "last" !== t.slice(-4)
                                  , a = "of-type" === e;
                                return 1 === i && 0 === r ? function(t) {
                                    return !!t.parentNode
                                }
                                : function(e, n, l) {
                                    var c, u, h, d, p, f, m = s !== o ? "nextSibling" : "previousSibling", g = e.parentNode, v = a && e.nodeName.toLowerCase(), y = !l && !a, x = !1;
                                    if (g) {
                                        if (s) {
                                            for (; m; ) {
                                                for (d = e; d = d[m]; )
                                                    if (a ? d.nodeName.toLowerCase() === v : 1 === d.nodeType)
                                                        return !1;
                                                f = m = "only" === t && !f && "nextSibling"
                                            }
                                            return !0
                                        }
                                        if (f = [o ? g.firstChild : g.lastChild],
                                        o && y) {
                                            for (x = (p = (c = (u = (h = (d = g)[_] || (d[_] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] || [])[0] === w && c[1]) && c[2],
                                            d = p && g.childNodes[p]; d = ++p && d && d[m] || (x = p = 0) || f.pop(); )
                                                if (1 === d.nodeType && ++x && d === e) {
                                                    u[t] = [w, p, x];
                                                    break
                                                }
                                        } else if (y && (x = p = (c = (u = (h = (d = e)[_] || (d[_] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] || [])[0] === w && c[1]),
                                        !1 === x)
                                            for (; (d = ++p && d && d[m] || (x = p = 0) || f.pop()) && ((a ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++x || (y && ((u = (h = d[_] || (d[_] = {}))[d.uniqueID] || (h[d.uniqueID] = {}))[t] = [w, x]),
                                            d !== e)); )
                                                ;
                                        return (x -= r) === i || x % i == 0 && x / i >= 0
                                    }
                                }
                            },
                            PSEUDO: function(t, e) {
                                var n, r = i.pseudos[t] || i.setFilters[t.toLowerCase()] || at.error("unsupported pseudo: " + t);
                                return r[_] ? r(e) : r.length > 1 ? (n = [t, t, "", e],
                                i.setFilters.hasOwnProperty(t.toLowerCase()) ? ct((function(t, n) {
                                    for (var i, s = r(t, e), o = s.length; o--; )
                                        t[i = N(t, s[o])] = !(n[i] = s[o])
                                }
                                )) : function(t) {
                                    return r(t, 0, n)
                                }
                                ) : r
                            }
                        },
                        pseudos: {
                            not: ct((function(t) {
                                var e = []
                                  , n = []
                                  , i = a(t.replace(G, "$1"));
                                return i[_] ? ct((function(t, e, n, r) {
                                    for (var s, o = i(t, null, r, []), a = t.length; a--; )
                                        (s = o[a]) && (t[a] = !(e[a] = s))
                                }
                                )) : function(t, r, s) {
                                    return e[0] = t,
                                    i(e, null, s, n),
                                    e[0] = null,
                                    !n.pop()
                                }
                            }
                            )),
                            has: ct((function(t) {
                                return function(e) {
                                    return at(t, e).length > 0
                                }
                            }
                            )),
                            contains: ct((function(t) {
                                return t = t.replace(et, nt),
                                function(e) {
                                    return (e.textContent || r(e)).indexOf(t) > -1
                                }
                            }
                            )),
                            lang: ct((function(t) {
                                return X.test(t || "") || at.error("unsupported lang: " + t),
                                t = t.replace(et, nt).toLowerCase(),
                                function(e) {
                                    var n;
                                    do {
                                        if (n = m ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang"))
                                            return (n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-")
                                    } while ((e = e.parentNode) && 1 === e.nodeType);
                                    return !1
                                }
                            }
                            )),
                            target: function(e) {
                                var n = t.location && t.location.hash;
                                return n && n.slice(1) === e.id
                            },
                            root: function(t) {
                                return t === f
                            },
                            focus: function(t) {
                                return t === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                            },
                            enabled: mt(!1),
                            disabled: mt(!0),
                            checked: function(t) {
                                var e = t.nodeName.toLowerCase();
                                return "input" === e && !!t.checked || "option" === e && !!t.selected
                            },
                            selected: function(t) {
                                return t.parentNode && t.parentNode.selectedIndex,
                                !0 === t.selected
                            },
                            empty: function(t) {
                                for (t = t.firstChild; t; t = t.nextSibling)
                                    if (t.nodeType < 6)
                                        return !1;
                                return !0
                            },
                            parent: function(t) {
                                return !i.pseudos.empty(t)
                            },
                            header: function(t) {
                                return K.test(t.nodeName)
                            },
                            input: function(t) {
                                return Z.test(t.nodeName)
                            },
                            button: function(t) {
                                var e = t.nodeName.toLowerCase();
                                return "input" === e && "button" === t.type || "button" === e
                            },
                            text: function(t) {
                                var e;
                                return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                            },
                            first: gt((function() {
                                return [0]
                            }
                            )),
                            last: gt((function(t, e) {
                                return [e - 1]
                            }
                            )),
                            eq: gt((function(t, e, n) {
                                return [n < 0 ? n + e : n]
                            }
                            )),
                            even: gt((function(t, e) {
                                for (var n = 0; n < e; n += 2)
                                    t.push(n);
                                return t
                            }
                            )),
                            odd: gt((function(t, e) {
                                for (var n = 1; n < e; n += 2)
                                    t.push(n);
                                return t
                            }
                            )),
                            lt: gt((function(t, e, n) {
                                for (var i = n < 0 ? n + e : n > e ? e : n; --i >= 0; )
                                    t.push(i);
                                return t
                            }
                            )),
                            gt: gt((function(t, e, n) {
                                for (var i = n < 0 ? n + e : n; ++i < e; )
                                    t.push(i);
                                return t
                            }
                            ))
                        }
                    }).pseudos.nth = i.pseudos.eq,
                    {
                        radio: !0,
                        checkbox: !0,
                        file: !0,
                        password: !0,
                        image: !0
                    })
                        i.pseudos[e] = pt(e);
                    for (e in {
                        submit: !0,
                        reset: !0
                    })
                        i.pseudos[e] = ft(e);
                    function yt() {}
                    function xt(t) {
                        for (var e = 0, n = t.length, i = ""; e < n; e++)
                            i += t[e].value;
                        return i
                    }
                    function _t(t, e, n) {
                        var i = e.dir
                          , r = e.next
                          , s = r || i
                          , o = n && "parentNode" === s
                          , a = M++;
                        return e.first ? function(e, n, r) {
                            for (; e = e[i]; )
                                if (1 === e.nodeType || o)
                                    return t(e, n, r);
                            return !1
                        }
                        : function(e, n, l) {
                            var c, u, h, d = [w, a];
                            if (l) {
                                for (; e = e[i]; )
                                    if ((1 === e.nodeType || o) && t(e, n, l))
                                        return !0
                            } else
                                for (; e = e[i]; )
                                    if (1 === e.nodeType || o)
                                        if (u = (h = e[_] || (e[_] = {}))[e.uniqueID] || (h[e.uniqueID] = {}),
                                        r && r === e.nodeName.toLowerCase())
                                            e = e[i] || e;
                                        else {
                                            if ((c = u[s]) && c[0] === w && c[1] === a)
                                                return d[2] = c[2];
                                            if (u[s] = d,
                                            d[2] = t(e, n, l))
                                                return !0
                                        }
                            return !1
                        }
                    }
                    function bt(t) {
                        return t.length > 1 ? function(e, n, i) {
                            for (var r = t.length; r--; )
                                if (!t[r](e, n, i))
                                    return !1;
                            return !0
                        }
                        : t[0]
                    }
                    function wt(t, e, n, i, r) {
                        for (var s, o = [], a = 0, l = t.length, c = null != e; a < l; a++)
                            (s = t[a]) && (n && !n(s, i, r) || (o.push(s),
                            c && e.push(a)));
                        return o
                    }
                    function Mt(t, e, n, i, r, s) {
                        return i && !i[_] && (i = Mt(i)),
                        r && !r[_] && (r = Mt(r, s)),
                        ct((function(s, o, a, l) {
                            var c, u, h, d = [], p = [], f = o.length, m = s || function(t, e, n) {
                                for (var i = 0, r = e.length; i < r; i++)
                                    at(t, e[i], n);
                                return n
                            }(e || "*", a.nodeType ? [a] : a, []), g = !t || !s && e ? m : wt(m, d, t, a, l), v = n ? r || (s ? t : f || i) ? [] : o : g;
                            if (n && n(g, v, a, l),
                            i)
                                for (c = wt(v, p),
                                i(c, [], a, l),
                                u = c.length; u--; )
                                    (h = c[u]) && (v[p[u]] = !(g[p[u]] = h));
                            if (s) {
                                if (r || t) {
                                    if (r) {
                                        for (c = [],
                                        u = v.length; u--; )
                                            (h = v[u]) && c.push(g[u] = h);
                                        r(null, v = [], c, l)
                                    }
                                    for (u = v.length; u--; )
                                        (h = v[u]) && (c = r ? N(s, h) : d[u]) > -1 && (s[c] = !(o[c] = h))
                                }
                            } else
                                v = wt(v === o ? v.splice(f, v.length) : v),
                                r ? r(null, o, v, l) : I.apply(o, v)
                        }
                        ))
                    }
                    function St(t) {
                        for (var e, n, r, s = t.length, o = i.relative[t[0].type], a = o || i.relative[" "], l = o ? 1 : 0, u = _t((function(t) {
                            return t === e
                        }
                        ), a, !0), h = _t((function(t) {
                            return N(e, t) > -1
                        }
                        ), a, !0), d = [function(t, n, i) {
                            var r = !o && (i || n !== c) || ((e = n).nodeType ? u(t, n, i) : h(t, n, i));
                            return e = null,
                            r
                        }
                        ]; l < s; l++)
                            if (n = i.relative[t[l].type])
                                d = [_t(bt(d), n)];
                            else {
                                if ((n = i.filter[t[l].type].apply(null, t[l].matches))[_]) {
                                    for (r = ++l; r < s && !i.relative[t[r].type]; r++)
                                        ;
                                    return Mt(l > 1 && bt(d), l > 1 && xt(t.slice(0, l - 1).concat({
                                        value: " " === t[l - 2].type ? "*" : ""
                                    })).replace(G, "$1"), n, l < r && St(t.slice(l, r)), r < s && St(t = t.slice(r)), r < s && xt(t))
                                }
                                d.push(n)
                            }
                        return bt(d)
                    }
                    return yt.prototype = i.filters = i.pseudos,
                    i.setFilters = new yt,
                    o = at.tokenize = function(t, e) {
                        var n, r, s, o, a, l, c, u = T[t + " "];
                        if (u)
                            return e ? 0 : u.slice(0);
                        for (a = t,
                        l = [],
                        c = i.preFilter; a; ) {
                            for (o in n && !(r = V.exec(a)) || (r && (a = a.slice(r[0].length) || a),
                            l.push(s = [])),
                            n = !1,
                            (r = W.exec(a)) && (n = r.shift(),
                            s.push({
                                value: n,
                                type: r[0].replace(G, " ")
                            }),
                            a = a.slice(n.length)),
                            i.filter)
                                !(r = Y[o].exec(a)) || c[o] && !(r = c[o](r)) || (n = r.shift(),
                                s.push({
                                    value: n,
                                    type: o,
                                    matches: r
                                }),
                                a = a.slice(n.length));
                            if (!n)
                                break
                        }
                        return e ? a.length : a ? at.error(t) : T(t, l).slice(0)
                    }
                    ,
                    a = at.compile = function(t, e) {
                        var n, r = [], s = [], a = E[t + " "];
                        if (!a) {
                            for (e || (e = o(t)),
                            n = e.length; n--; )
                                (a = St(e[n]))[_] ? r.push(a) : s.push(a);
                            (a = E(t, function(t, e) {
                                var n = e.length > 0
                                  , r = t.length > 0
                                  , s = function(s, o, a, l, u) {
                                    var h, f, g, v = 0, y = "0", x = s && [], _ = [], b = c, M = s || r && i.find.TAG("*", u), S = w += null == b ? 1 : Math.random() || .1, T = M.length;
                                    for (u && (c = o == p || o || u); y !== T && null != (h = M[y]); y++) {
                                        if (r && h) {
                                            for (f = 0,
                                            o || h.ownerDocument == p || (d(h),
                                            a = !m); g = t[f++]; )
                                                if (g(h, o || p, a)) {
                                                    l.push(h);
                                                    break
                                                }
                                            u && (w = S)
                                        }
                                        n && ((h = !g && h) && v--,
                                        s && x.push(h))
                                    }
                                    if (v += y,
                                    n && y !== v) {
                                        for (f = 0; g = e[f++]; )
                                            g(x, _, o, a);
                                        if (s) {
                                            if (v > 0)
                                                for (; y--; )
                                                    x[y] || _[y] || (_[y] = P.call(l));
                                            _ = wt(_)
                                        }
                                        I.apply(l, _),
                                        u && !s && _.length > 0 && v + e.length > 1 && at.uniqueSort(l)
                                    }
                                    return u && (w = S,
                                    c = b),
                                    x
                                };
                                return n ? ct(s) : s
                            }(s, r))).selector = t
                        }
                        return a
                    }
                    ,
                    l = at.select = function(t, e, n, r) {
                        var s, l, c, u, h, d = "function" == typeof t && t, p = !r && o(t = d.selector || t);
                        if (n = n || [],
                        1 === p.length) {
                            if ((l = p[0] = p[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === e.nodeType && m && i.relative[l[1].type]) {
                                if (!(e = (i.find.ID(c.matches[0].replace(et, nt), e) || [])[0]))
                                    return n;
                                d && (e = e.parentNode),
                                t = t.slice(l.shift().value.length)
                            }
                            for (s = Y.needsContext.test(t) ? 0 : l.length; s-- && (c = l[s],
                            !i.relative[u = c.type]); )
                                if ((h = i.find[u]) && (r = h(c.matches[0].replace(et, nt), tt.test(l[0].type) && vt(e.parentNode) || e))) {
                                    if (l.splice(s, 1),
                                    !(t = r.length && xt(l)))
                                        return I.apply(n, r),
                                        n;
                                    break
                                }
                        }
                        return (d || a(t, p))(r, e, !m, n, !e || tt.test(t) && vt(e.parentNode) || e),
                        n
                    }
                    ,
                    n.sortStable = _.split("").sort(C).join("") === _,
                    n.detectDuplicates = !!h,
                    d(),
                    n.sortDetached = ut((function(t) {
                        return 1 & t.compareDocumentPosition(p.createElement("fieldset"))
                    }
                    )),
                    ut((function(t) {
                        return t.innerHTML = "<a href='#'></a>",
                        "#" === t.firstChild.getAttribute("href")
                    }
                    )) || ht("type|href|height|width", (function(t, e, n) {
                        if (!n)
                            return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
                    }
                    )),
                    n.attributes && ut((function(t) {
                        return t.innerHTML = "<input/>",
                        t.firstChild.setAttribute("value", ""),
                        "" === t.firstChild.getAttribute("value")
                    }
                    )) || ht("value", (function(t, e, n) {
                        if (!n && "input" === t.nodeName.toLowerCase())
                            return t.defaultValue
                    }
                    )),
                    ut((function(t) {
                        return null == t.getAttribute("disabled")
                    }
                    )) || ht(k, (function(t, e, n) {
                        var i;
                        if (!n)
                            return !0 === t[e] ? e.toLowerCase() : (i = t.getAttributeNode(e)) && i.specified ? i.value : null
                    }
                    )),
                    at
                }(i);
                S.find = E,
                S.expr = E.selectors,
                S.expr[":"] = S.expr.pseudos,
                S.uniqueSort = S.unique = E.uniqueSort,
                S.text = E.getText,
                S.isXMLDoc = E.isXML,
                S.contains = E.contains,
                S.escapeSelector = E.escape;
                var A = function(t, e, n) {
                    for (var i = [], r = void 0 !== n; (t = t[e]) && 9 !== t.nodeType; )
                        if (1 === t.nodeType) {
                            if (r && S(t).is(n))
                                break;
                            i.push(t)
                        }
                    return i
                }
                  , C = function(t, e) {
                    for (var n = []; t; t = t.nextSibling)
                        1 === t.nodeType && t !== e && n.push(t);
                    return n
                }
                  , R = S.expr.match.needsContext;
                function L(t, e) {
                    return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
                }
                var P = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
                function D(t, e, n) {
                    return v(e) ? S.grep(t, (function(t, i) {
                        return !!e.call(t, i, t) !== n
                    }
                    )) : e.nodeType ? S.grep(t, (function(t) {
                        return t === e !== n
                    }
                    )) : "string" != typeof e ? S.grep(t, (function(t) {
                        return u.call(e, t) > -1 !== n
                    }
                    )) : S.filter(e, t, n)
                }
                S.filter = function(t, e, n) {
                    var i = e[0];
                    return n && (t = ":not(" + t + ")"),
                    1 === e.length && 1 === i.nodeType ? S.find.matchesSelector(i, t) ? [i] : [] : S.find.matches(t, S.grep(e, (function(t) {
                        return 1 === t.nodeType
                    }
                    )))
                }
                ,
                S.fn.extend({
                    find: function(t) {
                        var e, n, i = this.length, r = this;
                        if ("string" != typeof t)
                            return this.pushStack(S(t).filter((function() {
                                for (e = 0; e < i; e++)
                                    if (S.contains(r[e], this))
                                        return !0
                            }
                            )));
                        for (n = this.pushStack([]),
                        e = 0; e < i; e++)
                            S.find(t, r[e], n);
                        return i > 1 ? S.uniqueSort(n) : n
                    },
                    filter: function(t) {
                        return this.pushStack(D(this, t || [], !1))
                    },
                    not: function(t) {
                        return this.pushStack(D(this, t || [], !0))
                    },
                    is: function(t) {
                        return !!D(this, "string" == typeof t && R.test(t) ? S(t) : t || [], !1).length
                    }
                });
                var I, O = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
                (S.fn.init = function(t, e, n) {
                    var i, r;
                    if (!t)
                        return this;
                    if (n = n || I,
                    "string" == typeof t) {
                        if (!(i = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : O.exec(t)) || !i[1] && e)
                            return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);
                        if (i[1]) {
                            if (e = e instanceof S ? e[0] : e,
                            S.merge(this, S.parseHTML(i[1], e && e.nodeType ? e.ownerDocument || e : x, !0)),
                            P.test(i[1]) && S.isPlainObject(e))
                                for (i in e)
                                    v(this[i]) ? this[i](e[i]) : this.attr(i, e[i]);
                            return this
                        }
                        return (r = x.getElementById(i[2])) && (this[0] = r,
                        this.length = 1),
                        this
                    }
                    return t.nodeType ? (this[0] = t,
                    this.length = 1,
                    this) : v(t) ? void 0 !== n.ready ? n.ready(t) : t(S) : S.makeArray(t, this)
                }
                ).prototype = S.fn,
                I = S(x);
                var N = /^(?:parents|prev(?:Until|All))/
                  , k = {
                    children: !0,
                    contents: !0,
                    next: !0,
                    prev: !0
                };
                function z(t, e) {
                    for (; (t = t[e]) && 1 !== t.nodeType; )
                        ;
                    return t
                }
                S.fn.extend({
                    has: function(t) {
                        var e = S(t, this)
                          , n = e.length;
                        return this.filter((function() {
                            for (var t = 0; t < n; t++)
                                if (S.contains(this, e[t]))
                                    return !0
                        }
                        ))
                    },
                    closest: function(t, e) {
                        var n, i = 0, r = this.length, s = [], o = "string" != typeof t && S(t);
                        if (!R.test(t))
                            for (; i < r; i++)
                                for (n = this[i]; n && n !== e; n = n.parentNode)
                                    if (n.nodeType < 11 && (o ? o.index(n) > -1 : 1 === n.nodeType && S.find.matchesSelector(n, t))) {
                                        s.push(n);
                                        break
                                    }
                        return this.pushStack(s.length > 1 ? S.uniqueSort(s) : s)
                    },
                    index: function(t) {
                        return t ? "string" == typeof t ? u.call(S(t), this[0]) : u.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                    },
                    add: function(t, e) {
                        return this.pushStack(S.uniqueSort(S.merge(this.get(), S(t, e))))
                    },
                    addBack: function(t) {
                        return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
                    }
                }),
                S.each({
                    parent: function(t) {
                        var e = t.parentNode;
                        return e && 11 !== e.nodeType ? e : null
                    },
                    parents: function(t) {
                        return A(t, "parentNode")
                    },
                    parentsUntil: function(t, e, n) {
                        return A(t, "parentNode", n)
                    },
                    next: function(t) {
                        return z(t, "nextSibling")
                    },
                    prev: function(t) {
                        return z(t, "previousSibling")
                    },
                    nextAll: function(t) {
                        return A(t, "nextSibling")
                    },
                    prevAll: function(t) {
                        return A(t, "previousSibling")
                    },
                    nextUntil: function(t, e, n) {
                        return A(t, "nextSibling", n)
                    },
                    prevUntil: function(t, e, n) {
                        return A(t, "previousSibling", n)
                    },
                    siblings: function(t) {
                        return C((t.parentNode || {}).firstChild, t)
                    },
                    children: function(t) {
                        return C(t.firstChild)
                    },
                    contents: function(t) {
                        return null != t.contentDocument && o(t.contentDocument) ? t.contentDocument : (L(t, "template") && (t = t.content || t),
                        S.merge([], t.childNodes))
                    }
                }, (function(t, e) {
                    S.fn[t] = function(n, i) {
                        var r = S.map(this, e, n);
                        return "Until" !== t.slice(-5) && (i = n),
                        i && "string" == typeof i && (r = S.filter(i, r)),
                        this.length > 1 && (k[t] || S.uniqueSort(r),
                        N.test(t) && r.reverse()),
                        this.pushStack(r)
                    }
                }
                ));
                var H = /[^\x20\t\r\n\f]+/g;
                function B(t) {
                    return t
                }
                function F(t) {
                    throw t
                }
                function U(t, e, n, i) {
                    var r;
                    try {
                        t && v(r = t.promise) ? r.call(t).done(e).fail(n) : t && v(r = t.then) ? r.call(t, e, n) : e.apply(void 0, [t].slice(i))
                    } catch (t) {
                        n.apply(void 0, [t])
                    }
                }
                S.Callbacks = function(t) {
                    t = "string" == typeof t ? function(t) {
                        var e = {};
                        return S.each(t.match(H) || [], (function(t, n) {
                            e[n] = !0
                        }
                        )),
                        e
                    }(t) : S.extend({}, t);
                    var e, n, i, r, s = [], o = [], a = -1, l = function() {
                        for (r = r || t.once,
                        i = e = !0; o.length; a = -1)
                            for (n = o.shift(); ++a < s.length; )
                                !1 === s[a].apply(n[0], n[1]) && t.stopOnFalse && (a = s.length,
                                n = !1);
                        t.memory || (n = !1),
                        e = !1,
                        r && (s = n ? [] : "")
                    }, c = {
                        add: function() {
                            return s && (n && !e && (a = s.length - 1,
                            o.push(n)),
                            function e(n) {
                                S.each(n, (function(n, i) {
                                    v(i) ? t.unique && c.has(i) || s.push(i) : i && i.length && "string" !== w(i) && e(i)
                                }
                                ))
                            }(arguments),
                            n && !e && l()),
                            this
                        },
                        remove: function() {
                            return S.each(arguments, (function(t, e) {
                                for (var n; (n = S.inArray(e, s, n)) > -1; )
                                    s.splice(n, 1),
                                    n <= a && a--
                            }
                            )),
                            this
                        },
                        has: function(t) {
                            return t ? S.inArray(t, s) > -1 : s.length > 0
                        },
                        empty: function() {
                            return s && (s = []),
                            this
                        },
                        disable: function() {
                            return r = o = [],
                            s = n = "",
                            this
                        },
                        disabled: function() {
                            return !s
                        },
                        lock: function() {
                            return r = o = [],
                            n || e || (s = n = ""),
                            this
                        },
                        locked: function() {
                            return !!r
                        },
                        fireWith: function(t, n) {
                            return r || (n = [t, (n = n || []).slice ? n.slice() : n],
                            o.push(n),
                            e || l()),
                            this
                        },
                        fire: function() {
                            return c.fireWith(this, arguments),
                            this
                        },
                        fired: function() {
                            return !!i
                        }
                    };
                    return c
                }
                ,
                S.extend({
                    Deferred: function(t) {
                        var e = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]]
                          , n = "pending"
                          , r = {
                            state: function() {
                                return n
                            },
                            always: function() {
                                return s.done(arguments).fail(arguments),
                                this
                            },
                            catch: function(t) {
                                return r.then(null, t)
                            },
                            pipe: function() {
                                var t = arguments;
                                return S.Deferred((function(n) {
                                    S.each(e, (function(e, i) {
                                        var r = v(t[i[4]]) && t[i[4]];
                                        s[i[1]]((function() {
                                            var t = r && r.apply(this, arguments);
                                            t && v(t.promise) ? t.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, r ? [t] : arguments)
                                        }
                                        ))
                                    }
                                    )),
                                    t = null
                                }
                                )).promise()
                            },
                            then: function(t, n, r) {
                                var s = 0;
                                function o(t, e, n, r) {
                                    return function() {
                                        var a = this
                                          , l = arguments
                                          , c = function() {
                                            var i, c;
                                            if (!(t < s)) {
                                                if ((i = n.apply(a, l)) === e.promise())
                                                    throw new TypeError("Thenable self-resolution");
                                                c = i && ("object" == typeof i || "function" == typeof i) && i.then,
                                                v(c) ? r ? c.call(i, o(s, e, B, r), o(s, e, F, r)) : (s++,
                                                c.call(i, o(s, e, B, r), o(s, e, F, r), o(s, e, B, e.notifyWith))) : (n !== B && (a = void 0,
                                                l = [i]),
                                                (r || e.resolveWith)(a, l))
                                            }
                                        }
                                          , u = r ? c : function() {
                                            try {
                                                c()
                                            } catch (i) {
                                                S.Deferred.exceptionHook && S.Deferred.exceptionHook(i, u.stackTrace),
                                                t + 1 >= s && (n !== F && (a = void 0,
                                                l = [i]),
                                                e.rejectWith(a, l))
                                            }
                                        }
                                        ;
                                        t ? u() : (S.Deferred.getStackHook && (u.stackTrace = S.Deferred.getStackHook()),
                                        i.setTimeout(u))
                                    }
                                }
                                return S.Deferred((function(i) {
                                    e[0][3].add(o(0, i, v(r) ? r : B, i.notifyWith)),
                                    e[1][3].add(o(0, i, v(t) ? t : B)),
                                    e[2][3].add(o(0, i, v(n) ? n : F))
                                }
                                )).promise()
                            },
                            promise: function(t) {
                                return null != t ? S.extend(t, r) : r
                            }
                        }
                          , s = {};
                        return S.each(e, (function(t, i) {
                            var o = i[2]
                              , a = i[5];
                            r[i[1]] = o.add,
                            a && o.add((function() {
                                n = a
                            }
                            ), e[3 - t][2].disable, e[3 - t][3].disable, e[0][2].lock, e[0][3].lock),
                            o.add(i[3].fire),
                            s[i[0]] = function() {
                                return s[i[0] + "With"](this === s ? void 0 : this, arguments),
                                this
                            }
                            ,
                            s[i[0] + "With"] = o.fireWith
                        }
                        )),
                        r.promise(s),
                        t && t.call(s, s),
                        s
                    },
                    when: function(t) {
                        var e = arguments.length
                          , n = e
                          , i = Array(n)
                          , r = a.call(arguments)
                          , s = S.Deferred()
                          , o = function(t) {
                            return function(n) {
                                i[t] = this,
                                r[t] = arguments.length > 1 ? a.call(arguments) : n,
                                --e || s.resolveWith(i, r)
                            }
                        };
                        if (e <= 1 && (U(t, s.done(o(n)).resolve, s.reject, !e),
                        "pending" === s.state() || v(r[n] && r[n].then)))
                            return s.then();
                        for (; n--; )
                            U(r[n], o(n), s.reject);
                        return s.promise()
                    }
                });
                var G = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
                S.Deferred.exceptionHook = function(t, e) {
                    i.console && i.console.warn && t && G.test(t.name) && i.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e)
                }
                ,
                S.readyException = function(t) {
                    i.setTimeout((function() {
                        throw t
                    }
                    ))
                }
                ;
                var V = S.Deferred();
                function W() {
                    x.removeEventListener("DOMContentLoaded", W),
                    i.removeEventListener("load", W),
                    S.ready()
                }
                S.fn.ready = function(t) {
                    return V.then(t).catch((function(t) {
                        S.readyException(t)
                    }
                    )),
                    this
                }
                ,
                S.extend({
                    isReady: !1,
                    readyWait: 1,
                    ready: function(t) {
                        (!0 === t ? --S.readyWait : S.isReady) || (S.isReady = !0,
                        !0 !== t && --S.readyWait > 0 || V.resolveWith(x, [S]))
                    }
                }),
                S.ready.then = V.then,
                "complete" === x.readyState || "loading" !== x.readyState && !x.documentElement.doScroll ? i.setTimeout(S.ready) : (x.addEventListener("DOMContentLoaded", W),
                i.addEventListener("load", W));
                var j = function(t, e, n, i, r, s, o) {
                    var a = 0
                      , l = t.length
                      , c = null == n;
                    if ("object" === w(n))
                        for (a in r = !0,
                        n)
                            j(t, e, a, n[a], !0, s, o);
                    else if (void 0 !== i && (r = !0,
                    v(i) || (o = !0),
                    c && (o ? (e.call(t, i),
                    e = null) : (c = e,
                    e = function(t, e, n) {
                        return c.call(S(t), n)
                    }
                    )),
                    e))
                        for (; a < l; a++)
                            e(t[a], n, o ? i : i.call(t[a], a, e(t[a], n)));
                    return r ? t : c ? e.call(t) : l ? e(t[0], n) : s
                }
                  , q = /^-ms-/
                  , X = /-([a-z])/g;
                function Y(t, e) {
                    return e.toUpperCase()
                }
                function J(t) {
                    return t.replace(q, "ms-").replace(X, Y)
                }
                var Z = function(t) {
                    return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
                };
                function K() {
                    this.expando = S.expando + K.uid++
                }
                K.uid = 1,
                K.prototype = {
                    cache: function(t) {
                        var e = t[this.expando];
                        return e || (e = {},
                        Z(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                            value: e,
                            configurable: !0
                        }))),
                        e
                    },
                    set: function(t, e, n) {
                        var i, r = this.cache(t);
                        if ("string" == typeof e)
                            r[J(e)] = n;
                        else
                            for (i in e)
                                r[J(i)] = e[i];
                        return r
                    },
                    get: function(t, e) {
                        return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][J(e)]
                    },
                    access: function(t, e, n) {
                        return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t, e, n),
                        void 0 !== n ? n : e)
                    },
                    remove: function(t, e) {
                        var n, i = t[this.expando];
                        if (void 0 !== i) {
                            if (void 0 !== e) {
                                n = (e = Array.isArray(e) ? e.map(J) : (e = J(e))in i ? [e] : e.match(H) || []).length;
                                for (; n--; )
                                    delete i[e[n]]
                            }
                            (void 0 === e || S.isEmptyObject(i)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
                        }
                    },
                    hasData: function(t) {
                        var e = t[this.expando];
                        return void 0 !== e && !S.isEmptyObject(e)
                    }
                };
                var Q = new K
                  , $ = new K
                  , tt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
                  , et = /[A-Z]/g;
                function nt(t, e, n) {
                    var i;
                    if (void 0 === n && 1 === t.nodeType)
                        if (i = "data-" + e.replace(et, "-$&").toLowerCase(),
                        "string" == typeof (n = t.getAttribute(i))) {
                            try {
                                n = function(t) {
                                    return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : tt.test(t) ? JSON.parse(t) : t)
                                }(n)
                            } catch (t) {}
                            $.set(t, e, n)
                        } else
                            n = void 0;
                    return n
                }
                S.extend({
                    hasData: function(t) {
                        return $.hasData(t) || Q.hasData(t)
                    },
                    data: function(t, e, n) {
                        return $.access(t, e, n)
                    },
                    removeData: function(t, e) {
                        $.remove(t, e)
                    },
                    _data: function(t, e, n) {
                        return Q.access(t, e, n)
                    },
                    _removeData: function(t, e) {
                        Q.remove(t, e)
                    }
                }),
                S.fn.extend({
                    data: function(t, e) {
                        var n, i, r, s = this[0], o = s && s.attributes;
                        if (void 0 === t) {
                            if (this.length && (r = $.get(s),
                            1 === s.nodeType && !Q.get(s, "hasDataAttrs"))) {
                                for (n = o.length; n--; )
                                    o[n] && 0 === (i = o[n].name).indexOf("data-") && (i = J(i.slice(5)),
                                    nt(s, i, r[i]));
                                Q.set(s, "hasDataAttrs", !0)
                            }
                            return r
                        }
                        return "object" == typeof t ? this.each((function() {
                            $.set(this, t)
                        }
                        )) : j(this, (function(e) {
                            var n;
                            if (s && void 0 === e)
                                return void 0 !== (n = $.get(s, t)) || void 0 !== (n = nt(s, t)) ? n : void 0;
                            this.each((function() {
                                $.set(this, t, e)
                            }
                            ))
                        }
                        ), null, e, arguments.length > 1, null, !0)
                    },
                    removeData: function(t) {
                        return this.each((function() {
                            $.remove(this, t)
                        }
                        ))
                    }
                }),
                S.extend({
                    queue: function(t, e, n) {
                        var i;
                        if (t)
                            return e = (e || "fx") + "queue",
                            i = Q.get(t, e),
                            n && (!i || Array.isArray(n) ? i = Q.access(t, e, S.makeArray(n)) : i.push(n)),
                            i || []
                    },
                    dequeue: function(t, e) {
                        e = e || "fx";
                        var n = S.queue(t, e)
                          , i = n.length
                          , r = n.shift()
                          , s = S._queueHooks(t, e);
                        "inprogress" === r && (r = n.shift(),
                        i--),
                        r && ("fx" === e && n.unshift("inprogress"),
                        delete s.stop,
                        r.call(t, (function() {
                            S.dequeue(t, e)
                        }
                        ), s)),
                        !i && s && s.empty.fire()
                    },
                    _queueHooks: function(t, e) {
                        var n = e + "queueHooks";
                        return Q.get(t, n) || Q.access(t, n, {
                            empty: S.Callbacks("once memory").add((function() {
                                Q.remove(t, [e + "queue", n])
                            }
                            ))
                        })
                    }
                }),
                S.fn.extend({
                    queue: function(t, e) {
                        var n = 2;
                        return "string" != typeof t && (e = t,
                        t = "fx",
                        n--),
                        arguments.length < n ? S.queue(this[0], t) : void 0 === e ? this : this.each((function() {
                            var n = S.queue(this, t, e);
                            S._queueHooks(this, t),
                            "fx" === t && "inprogress" !== n[0] && S.dequeue(this, t)
                        }
                        ))
                    },
                    dequeue: function(t) {
                        return this.each((function() {
                            S.dequeue(this, t)
                        }
                        ))
                    },
                    clearQueue: function(t) {
                        return this.queue(t || "fx", [])
                    },
                    promise: function(t, e) {
                        var n, i = 1, r = S.Deferred(), s = this, o = this.length, a = function() {
                            --i || r.resolveWith(s, [s])
                        };
                        for ("string" != typeof t && (e = t,
                        t = void 0),
                        t = t || "fx"; o--; )
                            (n = Q.get(s[o], t + "queueHooks")) && n.empty && (i++,
                            n.empty.add(a));
                        return a(),
                        r.promise(e)
                    }
                });
                var it = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
                  , rt = new RegExp("^(?:([+-])=|)(" + it + ")([a-z%]*)$","i")
                  , st = ["Top", "Right", "Bottom", "Left"]
                  , ot = x.documentElement
                  , at = function(t) {
                    return S.contains(t.ownerDocument, t)
                }
                  , lt = {
                    composed: !0
                };
                ot.getRootNode && (at = function(t) {
                    return S.contains(t.ownerDocument, t) || t.getRootNode(lt) === t.ownerDocument
                }
                );
                var ct = function(t, e) {
                    return "none" === (t = e || t).style.display || "" === t.style.display && at(t) && "none" === S.css(t, "display")
                };
                function ut(t, e, n, i) {
                    var r, s, o = 20, a = i ? function() {
                        return i.cur()
                    }
                    : function() {
                        return S.css(t, e, "")
                    }
                    , l = a(), c = n && n[3] || (S.cssNumber[e] ? "" : "px"), u = t.nodeType && (S.cssNumber[e] || "px" !== c && +l) && rt.exec(S.css(t, e));
                    if (u && u[3] !== c) {
                        for (l /= 2,
                        c = c || u[3],
                        u = +l || 1; o--; )
                            S.style(t, e, u + c),
                            (1 - s) * (1 - (s = a() / l || .5)) <= 0 && (o = 0),
                            u /= s;
                        u *= 2,
                        S.style(t, e, u + c),
                        n = n || []
                    }
                    return n && (u = +u || +l || 0,
                    r = n[1] ? u + (n[1] + 1) * n[2] : +n[2],
                    i && (i.unit = c,
                    i.start = u,
                    i.end = r)),
                    r
                }
                var ht = {};
                function dt(t) {
                    var e, n = t.ownerDocument, i = t.nodeName, r = ht[i];
                    return r || (e = n.body.appendChild(n.createElement(i)),
                    r = S.css(e, "display"),
                    e.parentNode.removeChild(e),
                    "none" === r && (r = "block"),
                    ht[i] = r,
                    r)
                }
                function pt(t, e) {
                    for (var n, i, r = [], s = 0, o = t.length; s < o; s++)
                        (i = t[s]).style && (n = i.style.display,
                        e ? ("none" === n && (r[s] = Q.get(i, "display") || null,
                        r[s] || (i.style.display = "")),
                        "" === i.style.display && ct(i) && (r[s] = dt(i))) : "none" !== n && (r[s] = "none",
                        Q.set(i, "display", n)));
                    for (s = 0; s < o; s++)
                        null != r[s] && (t[s].style.display = r[s]);
                    return t
                }
                S.fn.extend({
                    show: function() {
                        return pt(this, !0)
                    },
                    hide: function() {
                        return pt(this)
                    },
                    toggle: function(t) {
                        return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each((function() {
                            ct(this) ? S(this).show() : S(this).hide()
                        }
                        ))
                    }
                });
                var ft, mt, gt = /^(?:checkbox|radio)$/i, vt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, yt = /^$|^module$|\/(?:java|ecma)script/i;
                ft = x.createDocumentFragment().appendChild(x.createElement("div")),
                (mt = x.createElement("input")).setAttribute("type", "radio"),
                mt.setAttribute("checked", "checked"),
                mt.setAttribute("name", "t"),
                ft.appendChild(mt),
                g.checkClone = ft.cloneNode(!0).cloneNode(!0).lastChild.checked,
                ft.innerHTML = "<textarea>x</textarea>",
                g.noCloneChecked = !!ft.cloneNode(!0).lastChild.defaultValue,
                ft.innerHTML = "<option></option>",
                g.option = !!ft.lastChild;
                var xt = {
                    thead: [1, "<table>", "</table>"],
                    col: [2, "<table><colgroup>", "</colgroup></table>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                    _default: [0, "", ""]
                };
                function _t(t, e) {
                    var n;
                    return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [],
                    void 0 === e || e && L(t, e) ? S.merge([t], n) : n
                }
                function bt(t, e) {
                    for (var n = 0, i = t.length; n < i; n++)
                        Q.set(t[n], "globalEval", !e || Q.get(e[n], "globalEval"))
                }
                xt.tbody = xt.tfoot = xt.colgroup = xt.caption = xt.thead,
                xt.th = xt.td,
                g.option || (xt.optgroup = xt.option = [1, "<select multiple='multiple'>", "</select>"]);
                var wt = /<|&#?\w+;/;
                function Mt(t, e, n, i, r) {
                    for (var s, o, a, l, c, u, h = e.createDocumentFragment(), d = [], p = 0, f = t.length; p < f; p++)
                        if ((s = t[p]) || 0 === s)
                            if ("object" === w(s))
                                S.merge(d, s.nodeType ? [s] : s);
                            else if (wt.test(s)) {
                                for (o = o || h.appendChild(e.createElement("div")),
                                a = (vt.exec(s) || ["", ""])[1].toLowerCase(),
                                l = xt[a] || xt._default,
                                o.innerHTML = l[1] + S.htmlPrefilter(s) + l[2],
                                u = l[0]; u--; )
                                    o = o.lastChild;
                                S.merge(d, o.childNodes),
                                (o = h.firstChild).textContent = ""
                            } else
                                d.push(e.createTextNode(s));
                    for (h.textContent = "",
                    p = 0; s = d[p++]; )
                        if (i && S.inArray(s, i) > -1)
                            r && r.push(s);
                        else if (c = at(s),
                        o = _t(h.appendChild(s), "script"),
                        c && bt(o),
                        n)
                            for (u = 0; s = o[u++]; )
                                yt.test(s.type || "") && n.push(s);
                    return h
                }
                var St = /^([^.]*)(?:\.(.+)|)/;
                function Tt() {
                    return !0
                }
                function Et() {
                    return !1
                }
                function At(t, e) {
                    return t === function() {
                        try {
                            return x.activeElement
                        } catch (t) {}
                    }() == ("focus" === e)
                }
                function Ct(t, e, n, i, r, s) {
                    var o, a;
                    if ("object" == typeof e) {
                        for (a in "string" != typeof n && (i = i || n,
                        n = void 0),
                        e)
                            Ct(t, a, n, i, e[a], s);
                        return t
                    }
                    if (null == i && null == r ? (r = n,
                    i = n = void 0) : null == r && ("string" == typeof n ? (r = i,
                    i = void 0) : (r = i,
                    i = n,
                    n = void 0)),
                    !1 === r)
                        r = Et;
                    else if (!r)
                        return t;
                    return 1 === s && (o = r,
                    (r = function(t) {
                        return S().off(t),
                        o.apply(this, arguments)
                    }
                    ).guid = o.guid || (o.guid = S.guid++)),
                    t.each((function() {
                        S.event.add(this, e, r, i, n)
                    }
                    ))
                }
                function Rt(t, e, n) {
                    n ? (Q.set(t, e, !1),
                    S.event.add(t, e, {
                        namespace: !1,
                        handler: function(t) {
                            var i, r, s = Q.get(this, e);
                            if (1 & t.isTrigger && this[e]) {
                                if (s.length)
                                    (S.event.special[e] || {}).delegateType && t.stopPropagation();
                                else if (s = a.call(arguments),
                                Q.set(this, e, s),
                                i = n(this, e),
                                this[e](),
                                s !== (r = Q.get(this, e)) || i ? Q.set(this, e, !1) : r = {},
                                s !== r)
                                    return t.stopImmediatePropagation(),
                                    t.preventDefault(),
                                    r && r.value
                            } else
                                s.length && (Q.set(this, e, {
                                    value: S.event.trigger(S.extend(s[0], S.Event.prototype), s.slice(1), this)
                                }),
                                t.stopImmediatePropagation())
                        }
                    })) : void 0 === Q.get(t, e) && S.event.add(t, e, Tt)
                }
                S.event = {
                    global: {},
                    add: function(t, e, n, i, r) {
                        var s, o, a, l, c, u, h, d, p, f, m, g = Q.get(t);
                        if (Z(t))
                            for (n.handler && (n = (s = n).handler,
                            r = s.selector),
                            r && S.find.matchesSelector(ot, r),
                            n.guid || (n.guid = S.guid++),
                            (l = g.events) || (l = g.events = Object.create(null)),
                            (o = g.handle) || (o = g.handle = function(e) {
                                return void 0 !== S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0
                            }
                            ),
                            c = (e = (e || "").match(H) || [""]).length; c--; )
                                p = m = (a = St.exec(e[c]) || [])[1],
                                f = (a[2] || "").split(".").sort(),
                                p && (h = S.event.special[p] || {},
                                p = (r ? h.delegateType : h.bindType) || p,
                                h = S.event.special[p] || {},
                                u = S.extend({
                                    type: p,
                                    origType: m,
                                    data: i,
                                    handler: n,
                                    guid: n.guid,
                                    selector: r,
                                    needsContext: r && S.expr.match.needsContext.test(r),
                                    namespace: f.join(".")
                                }, s),
                                (d = l[p]) || ((d = l[p] = []).delegateCount = 0,
                                h.setup && !1 !== h.setup.call(t, i, f, o) || t.addEventListener && t.addEventListener(p, o)),
                                h.add && (h.add.call(t, u),
                                u.handler.guid || (u.handler.guid = n.guid)),
                                r ? d.splice(d.delegateCount++, 0, u) : d.push(u),
                                S.event.global[p] = !0)
                    },
                    remove: function(t, e, n, i, r) {
                        var s, o, a, l, c, u, h, d, p, f, m, g = Q.hasData(t) && Q.get(t);
                        if (g && (l = g.events)) {
                            for (c = (e = (e || "").match(H) || [""]).length; c--; )
                                if (p = m = (a = St.exec(e[c]) || [])[1],
                                f = (a[2] || "").split(".").sort(),
                                p) {
                                    for (h = S.event.special[p] || {},
                                    d = l[p = (i ? h.delegateType : h.bindType) || p] || [],
                                    a = a[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                                    o = s = d.length; s--; )
                                        u = d[s],
                                        !r && m !== u.origType || n && n.guid !== u.guid || a && !a.test(u.namespace) || i && i !== u.selector && ("**" !== i || !u.selector) || (d.splice(s, 1),
                                        u.selector && d.delegateCount--,
                                        h.remove && h.remove.call(t, u));
                                    o && !d.length && (h.teardown && !1 !== h.teardown.call(t, f, g.handle) || S.removeEvent(t, p, g.handle),
                                    delete l[p])
                                } else
                                    for (p in l)
                                        S.event.remove(t, p + e[c], n, i, !0);
                            S.isEmptyObject(l) && Q.remove(t, "handle events")
                        }
                    },
                    dispatch: function(t) {
                        var e, n, i, r, s, o, a = new Array(arguments.length), l = S.event.fix(t), c = (Q.get(this, "events") || Object.create(null))[l.type] || [], u = S.event.special[l.type] || {};
                        for (a[0] = l,
                        e = 1; e < arguments.length; e++)
                            a[e] = arguments[e];
                        if (l.delegateTarget = this,
                        !u.preDispatch || !1 !== u.preDispatch.call(this, l)) {
                            for (o = S.event.handlers.call(this, l, c),
                            e = 0; (r = o[e++]) && !l.isPropagationStopped(); )
                                for (l.currentTarget = r.elem,
                                n = 0; (s = r.handlers[n++]) && !l.isImmediatePropagationStopped(); )
                                    l.rnamespace && !1 !== s.namespace && !l.rnamespace.test(s.namespace) || (l.handleObj = s,
                                    l.data = s.data,
                                    void 0 !== (i = ((S.event.special[s.origType] || {}).handle || s.handler).apply(r.elem, a)) && !1 === (l.result = i) && (l.preventDefault(),
                                    l.stopPropagation()));
                            return u.postDispatch && u.postDispatch.call(this, l),
                            l.result
                        }
                    },
                    handlers: function(t, e) {
                        var n, i, r, s, o, a = [], l = e.delegateCount, c = t.target;
                        if (l && c.nodeType && !("click" === t.type && t.button >= 1))
                            for (; c !== this; c = c.parentNode || this)
                                if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
                                    for (s = [],
                                    o = {},
                                    n = 0; n < l; n++)
                                        void 0 === o[r = (i = e[n]).selector + " "] && (o[r] = i.needsContext ? S(r, this).index(c) > -1 : S.find(r, this, null, [c]).length),
                                        o[r] && s.push(i);
                                    s.length && a.push({
                                        elem: c,
                                        handlers: s
                                    })
                                }
                        return c = this,
                        l < e.length && a.push({
                            elem: c,
                            handlers: e.slice(l)
                        }),
                        a
                    },
                    addProp: function(t, e) {
                        Object.defineProperty(S.Event.prototype, t, {
                            enumerable: !0,
                            configurable: !0,
                            get: v(e) ? function() {
                                if (this.originalEvent)
                                    return e(this.originalEvent)
                            }
                            : function() {
                                if (this.originalEvent)
                                    return this.originalEvent[t]
                            }
                            ,
                            set: function(e) {
                                Object.defineProperty(this, t, {
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0,
                                    value: e
                                })
                            }
                        })
                    },
                    fix: function(t) {
                        return t[S.expando] ? t : new S.Event(t)
                    },
                    special: {
                        load: {
                            noBubble: !0
                        },
                        click: {
                            setup: function(t) {
                                var e = this || t;
                                return gt.test(e.type) && e.click && L(e, "input") && Rt(e, "click", Tt),
                                !1
                            },
                            trigger: function(t) {
                                var e = this || t;
                                return gt.test(e.type) && e.click && L(e, "input") && Rt(e, "click"),
                                !0
                            },
                            _default: function(t) {
                                var e = t.target;
                                return gt.test(e.type) && e.click && L(e, "input") && Q.get(e, "click") || L(e, "a")
                            }
                        },
                        beforeunload: {
                            postDispatch: function(t) {
                                void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                            }
                        }
                    }
                },
                S.removeEvent = function(t, e, n) {
                    t.removeEventListener && t.removeEventListener(e, n)
                }
                ,
                S.Event = function(t, e) {
                    if (!(this instanceof S.Event))
                        return new S.Event(t,e);
                    t && t.type ? (this.originalEvent = t,
                    this.type = t.type,
                    this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? Tt : Et,
                    this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target,
                    this.currentTarget = t.currentTarget,
                    this.relatedTarget = t.relatedTarget) : this.type = t,
                    e && S.extend(this, e),
                    this.timeStamp = t && t.timeStamp || Date.now(),
                    this[S.expando] = !0
                }
                ,
                S.Event.prototype = {
                    constructor: S.Event,
                    isDefaultPrevented: Et,
                    isPropagationStopped: Et,
                    isImmediatePropagationStopped: Et,
                    isSimulated: !1,
                    preventDefault: function() {
                        var t = this.originalEvent;
                        this.isDefaultPrevented = Tt,
                        t && !this.isSimulated && t.preventDefault()
                    },
                    stopPropagation: function() {
                        var t = this.originalEvent;
                        this.isPropagationStopped = Tt,
                        t && !this.isSimulated && t.stopPropagation()
                    },
                    stopImmediatePropagation: function() {
                        var t = this.originalEvent;
                        this.isImmediatePropagationStopped = Tt,
                        t && !this.isSimulated && t.stopImmediatePropagation(),
                        this.stopPropagation()
                    }
                },
                S.each({
                    altKey: !0,
                    bubbles: !0,
                    cancelable: !0,
                    changedTouches: !0,
                    ctrlKey: !0,
                    detail: !0,
                    eventPhase: !0,
                    metaKey: !0,
                    pageX: !0,
                    pageY: !0,
                    shiftKey: !0,
                    view: !0,
                    char: !0,
                    code: !0,
                    charCode: !0,
                    key: !0,
                    keyCode: !0,
                    button: !0,
                    buttons: !0,
                    clientX: !0,
                    clientY: !0,
                    offsetX: !0,
                    offsetY: !0,
                    pointerId: !0,
                    pointerType: !0,
                    screenX: !0,
                    screenY: !0,
                    targetTouches: !0,
                    toElement: !0,
                    touches: !0,
                    which: !0
                }, S.event.addProp),
                S.each({
                    focus: "focusin",
                    blur: "focusout"
                }, (function(t, e) {
                    S.event.special[t] = {
                        setup: function() {
                            return Rt(this, t, At),
                            !1
                        },
                        trigger: function() {
                            return Rt(this, t),
                            !0
                        },
                        _default: function() {
                            return !0
                        },
                        delegateType: e
                    }
                }
                )),
                S.each({
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, (function(t, e) {
                    S.event.special[t] = {
                        delegateType: e,
                        bindType: e,
                        handle: function(t) {
                            var n, i = this, r = t.relatedTarget, s = t.handleObj;
                            return r && (r === i || S.contains(i, r)) || (t.type = s.origType,
                            n = s.handler.apply(this, arguments),
                            t.type = e),
                            n
                        }
                    }
                }
                )),
                S.fn.extend({
                    on: function(t, e, n, i) {
                        return Ct(this, t, e, n, i)
                    },
                    one: function(t, e, n, i) {
                        return Ct(this, t, e, n, i, 1)
                    },
                    off: function(t, e, n) {
                        var i, r;
                        if (t && t.preventDefault && t.handleObj)
                            return i = t.handleObj,
                            S(t.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler),
                            this;
                        if ("object" == typeof t) {
                            for (r in t)
                                this.off(r, e, t[r]);
                            return this
                        }
                        return !1 !== e && "function" != typeof e || (n = e,
                        e = void 0),
                        !1 === n && (n = Et),
                        this.each((function() {
                            S.event.remove(this, t, n, e)
                        }
                        ))
                    }
                });
                var Lt = /<script|<style|<link/i
                  , Pt = /checked\s*(?:[^=]|=\s*.checked.)/i
                  , Dt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
                function It(t, e) {
                    return L(t, "table") && L(11 !== e.nodeType ? e : e.firstChild, "tr") && S(t).children("tbody")[0] || t
                }
                function Ot(t) {
                    return t.type = (null !== t.getAttribute("type")) + "/" + t.type,
                    t
                }
                function Nt(t) {
                    return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"),
                    t
                }
                function kt(t, e) {
                    var n, i, r, s, o, a;
                    if (1 === e.nodeType) {
                        if (Q.hasData(t) && (a = Q.get(t).events))
                            for (r in Q.remove(e, "handle events"),
                            a)
                                for (n = 0,
                                i = a[r].length; n < i; n++)
                                    S.event.add(e, r, a[r][n]);
                        $.hasData(t) && (s = $.access(t),
                        o = S.extend({}, s),
                        $.set(e, o))
                    }
                }
                function zt(t, e) {
                    var n = e.nodeName.toLowerCase();
                    "input" === n && gt.test(t.type) ? e.checked = t.checked : "input" !== n && "textarea" !== n || (e.defaultValue = t.defaultValue)
                }
                function Ht(t, e, n, i) {
                    e = l(e);
                    var r, s, o, a, c, u, h = 0, d = t.length, p = d - 1, f = e[0], m = v(f);
                    if (m || d > 1 && "string" == typeof f && !g.checkClone && Pt.test(f))
                        return t.each((function(r) {
                            var s = t.eq(r);
                            m && (e[0] = f.call(this, r, s.html())),
                            Ht(s, e, n, i)
                        }
                        ));
                    if (d && (s = (r = Mt(e, t[0].ownerDocument, !1, t, i)).firstChild,
                    1 === r.childNodes.length && (r = s),
                    s || i)) {
                        for (a = (o = S.map(_t(r, "script"), Ot)).length; h < d; h++)
                            c = r,
                            h !== p && (c = S.clone(c, !0, !0),
                            a && S.merge(o, _t(c, "script"))),
                            n.call(t[h], c, h);
                        if (a)
                            for (u = o[o.length - 1].ownerDocument,
                            S.map(o, Nt),
                            h = 0; h < a; h++)
                                c = o[h],
                                yt.test(c.type || "") && !Q.access(c, "globalEval") && S.contains(u, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? S._evalUrl && !c.noModule && S._evalUrl(c.src, {
                                    nonce: c.nonce || c.getAttribute("nonce")
                                }, u) : b(c.textContent.replace(Dt, ""), c, u))
                    }
                    return t
                }
                function Bt(t, e, n) {
                    for (var i, r = e ? S.filter(e, t) : t, s = 0; null != (i = r[s]); s++)
                        n || 1 !== i.nodeType || S.cleanData(_t(i)),
                        i.parentNode && (n && at(i) && bt(_t(i, "script")),
                        i.parentNode.removeChild(i));
                    return t
                }
                S.extend({
                    htmlPrefilter: function(t) {
                        return t
                    },
                    clone: function(t, e, n) {
                        var i, r, s, o, a = t.cloneNode(!0), l = at(t);
                        if (!(g.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || S.isXMLDoc(t)))
                            for (o = _t(a),
                            i = 0,
                            r = (s = _t(t)).length; i < r; i++)
                                zt(s[i], o[i]);
                        if (e)
                            if (n)
                                for (s = s || _t(t),
                                o = o || _t(a),
                                i = 0,
                                r = s.length; i < r; i++)
                                    kt(s[i], o[i]);
                            else
                                kt(t, a);
                        return (o = _t(a, "script")).length > 0 && bt(o, !l && _t(t, "script")),
                        a
                    },
                    cleanData: function(t) {
                        for (var e, n, i, r = S.event.special, s = 0; void 0 !== (n = t[s]); s++)
                            if (Z(n)) {
                                if (e = n[Q.expando]) {
                                    if (e.events)
                                        for (i in e.events)
                                            r[i] ? S.event.remove(n, i) : S.removeEvent(n, i, e.handle);
                                    n[Q.expando] = void 0
                                }
                                n[$.expando] && (n[$.expando] = void 0)
                            }
                    }
                }),
                S.fn.extend({
                    detach: function(t) {
                        return Bt(this, t, !0)
                    },
                    remove: function(t) {
                        return Bt(this, t)
                    },
                    text: function(t) {
                        return j(this, (function(t) {
                            return void 0 === t ? S.text(this) : this.empty().each((function() {
                                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                            }
                            ))
                        }
                        ), null, t, arguments.length)
                    },
                    append: function() {
                        return Ht(this, arguments, (function(t) {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || It(this, t).appendChild(t)
                        }
                        ))
                    },
                    prepend: function() {
                        return Ht(this, arguments, (function(t) {
                            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                                var e = It(this, t);
                                e.insertBefore(t, e.firstChild)
                            }
                        }
                        ))
                    },
                    before: function() {
                        return Ht(this, arguments, (function(t) {
                            this.parentNode && this.parentNode.insertBefore(t, this)
                        }
                        ))
                    },
                    after: function() {
                        return Ht(this, arguments, (function(t) {
                            this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
                        }
                        ))
                    },
                    empty: function() {
                        for (var t, e = 0; null != (t = this[e]); e++)
                            1 === t.nodeType && (S.cleanData(_t(t, !1)),
                            t.textContent = "");
                        return this
                    },
                    clone: function(t, e) {
                        return t = null != t && t,
                        e = null == e ? t : e,
                        this.map((function() {
                            return S.clone(this, t, e)
                        }
                        ))
                    },
                    html: function(t) {
                        return j(this, (function(t) {
                            var e = this[0] || {}
                              , n = 0
                              , i = this.length;
                            if (void 0 === t && 1 === e.nodeType)
                                return e.innerHTML;
                            if ("string" == typeof t && !Lt.test(t) && !xt[(vt.exec(t) || ["", ""])[1].toLowerCase()]) {
                                t = S.htmlPrefilter(t);
                                try {
                                    for (; n < i; n++)
                                        1 === (e = this[n] || {}).nodeType && (S.cleanData(_t(e, !1)),
                                        e.innerHTML = t);
                                    e = 0
                                } catch (t) {}
                            }
                            e && this.empty().append(t)
                        }
                        ), null, t, arguments.length)
                    },
                    replaceWith: function() {
                        var t = [];
                        return Ht(this, arguments, (function(e) {
                            var n = this.parentNode;
                            S.inArray(this, t) < 0 && (S.cleanData(_t(this)),
                            n && n.replaceChild(e, this))
                        }
                        ), t)
                    }
                }),
                S.each({
                    appendTo: "append",
                    prependTo: "prepend",
                    insertBefore: "before",
                    insertAfter: "after",
                    replaceAll: "replaceWith"
                }, (function(t, e) {
                    S.fn[t] = function(t) {
                        for (var n, i = [], r = S(t), s = r.length - 1, o = 0; o <= s; o++)
                            n = o === s ? this : this.clone(!0),
                            S(r[o])[e](n),
                            c.apply(i, n.get());
                        return this.pushStack(i)
                    }
                }
                ));
                var Ft = new RegExp("^(" + it + ")(?!px)[a-z%]+$","i")
                  , Ut = function(t) {
                    var e = t.ownerDocument.defaultView;
                    return e && e.opener || (e = i),
                    e.getComputedStyle(t)
                }
                  , Gt = function(t, e, n) {
                    var i, r, s = {};
                    for (r in e)
                        s[r] = t.style[r],
                        t.style[r] = e[r];
                    for (r in i = n.call(t),
                    e)
                        t.style[r] = s[r];
                    return i
                }
                  , Vt = new RegExp(st.join("|"),"i");
                function Wt(t, e, n) {
                    var i, r, s, o, a = t.style;
                    return (n = n || Ut(t)) && ("" !== (o = n.getPropertyValue(e) || n[e]) || at(t) || (o = S.style(t, e)),
                    !g.pixelBoxStyles() && Ft.test(o) && Vt.test(e) && (i = a.width,
                    r = a.minWidth,
                    s = a.maxWidth,
                    a.minWidth = a.maxWidth = a.width = o,
                    o = n.width,
                    a.width = i,
                    a.minWidth = r,
                    a.maxWidth = s)),
                    void 0 !== o ? o + "" : o
                }
                function jt(t, e) {
                    return {
                        get: function() {
                            if (!t())
                                return (this.get = e).apply(this, arguments);
                            delete this.get
                        }
                    }
                }
                !function() {
                    function t() {
                        if (u) {
                            c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                            u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                            ot.appendChild(c).appendChild(u);
                            var t = i.getComputedStyle(u);
                            n = "1%" !== t.top,
                            l = 12 === e(t.marginLeft),
                            u.style.right = "60%",
                            o = 36 === e(t.right),
                            r = 36 === e(t.width),
                            u.style.position = "absolute",
                            s = 12 === e(u.offsetWidth / 3),
                            ot.removeChild(c),
                            u = null
                        }
                    }
                    function e(t) {
                        return Math.round(parseFloat(t))
                    }
                    var n, r, s, o, a, l, c = x.createElement("div"), u = x.createElement("div");
                    u.style && (u.style.backgroundClip = "content-box",
                    u.cloneNode(!0).style.backgroundClip = "",
                    g.clearCloneStyle = "content-box" === u.style.backgroundClip,
                    S.extend(g, {
                        boxSizingReliable: function() {
                            return t(),
                            r
                        },
                        pixelBoxStyles: function() {
                            return t(),
                            o
                        },
                        pixelPosition: function() {
                            return t(),
                            n
                        },
                        reliableMarginLeft: function() {
                            return t(),
                            l
                        },
                        scrollboxSize: function() {
                            return t(),
                            s
                        },
                        reliableTrDimensions: function() {
                            var t, e, n, r;
                            return null == a && (t = x.createElement("table"),
                            e = x.createElement("tr"),
                            n = x.createElement("div"),
                            t.style.cssText = "position:absolute;left:-11111px;border-collapse:separate",
                            e.style.cssText = "border:1px solid",
                            e.style.height = "1px",
                            n.style.height = "9px",
                            n.style.display = "block",
                            ot.appendChild(t).appendChild(e).appendChild(n),
                            r = i.getComputedStyle(e),
                            a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === e.offsetHeight,
                            ot.removeChild(t)),
                            a
                        }
                    }))
                }();
                var qt = ["Webkit", "Moz", "ms"]
                  , Xt = x.createElement("div").style
                  , Yt = {};
                function Jt(t) {
                    return S.cssProps[t] || Yt[t] || (t in Xt ? t : Yt[t] = function(t) {
                        for (var e = t[0].toUpperCase() + t.slice(1), n = qt.length; n--; )
                            if ((t = qt[n] + e)in Xt)
                                return t
                    }(t) || t)
                }
                var Zt = /^(none|table(?!-c[ea]).+)/
                  , Kt = /^--/
                  , Qt = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                }
                  , $t = {
                    letterSpacing: "0",
                    fontWeight: "400"
                };
                function te(t, e, n) {
                    var i = rt.exec(e);
                    return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : e
                }
                function ee(t, e, n, i, r, s) {
                    var o = "width" === e ? 1 : 0
                      , a = 0
                      , l = 0;
                    if (n === (i ? "border" : "content"))
                        return 0;
                    for (; o < 4; o += 2)
                        "margin" === n && (l += S.css(t, n + st[o], !0, r)),
                        i ? ("content" === n && (l -= S.css(t, "padding" + st[o], !0, r)),
                        "margin" !== n && (l -= S.css(t, "border" + st[o] + "Width", !0, r))) : (l += S.css(t, "padding" + st[o], !0, r),
                        "padding" !== n ? l += S.css(t, "border" + st[o] + "Width", !0, r) : a += S.css(t, "border" + st[o] + "Width", !0, r));
                    return !i && s >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - s - l - a - .5)) || 0),
                    l
                }
                function ne(t, e, n) {
                    var i = Ut(t)
                      , r = (!g.boxSizingReliable() || n) && "border-box" === S.css(t, "boxSizing", !1, i)
                      , s = r
                      , o = Wt(t, e, i)
                      , a = "offset" + e[0].toUpperCase() + e.slice(1);
                    if (Ft.test(o)) {
                        if (!n)
                            return o;
                        o = "auto"
                    }
                    return (!g.boxSizingReliable() && r || !g.reliableTrDimensions() && L(t, "tr") || "auto" === o || !parseFloat(o) && "inline" === S.css(t, "display", !1, i)) && t.getClientRects().length && (r = "border-box" === S.css(t, "boxSizing", !1, i),
                    (s = a in t) && (o = t[a])),
                    (o = parseFloat(o) || 0) + ee(t, e, n || (r ? "border" : "content"), s, i, o) + "px"
                }
                function ie(t, e, n, i, r) {
                    return new ie.prototype.init(t,e,n,i,r)
                }
                S.extend({
                    cssHooks: {
                        opacity: {
                            get: function(t, e) {
                                if (e) {
                                    var n = Wt(t, "opacity");
                                    return "" === n ? "1" : n
                                }
                            }
                        }
                    },
                    cssNumber: {
                        animationIterationCount: !0,
                        columnCount: !0,
                        fillOpacity: !0,
                        flexGrow: !0,
                        flexShrink: !0,
                        fontWeight: !0,
                        gridArea: !0,
                        gridColumn: !0,
                        gridColumnEnd: !0,
                        gridColumnStart: !0,
                        gridRow: !0,
                        gridRowEnd: !0,
                        gridRowStart: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0
                    },
                    cssProps: {},
                    style: function(t, e, n, i) {
                        if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                            var r, s, o, a = J(e), l = Kt.test(e), c = t.style;
                            if (l || (e = Jt(a)),
                            o = S.cssHooks[e] || S.cssHooks[a],
                            void 0 === n)
                                return o && "get"in o && void 0 !== (r = o.get(t, !1, i)) ? r : c[e];
                            "string" == (s = typeof n) && (r = rt.exec(n)) && r[1] && (n = ut(t, e, r),
                            s = "number"),
                            null != n && n == n && ("number" !== s || l || (n += r && r[3] || (S.cssNumber[a] ? "" : "px")),
                            g.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (c[e] = "inherit"),
                            o && "set"in o && void 0 === (n = o.set(t, n, i)) || (l ? c.setProperty(e, n) : c[e] = n))
                        }
                    },
                    css: function(t, e, n, i) {
                        var r, s, o, a = J(e);
                        return Kt.test(e) || (e = Jt(a)),
                        (o = S.cssHooks[e] || S.cssHooks[a]) && "get"in o && (r = o.get(t, !0, n)),
                        void 0 === r && (r = Wt(t, e, i)),
                        "normal" === r && e in $t && (r = $t[e]),
                        "" === n || n ? (s = parseFloat(r),
                        !0 === n || isFinite(s) ? s || 0 : r) : r
                    }
                }),
                S.each(["height", "width"], (function(t, e) {
                    S.cssHooks[e] = {
                        get: function(t, n, i) {
                            if (n)
                                return !Zt.test(S.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? ne(t, e, i) : Gt(t, Qt, (function() {
                                    return ne(t, e, i)
                                }
                                ))
                        },
                        set: function(t, n, i) {
                            var r, s = Ut(t), o = !g.scrollboxSize() && "absolute" === s.position, a = (o || i) && "border-box" === S.css(t, "boxSizing", !1, s), l = i ? ee(t, e, i, a, s) : 0;
                            return a && o && (l -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(s[e]) - ee(t, e, "border", !1, s) - .5)),
                            l && (r = rt.exec(n)) && "px" !== (r[3] || "px") && (t.style[e] = n,
                            n = S.css(t, e)),
                            te(0, n, l)
                        }
                    }
                }
                )),
                S.cssHooks.marginLeft = jt(g.reliableMarginLeft, (function(t, e) {
                    if (e)
                        return (parseFloat(Wt(t, "marginLeft")) || t.getBoundingClientRect().left - Gt(t, {
                            marginLeft: 0
                        }, (function() {
                            return t.getBoundingClientRect().left
                        }
                        ))) + "px"
                }
                )),
                S.each({
                    margin: "",
                    padding: "",
                    border: "Width"
                }, (function(t, e) {
                    S.cssHooks[t + e] = {
                        expand: function(n) {
                            for (var i = 0, r = {}, s = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++)
                                r[t + st[i] + e] = s[i] || s[i - 2] || s[0];
                            return r
                        }
                    },
                    "margin" !== t && (S.cssHooks[t + e].set = te)
                }
                )),
                S.fn.extend({
                    css: function(t, e) {
                        return j(this, (function(t, e, n) {
                            var i, r, s = {}, o = 0;
                            if (Array.isArray(e)) {
                                for (i = Ut(t),
                                r = e.length; o < r; o++)
                                    s[e[o]] = S.css(t, e[o], !1, i);
                                return s
                            }
                            return void 0 !== n ? S.style(t, e, n) : S.css(t, e)
                        }
                        ), t, e, arguments.length > 1)
                    }
                }),
                S.Tween = ie,
                ie.prototype = {
                    constructor: ie,
                    init: function(t, e, n, i, r, s) {
                        this.elem = t,
                        this.prop = n,
                        this.easing = r || S.easing._default,
                        this.options = e,
                        this.start = this.now = this.cur(),
                        this.end = i,
                        this.unit = s || (S.cssNumber[n] ? "" : "px")
                    },
                    cur: function() {
                        var t = ie.propHooks[this.prop];
                        return t && t.get ? t.get(this) : ie.propHooks._default.get(this)
                    },
                    run: function(t) {
                        var e, n = ie.propHooks[this.prop];
                        return this.options.duration ? this.pos = e = S.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t,
                        this.now = (this.end - this.start) * e + this.start,
                        this.options.step && this.options.step.call(this.elem, this.now, this),
                        n && n.set ? n.set(this) : ie.propHooks._default.set(this),
                        this
                    }
                },
                ie.prototype.init.prototype = ie.prototype,
                ie.propHooks = {
                    _default: {
                        get: function(t) {
                            var e;
                            return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = S.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
                        },
                        set: function(t) {
                            S.fx.step[t.prop] ? S.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !S.cssHooks[t.prop] && null == t.elem.style[Jt(t.prop)] ? t.elem[t.prop] = t.now : S.style(t.elem, t.prop, t.now + t.unit)
                        }
                    }
                },
                ie.propHooks.scrollTop = ie.propHooks.scrollLeft = {
                    set: function(t) {
                        t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
                    }
                },
                S.easing = {
                    linear: function(t) {
                        return t
                    },
                    swing: function(t) {
                        return .5 - Math.cos(t * Math.PI) / 2
                    },
                    _default: "swing"
                },
                S.fx = ie.prototype.init,
                S.fx.step = {};
                var re, se, oe = /^(?:toggle|show|hide)$/, ae = /queueHooks$/;
                function le() {
                    se && (!1 === x.hidden && i.requestAnimationFrame ? i.requestAnimationFrame(le) : i.setTimeout(le, S.fx.interval),
                    S.fx.tick())
                }
                function ce() {
                    return i.setTimeout((function() {
                        re = void 0
                    }
                    )),
                    re = Date.now()
                }
                function ue(t, e) {
                    var n, i = 0, r = {
                        height: t
                    };
                    for (e = e ? 1 : 0; i < 4; i += 2 - e)
                        r["margin" + (n = st[i])] = r["padding" + n] = t;
                    return e && (r.opacity = r.width = t),
                    r
                }
                function he(t, e, n) {
                    for (var i, r = (de.tweeners[e] || []).concat(de.tweeners["*"]), s = 0, o = r.length; s < o; s++)
                        if (i = r[s].call(n, e, t))
                            return i
                }
                function de(t, e, n) {
                    var i, r, s = 0, o = de.prefilters.length, a = S.Deferred().always((function() {
                        delete l.elem
                    }
                    )), l = function() {
                        if (r)
                            return !1;
                        for (var e = re || ce(), n = Math.max(0, c.startTime + c.duration - e), i = 1 - (n / c.duration || 0), s = 0, o = c.tweens.length; s < o; s++)
                            c.tweens[s].run(i);
                        return a.notifyWith(t, [c, i, n]),
                        i < 1 && o ? n : (o || a.notifyWith(t, [c, 1, 0]),
                        a.resolveWith(t, [c]),
                        !1)
                    }, c = a.promise({
                        elem: t,
                        props: S.extend({}, e),
                        opts: S.extend(!0, {
                            specialEasing: {},
                            easing: S.easing._default
                        }, n),
                        originalProperties: e,
                        originalOptions: n,
                        startTime: re || ce(),
                        duration: n.duration,
                        tweens: [],
                        createTween: function(e, n) {
                            var i = S.Tween(t, c.opts, e, n, c.opts.specialEasing[e] || c.opts.easing);
                            return c.tweens.push(i),
                            i
                        },
                        stop: function(e) {
                            var n = 0
                              , i = e ? c.tweens.length : 0;
                            if (r)
                                return this;
                            for (r = !0; n < i; n++)
                                c.tweens[n].run(1);
                            return e ? (a.notifyWith(t, [c, 1, 0]),
                            a.resolveWith(t, [c, e])) : a.rejectWith(t, [c, e]),
                            this
                        }
                    }), u = c.props;
                    for (function(t, e) {
                        var n, i, r, s, o;
                        for (n in t)
                            if (r = e[i = J(n)],
                            s = t[n],
                            Array.isArray(s) && (r = s[1],
                            s = t[n] = s[0]),
                            n !== i && (t[i] = s,
                            delete t[n]),
                            (o = S.cssHooks[i]) && "expand"in o)
                                for (n in s = o.expand(s),
                                delete t[i],
                                s)
                                    n in t || (t[n] = s[n],
                                    e[n] = r);
                            else
                                e[i] = r
                    }(u, c.opts.specialEasing); s < o; s++)
                        if (i = de.prefilters[s].call(c, t, u, c.opts))
                            return v(i.stop) && (S._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)),
                            i;
                    return S.map(u, he, c),
                    v(c.opts.start) && c.opts.start.call(t, c),
                    c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always),
                    S.fx.timer(S.extend(l, {
                        elem: t,
                        anim: c,
                        queue: c.opts.queue
                    })),
                    c
                }
                S.Animation = S.extend(de, {
                    tweeners: {
                        "*": [function(t, e) {
                            var n = this.createTween(t, e);
                            return ut(n.elem, t, rt.exec(e), n),
                            n
                        }
                        ]
                    },
                    tweener: function(t, e) {
                        v(t) ? (e = t,
                        t = ["*"]) : t = t.match(H);
                        for (var n, i = 0, r = t.length; i < r; i++)
                            n = t[i],
                            de.tweeners[n] = de.tweeners[n] || [],
                            de.tweeners[n].unshift(e)
                    },
                    prefilters: [function(t, e, n) {
                        var i, r, s, o, a, l, c, u, h = "width"in e || "height"in e, d = this, p = {}, f = t.style, m = t.nodeType && ct(t), g = Q.get(t, "fxshow");
                        for (i in n.queue || (null == (o = S._queueHooks(t, "fx")).unqueued && (o.unqueued = 0,
                        a = o.empty.fire,
                        o.empty.fire = function() {
                            o.unqueued || a()
                        }
                        ),
                        o.unqueued++,
                        d.always((function() {
                            d.always((function() {
                                o.unqueued--,
                                S.queue(t, "fx").length || o.empty.fire()
                            }
                            ))
                        }
                        ))),
                        e)
                            if (r = e[i],
                            oe.test(r)) {
                                if (delete e[i],
                                s = s || "toggle" === r,
                                r === (m ? "hide" : "show")) {
                                    if ("show" !== r || !g || void 0 === g[i])
                                        continue;
                                    m = !0
                                }
                                p[i] = g && g[i] || S.style(t, i)
                            }
                        if ((l = !S.isEmptyObject(e)) || !S.isEmptyObject(p))
                            for (i in h && 1 === t.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY],
                            null == (c = g && g.display) && (c = Q.get(t, "display")),
                            "none" === (u = S.css(t, "display")) && (c ? u = c : (pt([t], !0),
                            c = t.style.display || c,
                            u = S.css(t, "display"),
                            pt([t]))),
                            ("inline" === u || "inline-block" === u && null != c) && "none" === S.css(t, "float") && (l || (d.done((function() {
                                f.display = c
                            }
                            )),
                            null == c && (u = f.display,
                            c = "none" === u ? "" : u)),
                            f.display = "inline-block")),
                            n.overflow && (f.overflow = "hidden",
                            d.always((function() {
                                f.overflow = n.overflow[0],
                                f.overflowX = n.overflow[1],
                                f.overflowY = n.overflow[2]
                            }
                            ))),
                            l = !1,
                            p)
                                l || (g ? "hidden"in g && (m = g.hidden) : g = Q.access(t, "fxshow", {
                                    display: c
                                }),
                                s && (g.hidden = !m),
                                m && pt([t], !0),
                                d.done((function() {
                                    for (i in m || pt([t]),
                                    Q.remove(t, "fxshow"),
                                    p)
                                        S.style(t, i, p[i])
                                }
                                ))),
                                l = he(m ? g[i] : 0, i, d),
                                i in g || (g[i] = l.start,
                                m && (l.end = l.start,
                                l.start = 0))
                    }
                    ],
                    prefilter: function(t, e) {
                        e ? de.prefilters.unshift(t) : de.prefilters.push(t)
                    }
                }),
                S.speed = function(t, e, n) {
                    var i = t && "object" == typeof t ? S.extend({}, t) : {
                        complete: n || !n && e || v(t) && t,
                        duration: t,
                        easing: n && e || e && !v(e) && e
                    };
                    return S.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in S.fx.speeds ? i.duration = S.fx.speeds[i.duration] : i.duration = S.fx.speeds._default),
                    null != i.queue && !0 !== i.queue || (i.queue = "fx"),
                    i.old = i.complete,
                    i.complete = function() {
                        v(i.old) && i.old.call(this),
                        i.queue && S.dequeue(this, i.queue)
                    }
                    ,
                    i
                }
                ,
                S.fn.extend({
                    fadeTo: function(t, e, n, i) {
                        return this.filter(ct).css("opacity", 0).show().end().animate({
                            opacity: e
                        }, t, n, i)
                    },
                    animate: function(t, e, n, i) {
                        var r = S.isEmptyObject(t)
                          , s = S.speed(e, n, i)
                          , o = function() {
                            var e = de(this, S.extend({}, t), s);
                            (r || Q.get(this, "finish")) && e.stop(!0)
                        };
                        return o.finish = o,
                        r || !1 === s.queue ? this.each(o) : this.queue(s.queue, o)
                    },
                    stop: function(t, e, n) {
                        var i = function(t) {
                            var e = t.stop;
                            delete t.stop,
                            e(n)
                        };
                        return "string" != typeof t && (n = e,
                        e = t,
                        t = void 0),
                        e && this.queue(t || "fx", []),
                        this.each((function() {
                            var e = !0
                              , r = null != t && t + "queueHooks"
                              , s = S.timers
                              , o = Q.get(this);
                            if (r)
                                o[r] && o[r].stop && i(o[r]);
                            else
                                for (r in o)
                                    o[r] && o[r].stop && ae.test(r) && i(o[r]);
                            for (r = s.length; r--; )
                                s[r].elem !== this || null != t && s[r].queue !== t || (s[r].anim.stop(n),
                                e = !1,
                                s.splice(r, 1));
                            !e && n || S.dequeue(this, t)
                        }
                        ))
                    },
                    finish: function(t) {
                        return !1 !== t && (t = t || "fx"),
                        this.each((function() {
                            var e, n = Q.get(this), i = n[t + "queue"], r = n[t + "queueHooks"], s = S.timers, o = i ? i.length : 0;
                            for (n.finish = !0,
                            S.queue(this, t, []),
                            r && r.stop && r.stop.call(this, !0),
                            e = s.length; e--; )
                                s[e].elem === this && s[e].queue === t && (s[e].anim.stop(!0),
                                s.splice(e, 1));
                            for (e = 0; e < o; e++)
                                i[e] && i[e].finish && i[e].finish.call(this);
                            delete n.finish
                        }
                        ))
                    }
                }),
                S.each(["toggle", "show", "hide"], (function(t, e) {
                    var n = S.fn[e];
                    S.fn[e] = function(t, i, r) {
                        return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(ue(e, !0), t, i, r)
                    }
                }
                )),
                S.each({
                    slideDown: ue("show"),
                    slideUp: ue("hide"),
                    slideToggle: ue("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, (function(t, e) {
                    S.fn[t] = function(t, n, i) {
                        return this.animate(e, t, n, i)
                    }
                }
                )),
                S.timers = [],
                S.fx.tick = function() {
                    var t, e = 0, n = S.timers;
                    for (re = Date.now(); e < n.length; e++)
                        (t = n[e])() || n[e] !== t || n.splice(e--, 1);
                    n.length || S.fx.stop(),
                    re = void 0
                }
                ,
                S.fx.timer = function(t) {
                    S.timers.push(t),
                    S.fx.start()
                }
                ,
                S.fx.interval = 13,
                S.fx.start = function() {
                    se || (se = !0,
                    le())
                }
                ,
                S.fx.stop = function() {
                    se = null
                }
                ,
                S.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    _default: 400
                },
                S.fn.delay = function(t, e) {
                    return t = S.fx && S.fx.speeds[t] || t,
                    e = e || "fx",
                    this.queue(e, (function(e, n) {
                        var r = i.setTimeout(e, t);
                        n.stop = function() {
                            i.clearTimeout(r)
                        }
                    }
                    ))
                }
                ,
                function() {
                    var t = x.createElement("input")
                      , e = x.createElement("select").appendChild(x.createElement("option"));
                    t.type = "checkbox",
                    g.checkOn = "" !== t.value,
                    g.optSelected = e.selected,
                    (t = x.createElement("input")).value = "t",
                    t.type = "radio",
                    g.radioValue = "t" === t.value
                }();
                var pe, fe = S.expr.attrHandle;
                S.fn.extend({
                    attr: function(t, e) {
                        return j(this, S.attr, t, e, arguments.length > 1)
                    },
                    removeAttr: function(t) {
                        return this.each((function() {
                            S.removeAttr(this, t)
                        }
                        ))
                    }
                }),
                S.extend({
                    attr: function(t, e, n) {
                        var i, r, s = t.nodeType;
                        if (3 !== s && 8 !== s && 2 !== s)
                            return void 0 === t.getAttribute ? S.prop(t, e, n) : (1 === s && S.isXMLDoc(t) || (r = S.attrHooks[e.toLowerCase()] || (S.expr.match.bool.test(e) ? pe : void 0)),
                            void 0 !== n ? null === n ? void S.removeAttr(t, e) : r && "set"in r && void 0 !== (i = r.set(t, n, e)) ? i : (t.setAttribute(e, n + ""),
                            n) : r && "get"in r && null !== (i = r.get(t, e)) ? i : null == (i = S.find.attr(t, e)) ? void 0 : i)
                    },
                    attrHooks: {
                        type: {
                            set: function(t, e) {
                                if (!g.radioValue && "radio" === e && L(t, "input")) {
                                    var n = t.value;
                                    return t.setAttribute("type", e),
                                    n && (t.value = n),
                                    e
                                }
                            }
                        }
                    },
                    removeAttr: function(t, e) {
                        var n, i = 0, r = e && e.match(H);
                        if (r && 1 === t.nodeType)
                            for (; n = r[i++]; )
                                t.removeAttribute(n)
                    }
                }),
                pe = {
                    set: function(t, e, n) {
                        return !1 === e ? S.removeAttr(t, n) : t.setAttribute(n, n),
                        n
                    }
                },
                S.each(S.expr.match.bool.source.match(/\w+/g), (function(t, e) {
                    var n = fe[e] || S.find.attr;
                    fe[e] = function(t, e, i) {
                        var r, s, o = e.toLowerCase();
                        return i || (s = fe[o],
                        fe[o] = r,
                        r = null != n(t, e, i) ? o : null,
                        fe[o] = s),
                        r
                    }
                }
                ));
                var me = /^(?:input|select|textarea|button)$/i
                  , ge = /^(?:a|area)$/i;
                function ve(t) {
                    return (t.match(H) || []).join(" ")
                }
                function ye(t) {
                    return t.getAttribute && t.getAttribute("class") || ""
                }
                function xe(t) {
                    return Array.isArray(t) ? t : "string" == typeof t && t.match(H) || []
                }
                S.fn.extend({
                    prop: function(t, e) {
                        return j(this, S.prop, t, e, arguments.length > 1)
                    },
                    removeProp: function(t) {
                        return this.each((function() {
                            delete this[S.propFix[t] || t]
                        }
                        ))
                    }
                }),
                S.extend({
                    prop: function(t, e, n) {
                        var i, r, s = t.nodeType;
                        if (3 !== s && 8 !== s && 2 !== s)
                            return 1 === s && S.isXMLDoc(t) || (e = S.propFix[e] || e,
                            r = S.propHooks[e]),
                            void 0 !== n ? r && "set"in r && void 0 !== (i = r.set(t, n, e)) ? i : t[e] = n : r && "get"in r && null !== (i = r.get(t, e)) ? i : t[e]
                    },
                    propHooks: {
                        tabIndex: {
                            get: function(t) {
                                var e = S.find.attr(t, "tabindex");
                                return e ? parseInt(e, 10) : me.test(t.nodeName) || ge.test(t.nodeName) && t.href ? 0 : -1
                            }
                        }
                    },
                    propFix: {
                        for: "htmlFor",
                        class: "className"
                    }
                }),
                g.optSelected || (S.propHooks.selected = {
                    get: function(t) {
                        var e = t.parentNode;
                        return e && e.parentNode && e.parentNode.selectedIndex,
                        null
                    },
                    set: function(t) {
                        var e = t.parentNode;
                        e && (e.selectedIndex,
                        e.parentNode && e.parentNode.selectedIndex)
                    }
                }),
                S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function() {
                    S.propFix[this.toLowerCase()] = this
                }
                )),
                S.fn.extend({
                    addClass: function(t) {
                        var e, n, i, r, s, o, a, l = 0;
                        if (v(t))
                            return this.each((function(e) {
                                S(this).addClass(t.call(this, e, ye(this)))
                            }
                            ));
                        if ((e = xe(t)).length)
                            for (; n = this[l++]; )
                                if (r = ye(n),
                                i = 1 === n.nodeType && " " + ve(r) + " ") {
                                    for (o = 0; s = e[o++]; )
                                        i.indexOf(" " + s + " ") < 0 && (i += s + " ");
                                    r !== (a = ve(i)) && n.setAttribute("class", a)
                                }
                        return this
                    },
                    removeClass: function(t) {
                        var e, n, i, r, s, o, a, l = 0;
                        if (v(t))
                            return this.each((function(e) {
                                S(this).removeClass(t.call(this, e, ye(this)))
                            }
                            ));
                        if (!arguments.length)
                            return this.attr("class", "");
                        if ((e = xe(t)).length)
                            for (; n = this[l++]; )
                                if (r = ye(n),
                                i = 1 === n.nodeType && " " + ve(r) + " ") {
                                    for (o = 0; s = e[o++]; )
                                        for (; i.indexOf(" " + s + " ") > -1; )
                                            i = i.replace(" " + s + " ", " ");
                                    r !== (a = ve(i)) && n.setAttribute("class", a)
                                }
                        return this
                    },
                    toggleClass: function(t, e) {
                        var n = typeof t
                          , i = "string" === n || Array.isArray(t);
                        return "boolean" == typeof e && i ? e ? this.addClass(t) : this.removeClass(t) : v(t) ? this.each((function(n) {
                            S(this).toggleClass(t.call(this, n, ye(this), e), e)
                        }
                        )) : this.each((function() {
                            var e, r, s, o;
                            if (i)
                                for (r = 0,
                                s = S(this),
                                o = xe(t); e = o[r++]; )
                                    s.hasClass(e) ? s.removeClass(e) : s.addClass(e);
                            else
                                void 0 !== t && "boolean" !== n || ((e = ye(this)) && Q.set(this, "__className__", e),
                                this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : Q.get(this, "__className__") || ""))
                        }
                        ))
                    },
                    hasClass: function(t) {
                        var e, n, i = 0;
                        for (e = " " + t + " "; n = this[i++]; )
                            if (1 === n.nodeType && (" " + ve(ye(n)) + " ").indexOf(e) > -1)
                                return !0;
                        return !1
                    }
                });
                var _e = /\r/g;
                S.fn.extend({
                    val: function(t) {
                        var e, n, i, r = this[0];
                        return arguments.length ? (i = v(t),
                        this.each((function(n) {
                            var r;
                            1 === this.nodeType && (null == (r = i ? t.call(this, n, S(this).val()) : t) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = S.map(r, (function(t) {
                                return null == t ? "" : t + ""
                            }
                            ))),
                            (e = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set"in e && void 0 !== e.set(this, r, "value") || (this.value = r))
                        }
                        ))) : r ? (e = S.valHooks[r.type] || S.valHooks[r.nodeName.toLowerCase()]) && "get"in e && void 0 !== (n = e.get(r, "value")) ? n : "string" == typeof (n = r.value) ? n.replace(_e, "") : null == n ? "" : n : void 0
                    }
                }),
                S.extend({
                    valHooks: {
                        option: {
                            get: function(t) {
                                var e = S.find.attr(t, "value");
                                return null != e ? e : ve(S.text(t))
                            }
                        },
                        select: {
                            get: function(t) {
                                var e, n, i, r = t.options, s = t.selectedIndex, o = "select-one" === t.type, a = o ? null : [], l = o ? s + 1 : r.length;
                                for (i = s < 0 ? l : o ? s : 0; i < l; i++)
                                    if (((n = r[i]).selected || i === s) && !n.disabled && (!n.parentNode.disabled || !L(n.parentNode, "optgroup"))) {
                                        if (e = S(n).val(),
                                        o)
                                            return e;
                                        a.push(e)
                                    }
                                return a
                            },
                            set: function(t, e) {
                                for (var n, i, r = t.options, s = S.makeArray(e), o = r.length; o--; )
                                    ((i = r[o]).selected = S.inArray(S.valHooks.option.get(i), s) > -1) && (n = !0);
                                return n || (t.selectedIndex = -1),
                                s
                            }
                        }
                    }
                }),
                S.each(["radio", "checkbox"], (function() {
                    S.valHooks[this] = {
                        set: function(t, e) {
                            if (Array.isArray(e))
                                return t.checked = S.inArray(S(t).val(), e) > -1
                        }
                    },
                    g.checkOn || (S.valHooks[this].get = function(t) {
                        return null === t.getAttribute("value") ? "on" : t.value
                    }
                    )
                }
                )),
                g.focusin = "onfocusin"in i;
                var be = /^(?:focusinfocus|focusoutblur)$/
                  , we = function(t) {
                    t.stopPropagation()
                };
                S.extend(S.event, {
                    trigger: function(t, e, n, r) {
                        var s, o, a, l, c, u, h, d, f = [n || x], m = p.call(t, "type") ? t.type : t, g = p.call(t, "namespace") ? t.namespace.split(".") : [];
                        if (o = d = a = n = n || x,
                        3 !== n.nodeType && 8 !== n.nodeType && !be.test(m + S.event.triggered) && (m.indexOf(".") > -1 && (g = m.split("."),
                        m = g.shift(),
                        g.sort()),
                        c = m.indexOf(":") < 0 && "on" + m,
                        (t = t[S.expando] ? t : new S.Event(m,"object" == typeof t && t)).isTrigger = r ? 2 : 3,
                        t.namespace = g.join("."),
                        t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
                        t.result = void 0,
                        t.target || (t.target = n),
                        e = null == e ? [t] : S.makeArray(e, [t]),
                        h = S.event.special[m] || {},
                        r || !h.trigger || !1 !== h.trigger.apply(n, e))) {
                            if (!r && !h.noBubble && !y(n)) {
                                for (l = h.delegateType || m,
                                be.test(l + m) || (o = o.parentNode); o; o = o.parentNode)
                                    f.push(o),
                                    a = o;
                                a === (n.ownerDocument || x) && f.push(a.defaultView || a.parentWindow || i)
                            }
                            for (s = 0; (o = f[s++]) && !t.isPropagationStopped(); )
                                d = o,
                                t.type = s > 1 ? l : h.bindType || m,
                                (u = (Q.get(o, "events") || Object.create(null))[t.type] && Q.get(o, "handle")) && u.apply(o, e),
                                (u = c && o[c]) && u.apply && Z(o) && (t.result = u.apply(o, e),
                                !1 === t.result && t.preventDefault());
                            return t.type = m,
                            r || t.isDefaultPrevented() || h._default && !1 !== h._default.apply(f.pop(), e) || !Z(n) || c && v(n[m]) && !y(n) && ((a = n[c]) && (n[c] = null),
                            S.event.triggered = m,
                            t.isPropagationStopped() && d.addEventListener(m, we),
                            n[m](),
                            t.isPropagationStopped() && d.removeEventListener(m, we),
                            S.event.triggered = void 0,
                            a && (n[c] = a)),
                            t.result
                        }
                    },
                    simulate: function(t, e, n) {
                        var i = S.extend(new S.Event, n, {
                            type: t,
                            isSimulated: !0
                        });
                        S.event.trigger(i, null, e)
                    }
                }),
                S.fn.extend({
                    trigger: function(t, e) {
                        return this.each((function() {
                            S.event.trigger(t, e, this)
                        }
                        ))
                    },
                    triggerHandler: function(t, e) {
                        var n = this[0];
                        if (n)
                            return S.event.trigger(t, e, n, !0)
                    }
                }),
                g.focusin || S.each({
                    focus: "focusin",
                    blur: "focusout"
                }, (function(t, e) {
                    var n = function(t) {
                        S.event.simulate(e, t.target, S.event.fix(t))
                    };
                    S.event.special[e] = {
                        setup: function() {
                            var i = this.ownerDocument || this.document || this
                              , r = Q.access(i, e);
                            r || i.addEventListener(t, n, !0),
                            Q.access(i, e, (r || 0) + 1)
                        },
                        teardown: function() {
                            var i = this.ownerDocument || this.document || this
                              , r = Q.access(i, e) - 1;
                            r ? Q.access(i, e, r) : (i.removeEventListener(t, n, !0),
                            Q.remove(i, e))
                        }
                    }
                }
                ));
                var Me = i.location
                  , Se = {
                    guid: Date.now()
                }
                  , Te = /\?/;
                S.parseXML = function(t) {
                    var e, n;
                    if (!t || "string" != typeof t)
                        return null;
                    try {
                        e = (new i.DOMParser).parseFromString(t, "text/xml")
                    } catch (t) {}
                    return n = e && e.getElementsByTagName("parsererror")[0],
                    e && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, (function(t) {
                        return t.textContent
                    }
                    )).join("\n") : t)),
                    e
                }
                ;
                var Ee = /\[\]$/
                  , Ae = /\r?\n/g
                  , Ce = /^(?:submit|button|image|reset|file)$/i
                  , Re = /^(?:input|select|textarea|keygen)/i;
                function Le(t, e, n, i) {
                    var r;
                    if (Array.isArray(e))
                        S.each(e, (function(e, r) {
                            n || Ee.test(t) ? i(t, r) : Le(t + "[" + ("object" == typeof r && null != r ? e : "") + "]", r, n, i)
                        }
                        ));
                    else if (n || "object" !== w(e))
                        i(t, e);
                    else
                        for (r in e)
                            Le(t + "[" + r + "]", e[r], n, i)
                }
                S.param = function(t, e) {
                    var n, i = [], r = function(t, e) {
                        var n = v(e) ? e() : e;
                        i[i.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n)
                    };
                    if (null == t)
                        return "";
                    if (Array.isArray(t) || t.jquery && !S.isPlainObject(t))
                        S.each(t, (function() {
                            r(this.name, this.value)
                        }
                        ));
                    else
                        for (n in t)
                            Le(n, t[n], e, r);
                    return i.join("&")
                }
                ,
                S.fn.extend({
                    serialize: function() {
                        return S.param(this.serializeArray())
                    },
                    serializeArray: function() {
                        return this.map((function() {
                            var t = S.prop(this, "elements");
                            return t ? S.makeArray(t) : this
                        }
                        )).filter((function() {
                            var t = this.type;
                            return this.name && !S(this).is(":disabled") && Re.test(this.nodeName) && !Ce.test(t) && (this.checked || !gt.test(t))
                        }
                        )).map((function(t, e) {
                            var n = S(this).val();
                            return null == n ? null : Array.isArray(n) ? S.map(n, (function(t) {
                                return {
                                    name: e.name,
                                    value: t.replace(Ae, "\r\n")
                                }
                            }
                            )) : {
                                name: e.name,
                                value: n.replace(Ae, "\r\n")
                            }
                        }
                        )).get()
                    }
                });
                var Pe = /%20/g
                  , De = /#.*$/
                  , Ie = /([?&])_=[^&]*/
                  , Oe = /^(.*?):[ \t]*([^\r\n]*)$/gm
                  , Ne = /^(?:GET|HEAD)$/
                  , ke = /^\/\//
                  , ze = {}
                  , He = {}
                  , Be = "*/".concat("*")
                  , Fe = x.createElement("a");
                function Ue(t) {
                    return function(e, n) {
                        "string" != typeof e && (n = e,
                        e = "*");
                        var i, r = 0, s = e.toLowerCase().match(H) || [];
                        if (v(n))
                            for (; i = s[r++]; )
                                "+" === i[0] ? (i = i.slice(1) || "*",
                                (t[i] = t[i] || []).unshift(n)) : (t[i] = t[i] || []).push(n)
                    }
                }
                function Ge(t, e, n, i) {
                    var r = {}
                      , s = t === He;
                    function o(a) {
                        var l;
                        return r[a] = !0,
                        S.each(t[a] || [], (function(t, a) {
                            var c = a(e, n, i);
                            return "string" != typeof c || s || r[c] ? s ? !(l = c) : void 0 : (e.dataTypes.unshift(c),
                            o(c),
                            !1)
                        }
                        )),
                        l
                    }
                    return o(e.dataTypes[0]) || !r["*"] && o("*")
                }
                function Ve(t, e) {
                    var n, i, r = S.ajaxSettings.flatOptions || {};
                    for (n in e)
                        void 0 !== e[n] && ((r[n] ? t : i || (i = {}))[n] = e[n]);
                    return i && S.extend(!0, t, i),
                    t
                }
                Fe.href = Me.href,
                S.extend({
                    active: 0,
                    lastModified: {},
                    etag: {},
                    ajaxSettings: {
                        url: Me.href,
                        type: "GET",
                        isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Me.protocol),
                        global: !0,
                        processData: !0,
                        async: !0,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                        accepts: {
                            "*": Be,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },
                        contents: {
                            xml: /\bxml\b/,
                            html: /\bhtml/,
                            json: /\bjson\b/
                        },
                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },
                        converters: {
                            "* text": String,
                            "text html": !0,
                            "text json": JSON.parse,
                            "text xml": S.parseXML
                        },
                        flatOptions: {
                            url: !0,
                            context: !0
                        }
                    },
                    ajaxSetup: function(t, e) {
                        return e ? Ve(Ve(t, S.ajaxSettings), e) : Ve(S.ajaxSettings, t)
                    },
                    ajaxPrefilter: Ue(ze),
                    ajaxTransport: Ue(He),
                    ajax: function(t, e) {
                        "object" == typeof t && (e = t,
                        t = void 0),
                        e = e || {};
                        var n, r, s, o, a, l, c, u, h, d, p = S.ajaxSetup({}, e), f = p.context || p, m = p.context && (f.nodeType || f.jquery) ? S(f) : S.event, g = S.Deferred(), v = S.Callbacks("once memory"), y = p.statusCode || {}, _ = {}, b = {}, w = "canceled", M = {
                            readyState: 0,
                            getResponseHeader: function(t) {
                                var e;
                                if (c) {
                                    if (!o)
                                        for (o = {}; e = Oe.exec(s); )
                                            o[e[1].toLowerCase() + " "] = (o[e[1].toLowerCase() + " "] || []).concat(e[2]);
                                    e = o[t.toLowerCase() + " "]
                                }
                                return null == e ? null : e.join(", ")
                            },
                            getAllResponseHeaders: function() {
                                return c ? s : null
                            },
                            setRequestHeader: function(t, e) {
                                return null == c && (t = b[t.toLowerCase()] = b[t.toLowerCase()] || t,
                                _[t] = e),
                                this
                            },
                            overrideMimeType: function(t) {
                                return null == c && (p.mimeType = t),
                                this
                            },
                            statusCode: function(t) {
                                var e;
                                if (t)
                                    if (c)
                                        M.always(t[M.status]);
                                    else
                                        for (e in t)
                                            y[e] = [y[e], t[e]];
                                return this
                            },
                            abort: function(t) {
                                var e = t || w;
                                return n && n.abort(e),
                                T(0, e),
                                this
                            }
                        };
                        if (g.promise(M),
                        p.url = ((t || p.url || Me.href) + "").replace(ke, Me.protocol + "//"),
                        p.type = e.method || e.type || p.method || p.type,
                        p.dataTypes = (p.dataType || "*").toLowerCase().match(H) || [""],
                        null == p.crossDomain) {
                            l = x.createElement("a");
                            try {
                                l.href = p.url,
                                l.href = l.href,
                                p.crossDomain = Fe.protocol + "//" + Fe.host != l.protocol + "//" + l.host
                            } catch (t) {
                                p.crossDomain = !0
                            }
                        }
                        if (p.data && p.processData && "string" != typeof p.data && (p.data = S.param(p.data, p.traditional)),
                        Ge(ze, p, e, M),
                        c)
                            return M;
                        for (h in (u = S.event && p.global) && 0 == S.active++ && S.event.trigger("ajaxStart"),
                        p.type = p.type.toUpperCase(),
                        p.hasContent = !Ne.test(p.type),
                        r = p.url.replace(De, ""),
                        p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Pe, "+")) : (d = p.url.slice(r.length),
                        p.data && (p.processData || "string" == typeof p.data) && (r += (Te.test(r) ? "&" : "?") + p.data,
                        delete p.data),
                        !1 === p.cache && (r = r.replace(Ie, "$1"),
                        d = (Te.test(r) ? "&" : "?") + "_=" + Se.guid++ + d),
                        p.url = r + d),
                        p.ifModified && (S.lastModified[r] && M.setRequestHeader("If-Modified-Since", S.lastModified[r]),
                        S.etag[r] && M.setRequestHeader("If-None-Match", S.etag[r])),
                        (p.data && p.hasContent && !1 !== p.contentType || e.contentType) && M.setRequestHeader("Content-Type", p.contentType),
                        M.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Be + "; q=0.01" : "") : p.accepts["*"]),
                        p.headers)
                            M.setRequestHeader(h, p.headers[h]);
                        if (p.beforeSend && (!1 === p.beforeSend.call(f, M, p) || c))
                            return M.abort();
                        if (w = "abort",
                        v.add(p.complete),
                        M.done(p.success),
                        M.fail(p.error),
                        n = Ge(He, p, e, M)) {
                            if (M.readyState = 1,
                            u && m.trigger("ajaxSend", [M, p]),
                            c)
                                return M;
                            p.async && p.timeout > 0 && (a = i.setTimeout((function() {
                                M.abort("timeout")
                            }
                            ), p.timeout));
                            try {
                                c = !1,
                                n.send(_, T)
                            } catch (t) {
                                if (c)
                                    throw t;
                                T(-1, t)
                            }
                        } else
                            T(-1, "No Transport");
                        function T(t, e, o, l) {
                            var h, d, x, _, b, w = e;
                            c || (c = !0,
                            a && i.clearTimeout(a),
                            n = void 0,
                            s = l || "",
                            M.readyState = t > 0 ? 4 : 0,
                            h = t >= 200 && t < 300 || 304 === t,
                            o && (_ = function(t, e, n) {
                                for (var i, r, s, o, a = t.contents, l = t.dataTypes; "*" === l[0]; )
                                    l.shift(),
                                    void 0 === i && (i = t.mimeType || e.getResponseHeader("Content-Type"));
                                if (i)
                                    for (r in a)
                                        if (a[r] && a[r].test(i)) {
                                            l.unshift(r);
                                            break
                                        }
                                if (l[0]in n)
                                    s = l[0];
                                else {
                                    for (r in n) {
                                        if (!l[0] || t.converters[r + " " + l[0]]) {
                                            s = r;
                                            break
                                        }
                                        o || (o = r)
                                    }
                                    s = s || o
                                }
                                if (s)
                                    return s !== l[0] && l.unshift(s),
                                    n[s]
                            }(p, M, o)),
                            !h && S.inArray("script", p.dataTypes) > -1 && S.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function() {}
                            ),
                            _ = function(t, e, n, i) {
                                var r, s, o, a, l, c = {}, u = t.dataTypes.slice();
                                if (u[1])
                                    for (o in t.converters)
                                        c[o.toLowerCase()] = t.converters[o];
                                for (s = u.shift(); s; )
                                    if (t.responseFields[s] && (n[t.responseFields[s]] = e),
                                    !l && i && t.dataFilter && (e = t.dataFilter(e, t.dataType)),
                                    l = s,
                                    s = u.shift())
                                        if ("*" === s)
                                            s = l;
                                        else if ("*" !== l && l !== s) {
                                            if (!(o = c[l + " " + s] || c["* " + s]))
                                                for (r in c)
                                                    if ((a = r.split(" "))[1] === s && (o = c[l + " " + a[0]] || c["* " + a[0]])) {
                                                        !0 === o ? o = c[r] : !0 !== c[r] && (s = a[0],
                                                        u.unshift(a[1]));
                                                        break
                                                    }
                                            if (!0 !== o)
                                                if (o && t.throws)
                                                    e = o(e);
                                                else
                                                    try {
                                                        e = o(e)
                                                    } catch (t) {
                                                        return {
                                                            state: "parsererror",
                                                            error: o ? t : "No conversion from " + l + " to " + s
                                                        }
                                                    }
                                        }
                                return {
                                    state: "success",
                                    data: e
                                }
                            }(p, _, M, h),
                            h ? (p.ifModified && ((b = M.getResponseHeader("Last-Modified")) && (S.lastModified[r] = b),
                            (b = M.getResponseHeader("etag")) && (S.etag[r] = b)),
                            204 === t || "HEAD" === p.type ? w = "nocontent" : 304 === t ? w = "notmodified" : (w = _.state,
                            d = _.data,
                            h = !(x = _.error))) : (x = w,
                            !t && w || (w = "error",
                            t < 0 && (t = 0))),
                            M.status = t,
                            M.statusText = (e || w) + "",
                            h ? g.resolveWith(f, [d, w, M]) : g.rejectWith(f, [M, w, x]),
                            M.statusCode(y),
                            y = void 0,
                            u && m.trigger(h ? "ajaxSuccess" : "ajaxError", [M, p, h ? d : x]),
                            v.fireWith(f, [M, w]),
                            u && (m.trigger("ajaxComplete", [M, p]),
                            --S.active || S.event.trigger("ajaxStop")))
                        }
                        return M
                    },
                    getJSON: function(t, e, n) {
                        return S.get(t, e, n, "json")
                    },
                    getScript: function(t, e) {
                        return S.get(t, void 0, e, "script")
                    }
                }),
                S.each(["get", "post"], (function(t, e) {
                    S[e] = function(t, n, i, r) {
                        return v(n) && (r = r || i,
                        i = n,
                        n = void 0),
                        S.ajax(S.extend({
                            url: t,
                            type: e,
                            dataType: r,
                            data: n,
                            success: i
                        }, S.isPlainObject(t) && t))
                    }
                }
                )),
                S.ajaxPrefilter((function(t) {
                    var e;
                    for (e in t.headers)
                        "content-type" === e.toLowerCase() && (t.contentType = t.headers[e] || "")
                }
                )),
                S._evalUrl = function(t, e, n) {
                    return S.ajax({
                        url: t,
                        type: "GET",
                        dataType: "script",
                        cache: !0,
                        async: !1,
                        global: !1,
                        converters: {
                            "text script": function() {}
                        },
                        dataFilter: function(t) {
                            S.globalEval(t, e, n)
                        }
                    })
                }
                ,
                S.fn.extend({
                    wrapAll: function(t) {
                        var e;
                        return this[0] && (v(t) && (t = t.call(this[0])),
                        e = S(t, this[0].ownerDocument).eq(0).clone(!0),
                        this[0].parentNode && e.insertBefore(this[0]),
                        e.map((function() {
                            for (var t = this; t.firstElementChild; )
                                t = t.firstElementChild;
                            return t
                        }
                        )).append(this)),
                        this
                    },
                    wrapInner: function(t) {
                        return v(t) ? this.each((function(e) {
                            S(this).wrapInner(t.call(this, e))
                        }
                        )) : this.each((function() {
                            var e = S(this)
                              , n = e.contents();
                            n.length ? n.wrapAll(t) : e.append(t)
                        }
                        ))
                    },
                    wrap: function(t) {
                        var e = v(t);
                        return this.each((function(n) {
                            S(this).wrapAll(e ? t.call(this, n) : t)
                        }
                        ))
                    },
                    unwrap: function(t) {
                        return this.parent(t).not("body").each((function() {
                            S(this).replaceWith(this.childNodes)
                        }
                        )),
                        this
                    }
                }),
                S.expr.pseudos.hidden = function(t) {
                    return !S.expr.pseudos.visible(t)
                }
                ,
                S.expr.pseudos.visible = function(t) {
                    return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
                }
                ,
                S.ajaxSettings.xhr = function() {
                    try {
                        return new i.XMLHttpRequest
                    } catch (t) {}
                }
                ;
                var We = {
                    0: 200,
                    1223: 204
                }
                  , je = S.ajaxSettings.xhr();
                g.cors = !!je && "withCredentials"in je,
                g.ajax = je = !!je,
                S.ajaxTransport((function(t) {
                    var e, n;
                    if (g.cors || je && !t.crossDomain)
                        return {
                            send: function(r, s) {
                                var o, a = t.xhr();
                                if (a.open(t.type, t.url, t.async, t.username, t.password),
                                t.xhrFields)
                                    for (o in t.xhrFields)
                                        a[o] = t.xhrFields[o];
                                for (o in t.mimeType && a.overrideMimeType && a.overrideMimeType(t.mimeType),
                                t.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest"),
                                r)
                                    a.setRequestHeader(o, r[o]);
                                e = function(t) {
                                    return function() {
                                        e && (e = n = a.onload = a.onerror = a.onabort = a.ontimeout = a.onreadystatechange = null,
                                        "abort" === t ? a.abort() : "error" === t ? "number" != typeof a.status ? s(0, "error") : s(a.status, a.statusText) : s(We[a.status] || a.status, a.statusText, "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? {
                                            binary: a.response
                                        } : {
                                            text: a.responseText
                                        }, a.getAllResponseHeaders()))
                                    }
                                }
                                ,
                                a.onload = e(),
                                n = a.onerror = a.ontimeout = e("error"),
                                void 0 !== a.onabort ? a.onabort = n : a.onreadystatechange = function() {
                                    4 === a.readyState && i.setTimeout((function() {
                                        e && n()
                                    }
                                    ))
                                }
                                ,
                                e = e("abort");
                                try {
                                    a.send(t.hasContent && t.data || null)
                                } catch (t) {
                                    if (e)
                                        throw t
                                }
                            },
                            abort: function() {
                                e && e()
                            }
                        }
                }
                )),
                S.ajaxPrefilter((function(t) {
                    t.crossDomain && (t.contents.script = !1)
                }
                )),
                S.ajaxSetup({
                    accepts: {
                        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /\b(?:java|ecma)script\b/
                    },
                    converters: {
                        "text script": function(t) {
                            return S.globalEval(t),
                            t
                        }
                    }
                }),
                S.ajaxPrefilter("script", (function(t) {
                    void 0 === t.cache && (t.cache = !1),
                    t.crossDomain && (t.type = "GET")
                }
                )),
                S.ajaxTransport("script", (function(t) {
                    var e, n;
                    if (t.crossDomain || t.scriptAttrs)
                        return {
                            send: function(i, r) {
                                e = S("<script>").attr(t.scriptAttrs || {}).prop({
                                    charset: t.scriptCharset,
                                    src: t.url
                                }).on("load error", n = function(t) {
                                    e.remove(),
                                    n = null,
                                    t && r("error" === t.type ? 404 : 200, t.type)
                                }
                                ),
                                x.head.appendChild(e[0])
                            },
                            abort: function() {
                                n && n()
                            }
                        }
                }
                ));
                var qe, Xe = [], Ye = /(=)\?(?=&|$)|\?\?/;
                S.ajaxSetup({
                    jsonp: "callback",
                    jsonpCallback: function() {
                        var t = Xe.pop() || S.expando + "_" + Se.guid++;
                        return this[t] = !0,
                        t
                    }
                }),
                S.ajaxPrefilter("json jsonp", (function(t, e, n) {
                    var r, s, o, a = !1 !== t.jsonp && (Ye.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Ye.test(t.data) && "data");
                    if (a || "jsonp" === t.dataTypes[0])
                        return r = t.jsonpCallback = v(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback,
                        a ? t[a] = t[a].replace(Ye, "$1" + r) : !1 !== t.jsonp && (t.url += (Te.test(t.url) ? "&" : "?") + t.jsonp + "=" + r),
                        t.converters["script json"] = function() {
                            return o || S.error(r + " was not called"),
                            o[0]
                        }
                        ,
                        t.dataTypes[0] = "json",
                        s = i[r],
                        i[r] = function() {
                            o = arguments
                        }
                        ,
                        n.always((function() {
                            void 0 === s ? S(i).removeProp(r) : i[r] = s,
                            t[r] && (t.jsonpCallback = e.jsonpCallback,
                            Xe.push(r)),
                            o && v(s) && s(o[0]),
                            o = s = void 0
                        }
                        )),
                        "script"
                }
                )),
                g.createHTMLDocument = ((qe = x.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>",
                2 === qe.childNodes.length),
                S.parseHTML = function(t, e, n) {
                    return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e,
                    e = !1),
                    e || (g.createHTMLDocument ? ((i = (e = x.implementation.createHTMLDocument("")).createElement("base")).href = x.location.href,
                    e.head.appendChild(i)) : e = x),
                    s = !n && [],
                    (r = P.exec(t)) ? [e.createElement(r[1])] : (r = Mt([t], e, s),
                    s && s.length && S(s).remove(),
                    S.merge([], r.childNodes)));
                    var i, r, s
                }
                ,
                S.fn.load = function(t, e, n) {
                    var i, r, s, o = this, a = t.indexOf(" ");
                    return a > -1 && (i = ve(t.slice(a)),
                    t = t.slice(0, a)),
                    v(e) ? (n = e,
                    e = void 0) : e && "object" == typeof e && (r = "POST"),
                    o.length > 0 && S.ajax({
                        url: t,
                        type: r || "GET",
                        dataType: "html",
                        data: e
                    }).done((function(t) {
                        s = arguments,
                        o.html(i ? S("<div>").append(S.parseHTML(t)).find(i) : t)
                    }
                    )).always(n && function(t, e) {
                        o.each((function() {
                            n.apply(this, s || [t.responseText, e, t])
                        }
                        ))
                    }
                    ),
                    this
                }
                ,
                S.expr.pseudos.animated = function(t) {
                    return S.grep(S.timers, (function(e) {
                        return t === e.elem
                    }
                    )).length
                }
                ,
                S.offset = {
                    setOffset: function(t, e, n) {
                        var i, r, s, o, a, l, c = S.css(t, "position"), u = S(t), h = {};
                        "static" === c && (t.style.position = "relative"),
                        a = u.offset(),
                        s = S.css(t, "top"),
                        l = S.css(t, "left"),
                        ("absolute" === c || "fixed" === c) && (s + l).indexOf("auto") > -1 ? (o = (i = u.position()).top,
                        r = i.left) : (o = parseFloat(s) || 0,
                        r = parseFloat(l) || 0),
                        v(e) && (e = e.call(t, n, S.extend({}, a))),
                        null != e.top && (h.top = e.top - a.top + o),
                        null != e.left && (h.left = e.left - a.left + r),
                        "using"in e ? e.using.call(t, h) : u.css(h)
                    }
                },
                S.fn.extend({
                    offset: function(t) {
                        if (arguments.length)
                            return void 0 === t ? this : this.each((function(e) {
                                S.offset.setOffset(this, t, e)
                            }
                            ));
                        var e, n, i = this[0];
                        return i ? i.getClientRects().length ? (e = i.getBoundingClientRect(),
                        n = i.ownerDocument.defaultView,
                        {
                            top: e.top + n.pageYOffset,
                            left: e.left + n.pageXOffset
                        }) : {
                            top: 0,
                            left: 0
                        } : void 0
                    },
                    position: function() {
                        if (this[0]) {
                            var t, e, n, i = this[0], r = {
                                top: 0,
                                left: 0
                            };
                            if ("fixed" === S.css(i, "position"))
                                e = i.getBoundingClientRect();
                            else {
                                for (e = this.offset(),
                                n = i.ownerDocument,
                                t = i.offsetParent || n.documentElement; t && (t === n.body || t === n.documentElement) && "static" === S.css(t, "position"); )
                                    t = t.parentNode;
                                t && t !== i && 1 === t.nodeType && ((r = S(t).offset()).top += S.css(t, "borderTopWidth", !0),
                                r.left += S.css(t, "borderLeftWidth", !0))
                            }
                            return {
                                top: e.top - r.top - S.css(i, "marginTop", !0),
                                left: e.left - r.left - S.css(i, "marginLeft", !0)
                            }
                        }
                    },
                    offsetParent: function() {
                        return this.map((function() {
                            for (var t = this.offsetParent; t && "static" === S.css(t, "position"); )
                                t = t.offsetParent;
                            return t || ot
                        }
                        ))
                    }
                }),
                S.each({
                    scrollLeft: "pageXOffset",
                    scrollTop: "pageYOffset"
                }, (function(t, e) {
                    var n = "pageYOffset" === e;
                    S.fn[t] = function(i) {
                        return j(this, (function(t, i, r) {
                            var s;
                            if (y(t) ? s = t : 9 === t.nodeType && (s = t.defaultView),
                            void 0 === r)
                                return s ? s[e] : t[i];
                            s ? s.scrollTo(n ? s.pageXOffset : r, n ? r : s.pageYOffset) : t[i] = r
                        }
                        ), t, i, arguments.length)
                    }
                }
                )),
                S.each(["top", "left"], (function(t, e) {
                    S.cssHooks[e] = jt(g.pixelPosition, (function(t, n) {
                        if (n)
                            return n = Wt(t, e),
                            Ft.test(n) ? S(t).position()[e] + "px" : n
                    }
                    ))
                }
                )),
                S.each({
                    Height: "height",
                    Width: "width"
                }, (function(t, e) {
                    S.each({
                        padding: "inner" + t,
                        content: e,
                        "": "outer" + t
                    }, (function(n, i) {
                        S.fn[i] = function(r, s) {
                            var o = arguments.length && (n || "boolean" != typeof r)
                              , a = n || (!0 === r || !0 === s ? "margin" : "border");
                            return j(this, (function(e, n, r) {
                                var s;
                                return y(e) ? 0 === i.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (s = e.documentElement,
                                Math.max(e.body["scroll" + t], s["scroll" + t], e.body["offset" + t], s["offset" + t], s["client" + t])) : void 0 === r ? S.css(e, n, a) : S.style(e, n, r, a)
                            }
                            ), e, o ? r : void 0, o)
                        }
                    }
                    ))
                }
                )),
                S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function(t, e) {
                    S.fn[e] = function(t) {
                        return this.on(e, t)
                    }
                }
                )),
                S.fn.extend({
                    bind: function(t, e, n) {
                        return this.on(t, null, e, n)
                    },
                    unbind: function(t, e) {
                        return this.off(t, null, e)
                    },
                    delegate: function(t, e, n, i) {
                        return this.on(e, t, n, i)
                    },
                    undelegate: function(t, e, n) {
                        return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n)
                    },
                    hover: function(t, e) {
                        return this.mouseenter(t).mouseleave(e || t)
                    }
                }),
                S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function(t, e) {
                    S.fn[e] = function(t, n) {
                        return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e)
                    }
                }
                ));
                var Je = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
                S.proxy = function(t, e) {
                    var n, i, r;
                    if ("string" == typeof e && (n = t[e],
                    e = t,
                    t = n),
                    v(t))
                        return i = a.call(arguments, 2),
                        (r = function() {
                            return t.apply(e || this, i.concat(a.call(arguments)))
                        }
                        ).guid = t.guid = t.guid || S.guid++,
                        r
                }
                ,
                S.holdReady = function(t) {
                    t ? S.readyWait++ : S.ready(!0)
                }
                ,
                S.isArray = Array.isArray,
                S.parseJSON = JSON.parse,
                S.nodeName = L,
                S.isFunction = v,
                S.isWindow = y,
                S.camelCase = J,
                S.type = w,
                S.now = Date.now,
                S.isNumeric = function(t) {
                    var e = S.type(t);
                    return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
                }
                ,
                S.trim = function(t) {
                    return null == t ? "" : (t + "").replace(Je, "")
                }
                ,
                void 0 === (n = function() {
                    return S
                }
                .apply(e, [])) || (t.exports = n);
                var Ze = i.jQuery
                  , Ke = i.$;
                return S.noConflict = function(t) {
                    return i.$ === S && (i.$ = Ke),
                    t && i.jQuery === S && (i.jQuery = Ze),
                    S
                }
                ,
                void 0 === r && (i.jQuery = i.$ = S),
                S
            }
            ))
        },
        90: function(t) {
            !function(e, n) {
                var i = function(t, e, n) {
                    "use strict";
                    var i, r;
                    if (function() {
                        var e, n = {
                            lazyClass: "lazyload",
                            loadedClass: "lazyloaded",
                            loadingClass: "lazyloading",
                            preloadClass: "lazypreload",
                            errorClass: "lazyerror",
                            autosizesClass: "lazyautosizes",
                            fastLoadedClass: "ls-is-cached",
                            iframeLoadMode: 0,
                            srcAttr: "data-src",
                            srcsetAttr: "data-srcset",
                            sizesAttr: "data-sizes",
                            minSize: 40,
                            customMedia: {},
                            init: !0,
                            expFactor: 1.5,
                            hFac: .8,
                            loadMode: 2,
                            loadHidden: !0,
                            ricTimeout: 0,
                            throttleDelay: 125
                        };
                        for (e in r = t.lazySizesConfig || t.lazysizesConfig || {},
                        n)
                            e in r || (r[e] = n[e])
                    }(),
                    !e || !e.getElementsByClassName)
                        return {
                            init: function() {},
                            cfg: r,
                            noSupport: !0
                        };
                    var s, o, a, l, c, u, h, d, p, f, m, g, v, y, x, _, b, w, M, S, T, E, A, C, R, L, P, D, I, O, N, k, z, H, B, F, U, G, V, W, j, q, X, Y, J = e.documentElement, Z = t.HTMLPictureElement, K = "addEventListener", Q = t.addEventListener.bind(t), $ = t.setTimeout, tt = t.requestAnimationFrame || $, et = t.requestIdleCallback, nt = /^picture$/i, it = ["load", "error", "lazyincluded", "_lazyloaded"], rt = {}, st = Array.prototype.forEach, ot = function(t, e) {
                        return rt[e] || (rt[e] = new RegExp("(\\s|^)" + e + "(\\s|$)")),
                        rt[e].test(t.getAttribute("class") || "") && rt[e]
                    }, at = function(t, e) {
                        ot(t, e) || t.setAttribute("class", (t.getAttribute("class") || "").trim() + " " + e)
                    }, lt = function(t, e) {
                        var n;
                        (n = ot(t, e)) && t.setAttribute("class", (t.getAttribute("class") || "").replace(n, " "))
                    }, ct = function(t, e, n) {
                        var i = n ? K : "removeEventListener";
                        n && ct(t, e),
                        it.forEach((function(n) {
                            t[i](n, e)
                        }
                        ))
                    }, ut = function(t, n, r, s, o) {
                        var a = e.createEvent("Event");
                        return r || (r = {}),
                        r.instance = i,
                        a.initEvent(n, !s, !o),
                        a.detail = r,
                        t.dispatchEvent(a),
                        a
                    }, ht = function(e, n) {
                        var i;
                        !Z && (i = t.picturefill || r.pf) ? (n && n.src && !e.getAttribute("srcset") && e.setAttribute("srcset", n.src),
                        i({
                            reevaluate: !0,
                            elements: [e]
                        })) : n && n.src && (e.src = n.src)
                    }, dt = function(t, e) {
                        return (getComputedStyle(t, null) || {})[e]
                    }, pt = function(t, e, n) {
                        for (n = n || t.offsetWidth; n < r.minSize && e && !t._lazysizesWidth; )
                            n = e.offsetWidth,
                            e = e.parentNode;
                        return n
                    }, ft = (j = [],
                    q = W = [],
                    (Y = function(t, n) {
                        G && !n ? t.apply(this, arguments) : (q.push(t),
                        V || (V = !0,
                        (e.hidden ? $ : tt)(X)))
                    }
                    )._lsFlush = X = function() {
                        var t = q;
                        for (q = W.length ? j : W,
                        G = !0,
                        V = !1; t.length; )
                            t.shift()();
                        G = !1
                    }
                    ,
                    Y), mt = function(t, e) {
                        return e ? function() {
                            ft(t)
                        }
                        : function() {
                            var e = this
                              , n = arguments;
                            ft((function() {
                                t.apply(e, n)
                            }
                            ))
                        }
                    }, gt = function(t) {
                        var e, i, r = function() {
                            e = null,
                            t()
                        }, s = function() {
                            var t = n.now() - i;
                            t < 99 ? $(s, 99 - t) : (et || r)(r)
                        };
                        return function() {
                            i = n.now(),
                            e || (e = $(s, 99))
                        }
                    }, vt = (b = /^img$/i,
                    w = /^iframe$/i,
                    M = "onscroll"in t && !/(gle|ing)bot/.test(navigator.userAgent),
                    0,
                    S = 0,
                    T = 0,
                    E = -1,
                    A = function(t) {
                        T--,
                        (!t || T < 0 || !t.target) && (T = 0)
                    }
                    ,
                    C = function(t) {
                        return null == _ && (_ = "hidden" == dt(e.body, "visibility")),
                        _ || !("hidden" == dt(t.parentNode, "visibility") && "hidden" == dt(t, "visibility"))
                    }
                    ,
                    R = function(t, n) {
                        var i, r = t, s = C(t);
                        for (g -= n,
                        x += n,
                        v -= n,
                        y += n; s && (r = r.offsetParent) && r != e.body && r != J; )
                            (s = (dt(r, "opacity") || 1) > 0) && "visible" != dt(r, "overflow") && (i = r.getBoundingClientRect(),
                            s = y > i.left && v < i.right && x > i.top - 1 && g < i.bottom + 1);
                        return s
                    }
                    ,
                    P = function(t) {
                        var e, i = 0, s = r.throttleDelay, o = r.ricTimeout, a = function() {
                            e = !1,
                            i = n.now(),
                            t()
                        }, l = et && o > 49 ? function() {
                            et(a, {
                                timeout: o
                            }),
                            o !== r.ricTimeout && (o = r.ricTimeout)
                        }
                        : mt((function() {
                            $(a)
                        }
                        ), !0);
                        return function(t) {
                            var r;
                            (t = !0 === t) && (o = 33),
                            e || (e = !0,
                            (r = s - (n.now() - i)) < 0 && (r = 0),
                            t || r < 9 ? l() : $(l, r))
                        }
                    }(L = function() {
                        var t, n, s, o, a, l, h, p, b, w, A, L, P = i.elements;
                        if ((d = r.loadMode) && T < 8 && (t = P.length)) {
                            for (n = 0,
                            E++; n < t; n++)
                                if (P[n] && !P[n]._lazyRace)
                                    if (!M || i.prematureUnveil && i.prematureUnveil(P[n]))
                                        H(P[n]);
                                    else if ((p = P[n].getAttribute("data-expand")) && (l = 1 * p) || (l = S),
                                    w || (w = !r.expand || r.expand < 1 ? J.clientHeight > 500 && J.clientWidth > 500 ? 500 : 370 : r.expand,
                                    i._defEx = w,
                                    A = w * r.expFactor,
                                    L = r.hFac,
                                    _ = null,
                                    S < A && T < 1 && E > 2 && d > 2 && !e.hidden ? (S = A,
                                    E = 0) : S = d > 1 && E > 1 && T < 6 ? w : 0),
                                    b !== l && (f = innerWidth + l * L,
                                    m = innerHeight + l,
                                    h = -1 * l,
                                    b = l),
                                    s = P[n].getBoundingClientRect(),
                                    (x = s.bottom) >= h && (g = s.top) <= m && (y = s.right) >= h * L && (v = s.left) <= f && (x || y || v || g) && (r.loadHidden || C(P[n])) && (u && T < 3 && !p && (d < 3 || E < 4) || R(P[n], l))) {
                                        if (H(P[n]),
                                        a = !0,
                                        T > 9)
                                            break
                                    } else
                                        !a && u && !o && T < 4 && E < 4 && d > 2 && (c[0] || r.preloadAfterLoad) && (c[0] || !p && (x || y || v || g || "auto" != P[n].getAttribute(r.sizesAttr))) && (o = c[0] || P[n]);
                            o && !a && H(o)
                        }
                    }
                    ),
                    I = mt(D = function(t) {
                        var e = t.target;
                        e._lazyCache ? delete e._lazyCache : (A(t),
                        at(e, r.loadedClass),
                        lt(e, r.loadingClass),
                        ct(e, O),
                        ut(e, "lazyloaded"))
                    }
                    ),
                    O = function(t) {
                        I({
                            target: t.target
                        })
                    }
                    ,
                    N = function(t, e) {
                        var n = t.getAttribute("data-load-mode") || r.iframeLoadMode;
                        0 == n ? t.contentWindow.location.replace(e) : 1 == n && (t.src = e)
                    }
                    ,
                    k = function(t) {
                        var e, n = t.getAttribute(r.srcsetAttr);
                        (e = r.customMedia[t.getAttribute("data-media") || t.getAttribute("media")]) && t.setAttribute("media", e),
                        n && t.setAttribute("srcset", n)
                    }
                    ,
                    z = mt((function(t, e, n, i, s) {
                        var o, a, l, c, u, d;
                        (u = ut(t, "lazybeforeunveil", e)).defaultPrevented || (i && (n ? at(t, r.autosizesClass) : t.setAttribute("sizes", i)),
                        a = t.getAttribute(r.srcsetAttr),
                        o = t.getAttribute(r.srcAttr),
                        s && (c = (l = t.parentNode) && nt.test(l.nodeName || "")),
                        d = e.firesLoad || "src"in t && (a || o || c),
                        u = {
                            target: t
                        },
                        at(t, r.loadingClass),
                        d && (clearTimeout(h),
                        h = $(A, 2500),
                        ct(t, O, !0)),
                        c && st.call(l.getElementsByTagName("source"), k),
                        a ? t.setAttribute("srcset", a) : o && !c && (w.test(t.nodeName) ? N(t, o) : t.src = o),
                        s && (a || c) && ht(t, {
                            src: o
                        })),
                        t._lazyRace && delete t._lazyRace,
                        lt(t, r.lazyClass),
                        ft((function() {
                            var e = t.complete && t.naturalWidth > 1;
                            d && !e || (e && at(t, r.fastLoadedClass),
                            D(u),
                            t._lazyCache = !0,
                            $((function() {
                                "_lazyCache"in t && delete t._lazyCache
                            }
                            ), 9)),
                            "lazy" == t.loading && T--
                        }
                        ), !0)
                    }
                    )),
                    H = function(t) {
                        if (!t._lazyRace) {
                            var e, n = b.test(t.nodeName), i = n && (t.getAttribute(r.sizesAttr) || t.getAttribute("sizes")), s = "auto" == i;
                            (!s && u || !n || !t.getAttribute("src") && !t.srcset || t.complete || ot(t, r.errorClass) || !ot(t, r.lazyClass)) && (e = ut(t, "lazyunveilread").detail,
                            s && yt.updateElem(t, !0, t.offsetWidth),
                            t._lazyRace = !0,
                            T++,
                            z(t, e, s, i, n))
                        }
                    }
                    ,
                    B = gt((function() {
                        r.loadMode = 3,
                        P()
                    }
                    )),
                    U = function() {
                        u || (n.now() - p < 999 ? $(U, 999) : (u = !0,
                        r.loadMode = 3,
                        P(),
                        Q("scroll", F, !0)))
                    }
                    ,
                    {
                        _: function() {
                            p = n.now(),
                            i.elements = e.getElementsByClassName(r.lazyClass),
                            c = e.getElementsByClassName(r.lazyClass + " " + r.preloadClass),
                            Q("scroll", P, !0),
                            Q("resize", P, !0),
                            Q("pageshow", (function(t) {
                                if (t.persisted) {
                                    var n = e.querySelectorAll("." + r.loadingClass);
                                    n.length && n.forEach && tt((function() {
                                        n.forEach((function(t) {
                                            t.complete && H(t)
                                        }
                                        ))
                                    }
                                    ))
                                }
                            }
                            )),
                            t.MutationObserver ? new MutationObserver(P).observe(J, {
                                childList: !0,
                                subtree: !0,
                                attributes: !0
                            }) : (J.addEventListener("DOMNodeInserted", P, !0),
                            J.addEventListener("DOMAttrModified", P, !0),
                            setInterval(P, 999)),
                            Q("hashchange", P, !0),
                            ["focus", "mouseover", "click", "load", "transitionend", "animationend"].forEach((function(t) {
                                e.addEventListener(t, P, !0)
                            }
                            )),
                            /d$|^c/.test(e.readyState) ? U() : (Q("load", U),
                            e.addEventListener("DOMContentLoaded", P),
                            $(U, 2e4)),
                            i.elements.length ? (L(),
                            ft._lsFlush()) : P()
                        },
                        checkElems: P,
                        unveil: H,
                        _aLSL: F = function() {
                            3 == r.loadMode && (r.loadMode = 2),
                            B()
                        }
                    }), yt = (o = mt((function(t, e, n, i) {
                        var r, s, o;
                        if (t._lazysizesWidth = i,
                        i += "px",
                        t.setAttribute("sizes", i),
                        nt.test(e.nodeName || ""))
                            for (s = 0,
                            o = (r = e.getElementsByTagName("source")).length; s < o; s++)
                                r[s].setAttribute("sizes", i);
                        n.detail.dataAttr || ht(t, n.detail)
                    }
                    )),
                    a = function(t, e, n) {
                        var i, r = t.parentNode;
                        r && (n = pt(t, r, n),
                        (i = ut(t, "lazybeforesizes", {
                            width: n,
                            dataAttr: !!e
                        })).defaultPrevented || (n = i.detail.width) && n !== t._lazysizesWidth && o(t, r, i, n))
                    }
                    ,
                    {
                        _: function() {
                            s = e.getElementsByClassName(r.autosizesClass),
                            Q("resize", l)
                        },
                        checkElems: l = gt((function() {
                            var t, e = s.length;
                            if (e)
                                for (t = 0; t < e; t++)
                                    a(s[t])
                        }
                        )),
                        updateElem: a
                    }), xt = function() {
                        !xt.i && e.getElementsByClassName && (xt.i = !0,
                        yt._(),
                        vt._())
                    };
                    return $((function() {
                        r.init && xt()
                    }
                    )),
                    i = {
                        cfg: r,
                        autoSizer: yt,
                        loader: vt,
                        init: xt,
                        uP: ht,
                        aC: at,
                        rC: lt,
                        hC: ot,
                        fire: ut,
                        gW: pt,
                        rAF: ft
                    }
                }(e, e.document, Date);
                e.lazySizes = i,
                t.exports && (t.exports = i)
            }("undefined" != typeof window ? window : {})
        }
    }
      , e = {};
    function n(i) {
        var r = e[i];
        if (void 0 !== r)
            return r.exports;
        var s = e[i] = {
            exports: {}
        };
        return t[i].call(s.exports, s, s.exports, n),
        s.exports
    }
    n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        }
        : function() {
            return t
        }
        ;
        return n.d(e, {
            a: e
        }),
        e
    }
    ,
    n.d = function(t, e) {
        for (var i in e)
            n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            })
    }
    ,
    n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    ,
    function() {
        "use strict";
        function t(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }
        function e(t, e) {
            t.prototype = Object.create(e.prototype),
            t.prototype.constructor = t,
            t.__proto__ = e
        }
        var i, r, s, o, a, l, c, u, h, d, p, f, m, g = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        }, v = {
            duration: .5,
            overwrite: !1,
            delay: 0
        }, y = 1e8, x = 1e-8, _ = 2 * Math.PI, b = _ / 4, w = 0, M = Math.sqrt, S = Math.cos, T = Math.sin, E = function(t) {
            return "string" == typeof t
        }, A = function(t) {
            return "function" == typeof t
        }, C = function(t) {
            return "number" == typeof t
        }, R = function(t) {
            return void 0 === t
        }, L = function(t) {
            return "object" == typeof t
        }, P = function(t) {
            return !1 !== t
        }, D = function() {
            return "undefined" != typeof window
        }, I = function(t) {
            return A(t) || E(t)
        }, O = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
        , N = Array.isArray, k = /(?:-?\.?\d|\.)+/gi, z = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, H = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, B = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, F = /[+-]=-?[.\d]+/, U = /[^,'"\[\]\s]+/gi, G = /[\d.+\-=]+(?:e[-+]\d*)*/i, V = {}, W = {}, j = function(t) {
            return (W = gt(t, V)) && rn
        }, q = function(t, e) {
            return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
        }, X = function(t, e) {
            return !e && console.warn(t)
        }, Y = function(t, e) {
            return t && (V[t] = e) && W && (W[t] = e) || V
        }, J = function() {
            return 0
        }, Z = {}, K = [], Q = {}, $ = {}, tt = {}, et = 30, nt = [], it = "", rt = function(t) {
            var e, n, i = t[0];
            if (L(i) || A(i) || (t = [t]),
            !(e = (i._gsap || {}).harness)) {
                for (n = nt.length; n-- && !nt[n].targetTest(i); )
                    ;
                e = nt[n]
            }
            for (n = t.length; n--; )
                t[n] && (t[n]._gsap || (t[n]._gsap = new Ae(t[n],e))) || t.splice(n, 1);
            return t
        }, st = function(t) {
            return t._gsap || rt(qt(t))[0]._gsap
        }, ot = function(t, e, n) {
            return (n = t[e]) && A(n) ? t[e]() : R(n) && t.getAttribute && t.getAttribute(e) || n
        }, at = function(t, e) {
            return (t = t.split(",")).forEach(e) || t
        }, lt = function(t) {
            return Math.round(1e5 * t) / 1e5 || 0
        }, ct = function(t) {
            return Math.round(1e7 * t) / 1e7 || 0
        }, ut = function(t, e) {
            for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; )
                ;
            return i < n
        }, ht = function() {
            var t, e, n = K.length, i = K.slice(0);
            for (Q = {},
            K.length = 0,
            t = 0; t < n; t++)
                (e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
        }, dt = function(t, e, n, i) {
            K.length && ht(),
            t.render(e, n, i),
            K.length && ht()
        }, pt = function(t) {
            var e = parseFloat(t);
            return (e || 0 === e) && (t + "").match(U).length < 2 ? e : E(t) ? t.trim() : t
        }, ft = function(t) {
            return t
        }, mt = function(t, e) {
            for (var n in e)
                n in t || (t[n] = e[n]);
            return t
        }, gt = function(t, e) {
            for (var n in e)
                t[n] = e[n];
            return t
        }, vt = function t(e, n) {
            for (var i in n)
                "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = L(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
            return e
        }, yt = function(t, e) {
            var n, i = {};
            for (n in t)
                n in e || (i[n] = t[n]);
            return i
        }, xt = function(t) {
            var e, n = t.parent || r, i = t.keyframes ? (e = N(t.keyframes),
            function(t, n) {
                for (var i in n)
                    i in t || "duration" === i && e || "ease" === i || (t[i] = n[i])
            }
            ) : mt;
            if (P(t.inherit))
                for (; n; )
                    i(t, n.vars.defaults),
                    n = n.parent || n._dp;
            return t
        }, _t = function(t, e, n, i) {
            void 0 === n && (n = "_first"),
            void 0 === i && (i = "_last");
            var r = e._prev
              , s = e._next;
            r ? r._next = s : t[n] === e && (t[n] = s),
            s ? s._prev = r : t[i] === e && (t[i] = r),
            e._next = e._prev = e.parent = null
        }, bt = function(t, e) {
            t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
            t._act = 0
        }, wt = function(t, e) {
            if (t && (!e || e._end > t._dur || e._start < 0))
                for (var n = t; n; )
                    n._dirty = 1,
                    n = n.parent;
            return t
        }, Mt = function(t) {
            for (var e = t.parent; e && e.parent; )
                e._dirty = 1,
                e.totalDuration(),
                e = e.parent;
            return t
        }, St = function t(e) {
            return !e || e._ts && t(e.parent)
        }, Tt = function(t) {
            return t._repeat ? Et(t._tTime, t = t.duration() + t._rDelay) * t : 0
        }, Et = function(t, e) {
            var n = Math.floor(t /= e);
            return t && n === t ? n - 1 : n
        }, At = function(t, e) {
            return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        }, Ct = function(t) {
            return t._end = ct(t._start + (t._tDur / Math.abs(t._ts || t._rts || x) || 0))
        }, Rt = function(t, e) {
            var n = t._dp;
            return n && n.smoothChildTiming && t._ts && (t._start = ct(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)),
            Ct(t),
            n._dirty || wt(n, t)),
            t
        }, Lt = function(t, e) {
            var n;
            if ((e._time || e._initted && !e._dur) && (n = At(t.rawTime(), e),
            (!e._dur || Gt(0, e.totalDuration(), n) - e._tTime > x) && e.render(n, !0)),
            wt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                if (t._dur < t.duration())
                    for (n = t; n._dp; )
                        n.rawTime() >= 0 && n.totalTime(n._tTime),
                        n = n._dp;
                t._zTime = -1e-8
            }
        }, Pt = function(t, e, n, i) {
            return e.parent && bt(e),
            e._start = ct((C(n) ? n : n || t !== r ? Bt(t, n, e) : t._time) + e._delay),
            e._end = ct(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
            function(t, e, n, i, r) {
                void 0 === n && (n = "_first"),
                void 0 === i && (i = "_last");
                var s, o = t[i];
                if (r)
                    for (s = e[r]; o && o[r] > s; )
                        o = o._prev;
                o ? (e._next = o._next,
                o._next = e) : (e._next = t[n],
                t[n] = e),
                e._next ? e._next._prev = e : t[i] = e,
                e._prev = o,
                e.parent = e._dp = t
            }(t, e, "_first", "_last", t._sort ? "_start" : 0),
            Nt(e) || (t._recent = e),
            i || Lt(t, e),
            t
        }, Dt = function(t, e) {
            return (V.ScrollTrigger || q("scrollTrigger", e)) && V.ScrollTrigger.create(e, t)
        }, It = function(t, e, n, i) {
            return Oe(t, e),
            t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && c !== fe.frame ? (K.push(t),
            t._lazy = [e, i],
            1) : void 0 : 1
        }, Ot = function t(e) {
            var n = e.parent;
            return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
        }, Nt = function(t) {
            var e = t.data;
            return "isFromStart" === e || "isStart" === e
        }, kt = function(t, e, n, i) {
            var r = t._repeat
              , s = ct(e) || 0
              , o = t._tTime / t._tDur;
            return o && !i && (t._time *= s / t._dur),
            t._dur = s,
            t._tDur = r ? r < 0 ? 1e10 : ct(s * (r + 1) + t._rDelay * r) : s,
            o > 0 && !i ? Rt(t, t._tTime = t._tDur * o) : t.parent && Ct(t),
            n || wt(t.parent, t),
            t
        }, zt = function(t) {
            return t instanceof Re ? wt(t) : kt(t, t._dur)
        }, Ht = {
            _start: 0,
            endTime: J,
            totalDuration: J
        }, Bt = function t(e, n, i) {
            var r, s, o, a = e.labels, l = e._recent || Ht, c = e.duration() >= y ? l.endTime(!1) : e._dur;
            return E(n) && (isNaN(n) || n in a) ? (s = n.charAt(0),
            o = "%" === n.substr(-1),
            r = n.indexOf("="),
            "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")),
            ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (o ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in a || (a[n] = c),
            a[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)),
            o && i && (s = s / 100 * (N(i) ? i[0] : i).totalDuration()),
            r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n
        }, Ft = function(t, e, n) {
            var i, r, s = C(e[1]), o = (s ? 2 : 1) + (t < 2 ? 0 : 1), a = e[o];
            if (s && (a.duration = e[1]),
            a.parent = n,
            t) {
                for (i = a,
                r = n; r && !("immediateRender"in i); )
                    i = r.vars.defaults || {},
                    r = P(r.vars.inherit) && r.parent;
                a.immediateRender = P(i.immediateRender),
                t < 2 ? a.runBackwards = 1 : a.startAt = e[o - 1]
            }
            return new Be(e[0],a,e[o + 1])
        }, Ut = function(t, e) {
            return t || 0 === t ? e(t) : e
        }, Gt = function(t, e, n) {
            return n < t ? t : n > e ? e : n
        }, Vt = function(t, e) {
            return E(t) && (e = G.exec(t)) ? t.substr(e.index + e[0].length) : ""
        }, Wt = [].slice, jt = function(t, e) {
            return t && L(t) && "length"in t && (!e && !t.length || t.length - 1 in t && L(t[0])) && !t.nodeType && t !== s
        }, qt = function(t, e, n) {
            return !E(t) || n || !o && me() ? N(t) ? function(t, e, n) {
                return void 0 === n && (n = []),
                t.forEach((function(t) {
                    var i;
                    return E(t) && !e || jt(t, 1) ? (i = n).push.apply(i, qt(t)) : n.push(t)
                }
                )) || n
            }(t, n) : jt(t) ? Wt.call(t, 0) : t ? [t] : [] : Wt.call((e || a).querySelectorAll(t), 0)
        }, Xt = function(t) {
            return t.sort((function() {
                return .5 - Math.random()
            }
            ))
        }, Yt = function(t) {
            if (A(t))
                return t;
            var e = L(t) ? t : {
                each: t
            }
              , n = we(e.ease)
              , i = e.from || 0
              , r = parseFloat(e.base) || 0
              , s = {}
              , o = i > 0 && i < 1
              , a = isNaN(i) || o
              , l = e.axis
              , c = i
              , u = i;
            return E(i) ? c = u = {
                center: .5,
                edges: .5,
                end: 1
            }[i] || 0 : !o && a && (c = i[0],
            u = i[1]),
            function(t, o, h) {
                var d, p, f, m, g, v, x, _, b, w = (h || e).length, S = s[w];
                if (!S) {
                    if (!(b = "auto" === e.grid ? 0 : (e.grid || [1, y])[1])) {
                        for (x = -y; x < (x = h[b++].getBoundingClientRect().left) && b < w; )
                            ;
                        b--
                    }
                    for (S = s[w] = [],
                    d = a ? Math.min(b, w) * c - .5 : i % b,
                    p = b === y ? 0 : a ? w * u / b - .5 : i / b | 0,
                    x = 0,
                    _ = y,
                    v = 0; v < w; v++)
                        f = v % b - d,
                        m = p - (v / b | 0),
                        S[v] = g = l ? Math.abs("y" === l ? m : f) : M(f * f + m * m),
                        g > x && (x = g),
                        g < _ && (_ = g);
                    "random" === i && Xt(S),
                    S.max = x - _,
                    S.min = _,
                    S.v = w = (parseFloat(e.amount) || parseFloat(e.each) * (b > w ? w - 1 : l ? "y" === l ? w / b : b : Math.max(b, w / b)) || 0) * ("edges" === i ? -1 : 1),
                    S.b = w < 0 ? r - w : r,
                    S.u = Vt(e.amount || e.each) || 0,
                    n = n && w < 0 ? _e(n) : n
                }
                return w = (S[t] - S.min) / S.max || 0,
                ct(S.b + (n ? n(w) : w) * S.v) + S.u
            }
        }, Jt = function(t) {
            var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
            return function(n) {
                var i = Math.round(parseFloat(n) / t) * t * e;
                return (i - i % 1) / e + (C(n) ? 0 : Vt(n))
            }
        }, Zt = function(t, e) {
            var n, i, r = N(t);
            return !r && L(t) && (n = r = t.radius || y,
            t.values ? (t = qt(t.values),
            (i = !C(t[0])) && (n *= n)) : t = Jt(t.increment)),
            Ut(e, r ? A(t) ? function(e) {
                return i = t(e),
                Math.abs(i - e) <= n ? i : e
            }
            : function(e) {
                for (var r, s, o = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = y, c = 0, u = t.length; u--; )
                    (r = i ? (r = t[u].x - o) * r + (s = t[u].y - a) * s : Math.abs(t[u] - o)) < l && (l = r,
                    c = u);
                return c = !n || l <= n ? t[c] : e,
                i || c === e || C(e) ? c : c + Vt(e)
            }
            : Jt(t))
        }, Kt = function(t, e, n, i) {
            return Ut(N(t) ? !e : !0 === n ? !!(n = 0) : !i, (function() {
                return N(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i
            }
            ))
        }, Qt = function(t, e, n) {
            return Ut(n, (function(n) {
                return t[~~e(n)]
            }
            ))
        }, $t = function(t) {
            for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s)); )
                i = t.indexOf(")", e),
                r = "[" === t.charAt(e + 7),
                n = t.substr(e + 7, i - e - 7).match(r ? U : k),
                o += t.substr(s, e - s) + Kt(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5),
                s = i + 1;
            return o + t.substr(s, t.length - s)
        }, te = function(t, e, n, i, r) {
            var s = e - t
              , o = i - n;
            return Ut(r, (function(e) {
                return n + ((e - t) / s * o || 0)
            }
            ))
        }, ee = function(t, e, n) {
            var i, r, s, o = t.labels, a = y;
            for (i in o)
                (r = o[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i,
                a = r);
            return s
        }, ne = function(t, e, n) {
            var i, r, s = t.vars, o = s[e];
            if (o)
                return i = s[e + "Params"],
                r = s.callbackScope || t,
                n && K.length && ht(),
                i ? o.apply(r, i) : o.call(r)
        }, ie = function(t) {
            return bt(t),
            t.scrollTrigger && t.scrollTrigger.kill(!1),
            t.progress() < 1 && ne(t, "onInterrupt"),
            t
        }, re = function(t) {
            var e = (t = !t.name && t.default || t).name
              , n = A(t)
              , i = e && !n && t.init ? function() {
                this._props = []
            }
            : t
              , r = {
                init: J,
                render: Ye,
                add: De,
                kill: Ze,
                modifier: Je,
                rawVars: 0
            }
              , s = {
                targetTest: 0,
                get: 0,
                getSetter: We,
                aliases: {},
                register: 0
            };
            if (me(),
            t !== i) {
                if ($[e])
                    return;
                mt(i, mt(yt(t, r), s)),
                gt(i.prototype, gt(r, yt(t, s))),
                $[i.prop = e] = i,
                t.targetTest && (nt.push(i),
                Z[e] = 1),
                e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
            }
            Y(e, i),
            t.register && t.register(rn, i, $e)
        }, se = 255, oe = {
            aqua: [0, se, se],
            lime: [0, se, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, se],
            navy: [0, 0, 128],
            white: [se, se, se],
            olive: [128, 128, 0],
            yellow: [se, se, 0],
            orange: [se, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [se, 0, 0],
            pink: [se, 192, 203],
            cyan: [0, se, se],
            transparent: [se, se, se, 0]
        }, ae = function(t, e, n) {
            return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * se + .5 | 0
        }, le = function(t, e, n) {
            var i, r, s, o, a, l, c, u, h, d, p = t ? C(t) ? [t >> 16, t >> 8 & se, t & se] : 0 : oe.black;
            if (!p) {
                if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
                oe[t])
                    p = oe[t];
                else if ("#" === t.charAt(0)) {
                    if (t.length < 6 && (i = t.charAt(1),
                    r = t.charAt(2),
                    s = t.charAt(3),
                    t = "#" + i + i + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")),
                    9 === t.length)
                        return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & se, p & se, parseInt(t.substr(7), 16) / 255];
                    p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & se, t & se]
                } else if ("hsl" === t.substr(0, 3))
                    if (p = d = t.match(k),
                    e) {
                        if (~t.indexOf("="))
                            return p = t.match(z),
                            n && p.length < 4 && (p[3] = 1),
                            p
                    } else
                        o = +p[0] % 360 / 360,
                        a = +p[1] / 100,
                        i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a),
                        p.length > 3 && (p[3] *= 1),
                        p[0] = ae(o + 1 / 3, i, r),
                        p[1] = ae(o, i, r),
                        p[2] = ae(o - 1 / 3, i, r);
                else
                    p = t.match(k) || oe.transparent;
                p = p.map(Number)
            }
            return e && !d && (i = p[0] / se,
            r = p[1] / se,
            s = p[2] / se,
            l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2,
            c === u ? o = a = 0 : (h = c - u,
            a = l > .5 ? h / (2 - c - u) : h / (c + u),
            o = c === i ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - i) / h + 2 : (i - r) / h + 4,
            o *= 60),
            p[0] = ~~(o + .5),
            p[1] = ~~(100 * a + .5),
            p[2] = ~~(100 * l + .5)),
            n && p.length < 4 && (p[3] = 1),
            p
        }, ce = function(t) {
            var e = []
              , n = []
              , i = -1;
            return t.split(he).forEach((function(t) {
                var r = t.match(H) || [];
                e.push.apply(e, r),
                n.push(i += r.length + 1)
            }
            )),
            e.c = n,
            e
        }, ue = function(t, e, n) {
            var i, r, s, o, a = "", l = (t + a).match(he), c = e ? "hsla(" : "rgba(", u = 0;
            if (!l)
                return t;
            if (l = l.map((function(t) {
                return (t = le(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
            }
            )),
            n && (s = ce(t),
            (i = n.c).join(a) !== s.c.join(a)))
                for (o = (r = t.replace(he, "1").split(H)).length - 1; u < o; u++)
                    a += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
            if (!r)
                for (o = (r = t.split(he)).length - 1; u < o; u++)
                    a += r[u] + l[u];
            return a + r[o]
        }, he = function() {
            var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (t in oe)
                e += "|" + t + "\\b";
            return new RegExp(e + ")","gi")
        }(), de = /hsl[a]?\(/, pe = function(t) {
            var e, n = t.join(" ");
            if (he.lastIndex = 0,
            he.test(n))
                return e = de.test(n),
                t[1] = ue(t[1], e),
                t[0] = ue(t[0], e, ce(t[1])),
                !0
        }, fe = function() {
            var t, e, n, i, r, c, u = Date.now, d = 500, p = 33, f = u(), m = f, g = 1e3 / 240, v = g, y = [], x = function n(s) {
                var o, a, l, h, x = u() - m, _ = !0 === s;
                if (x > d && (f += x - p),
                ((o = (l = (m += x) - f) - v) > 0 || _) && (h = ++i.frame,
                r = l - 1e3 * i.time,
                i.time = l /= 1e3,
                v += o + (o >= g ? 4 : g - o),
                a = 1),
                _ || (t = e(n)),
                a)
                    for (c = 0; c < y.length; c++)
                        y[c](l, r, h, s)
            };
            return i = {
                time: 0,
                frame: 0,
                tick: function() {
                    x(!0)
                },
                deltaRatio: function(t) {
                    return r / (1e3 / (t || 60))
                },
                wake: function() {
                    l && (!o && D() && (s = o = window,
                    a = s.document || {},
                    V.gsap = rn,
                    (s.gsapVersions || (s.gsapVersions = [])).push(rn.version),
                    j(W || s.GreenSockGlobals || !s.gsap && s || {}),
                    n = s.requestAnimationFrame),
                    t && i.sleep(),
                    e = n || function(t) {
                        return setTimeout(t, v - 1e3 * i.time + 1 | 0)
                    }
                    ,
                    h = 1,
                    x(2))
                },
                sleep: function() {
                    (n ? s.cancelAnimationFrame : clearTimeout)(t),
                    h = 0,
                    e = J
                },
                lagSmoothing: function(t, e) {
                    d = t || 1e8,
                    p = Math.min(e, d, 0)
                },
                fps: function(t) {
                    g = 1e3 / (t || 240),
                    v = 1e3 * i.time + g
                },
                add: function(t) {
                    y.indexOf(t) < 0 && y.push(t),
                    me()
                },
                remove: function(t, e) {
                    ~(e = y.indexOf(t)) && y.splice(e, 1) && c >= e && c--
                },
                _listeners: y
            }
        }(), me = function() {
            return !h && fe.wake()
        }, ge = {}, ve = /^[\d.\-M][\d.\-,\s]/, ye = /["']/g, xe = function(t) {
            for (var e, n, i, r = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++)
                n = s[a],
                e = a !== l - 1 ? n.lastIndexOf(",") : n.length,
                i = n.substr(0, e),
                r[o] = isNaN(i) ? i.replace(ye, "").trim() : +i,
                o = n.substr(e + 1).trim();
            return r
        }, _e = function(t) {
            return function(e) {
                return 1 - t(1 - e)
            }
        }, be = function t(e, n) {
            for (var i, r = e._first; r; )
                r instanceof Re ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease,
                r._ease = r._yEase,
                r._yEase = i,
                r._yoyo = n)),
                r = r._next
        }, we = function(t, e) {
            return t && (A(t) ? t : ge[t] || function(t) {
                var e, n, i, r, s = (t + "").split("("), o = ge[s[0]];
                return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [xe(s[1])] : (e = t,
                n = e.indexOf("(") + 1,
                i = e.indexOf(")"),
                r = e.indexOf("(", n),
                e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(pt)) : ge._CE && ve.test(t) ? ge._CE("", t) : o
            }(t)) || e
        }, Me = function(t, e, n, i) {
            void 0 === n && (n = function(t) {
                return 1 - e(1 - t)
            }
            ),
            void 0 === i && (i = function(t) {
                return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
            }
            );
            var r, s = {
                easeIn: e,
                easeOut: n,
                easeInOut: i
            };
            return at(t, (function(t) {
                for (var e in ge[t] = V[t] = s,
                ge[r = t.toLowerCase()] = n,
                s)
                    ge[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = ge[t + "." + e] = s[e]
            }
            )),
            s
        }, Se = function(t) {
            return function(e) {
                return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
            }
        }, Te = function t(e, n, i) {
            var r = n >= 1 ? n : 1
              , s = (i || (e ? .3 : .45)) / (n < 1 ? n : 1)
              , o = s / _ * (Math.asin(1 / r) || 0)
              , a = function(t) {
                return 1 === t ? 1 : r * Math.pow(2, -10 * t) * T((t - o) * s) + 1
            }
              , l = "out" === e ? a : "in" === e ? function(t) {
                return 1 - a(1 - t)
            }
            : Se(a);
            return s = _ / s,
            l.config = function(n, i) {
                return t(e, n, i)
            }
            ,
            l
        }, Ee = function t(e, n) {
            void 0 === n && (n = 1.70158);
            var i = function(t) {
                return t ? --t * t * ((n + 1) * t + n) + 1 : 0
            }
              , r = "out" === e ? i : "in" === e ? function(t) {
                return 1 - i(1 - t)
            }
            : Se(i);
            return r.config = function(n) {
                return t(e, n)
            }
            ,
            r
        };
        at("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
            var n = e < 5 ? e + 1 : e;
            Me(t + ",Power" + (n - 1), e ? function(t) {
                return Math.pow(t, n)
            }
            : function(t) {
                return t
            }
            , (function(t) {
                return 1 - Math.pow(1 - t, n)
            }
            ), (function(t) {
                return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
            }
            ))
        }
        )),
        ge.Linear.easeNone = ge.none = ge.Linear.easeIn,
        Me("Elastic", Te("in"), Te("out"), Te()),
        d = 7.5625,
        f = 1 / (p = 2.75),
        Me("Bounce", (function(t) {
            return 1 - m(1 - t)
        }
        ), m = function(t) {
            return t < f ? d * t * t : t < .7272727272727273 ? d * Math.pow(t - 1.5 / p, 2) + .75 : t < .9090909090909092 ? d * (t -= 2.25 / p) * t + .9375 : d * Math.pow(t - 2.625 / p, 2) + .984375
        }
        ),
        Me("Expo", (function(t) {
            return t ? Math.pow(2, 10 * (t - 1)) : 0
        }
        )),
        Me("Circ", (function(t) {
            return -(M(1 - t * t) - 1)
        }
        )),
        Me("Sine", (function(t) {
            return 1 === t ? 1 : 1 - S(t * b)
        }
        )),
        Me("Back", Ee("in"), Ee("out"), Ee()),
        ge.SteppedEase = ge.steps = V.SteppedEase = {
            config: function(t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t
                  , i = t + (e ? 0 : 1)
                  , r = e ? 1 : 0;
                return function(t) {
                    return ((i * Gt(0, .99999999, t) | 0) + r) * n
                }
            }
        },
        v.ease = ge["quad.out"],
        at("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
            return it += t + "," + t + "Params,"
        }
        ));
        var Ae = function(t, e) {
            this.id = w++,
            t._gsap = this,
            this.target = t,
            this.harness = e,
            this.get = e ? e.get : ot,
            this.set = e ? e.getSetter : We
        }
          , Ce = function() {
            function t(t) {
                this.vars = t,
                this._delay = +t.delay || 0,
                (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
                this._yoyo = !!t.yoyo || !!t.yoyoEase),
                this._ts = 1,
                kt(this, +t.duration, 1, 1),
                this.data = t.data,
                h || fe.wake()
            }
            var e = t.prototype;
            return e.delay = function(t) {
                return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay),
                this._delay = t,
                this) : this._delay
            }
            ,
            e.duration = function(t) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
            }
            ,
            e.totalDuration = function(t) {
                return arguments.length ? (this._dirty = 0,
                kt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }
            ,
            e.totalTime = function(t, e) {
                if (me(),
                !arguments.length)
                    return this._tTime;
                var n = this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                    for (Rt(this, t),
                    !n._dp || n.parent || Lt(n, this); n && n.parent; )
                        n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                        n = n.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Pt(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === x || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t),
                dt(this, t, e)),
                this
            }
            ,
            e.time = function(t, e) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Tt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
            }
            ,
            e.totalProgress = function(t, e) {
                return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
            }
            ,
            e.progress = function(t, e) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Tt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
            }
            ,
            e.iteration = function(t, e) {
                var n = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Et(this._tTime, n) + 1 : 1
            }
            ,
            e.timeScale = function(t) {
                if (!arguments.length)
                    return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === t)
                    return this;
                var e = this.parent && this._ts ? At(this.parent._time, this) : this._tTime;
                return this._rts = +t || 0,
                this._ts = this._ps || -1e-8 === t ? 0 : this._rts,
                Mt(this.totalTime(Gt(-this._delay, this._tDur, e), !0)),
                Ct(this),
                this
            }
            ,
            e.paused = function(t) {
                return arguments.length ? (this._ps !== t && (this._ps = t,
                t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                this._ts = this._act = 0) : (me(),
                this._ts = this._rts,
                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== x && (this._tTime -= x)))),
                this) : this._ps
            }
            ,
            e.startTime = function(t) {
                if (arguments.length) {
                    this._start = t;
                    var e = this.parent || this._dp;
                    return e && (e._sort || !this.parent) && Pt(e, this, t - this._delay),
                    this
                }
                return this._start
            }
            ,
            e.endTime = function(t) {
                return this._start + (P(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }
            ,
            e.rawTime = function(t) {
                var e = this.parent || this._dp;
                return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? At(e.rawTime(t), this) : this._tTime : this._tTime
            }
            ,
            e.globalTime = function(t) {
                for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
                    n = e._start + n / (e._ts || 1),
                    e = e._dp;
                return n
            }
            ,
            e.repeat = function(t) {
                return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t,
                zt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }
            ,
            e.repeatDelay = function(t) {
                if (arguments.length) {
                    var e = this._time;
                    return this._rDelay = t,
                    zt(this),
                    e ? this.time(e) : this
                }
                return this._rDelay
            }
            ,
            e.yoyo = function(t) {
                return arguments.length ? (this._yoyo = t,
                this) : this._yoyo
            }
            ,
            e.seek = function(t, e) {
                return this.totalTime(Bt(this, t), P(e))
            }
            ,
            e.restart = function(t, e) {
                return this.play().totalTime(t ? -this._delay : 0, P(e))
            }
            ,
            e.play = function(t, e) {
                return null != t && this.seek(t, e),
                this.reversed(!1).paused(!1)
            }
            ,
            e.reverse = function(t, e) {
                return null != t && this.seek(t || this.totalDuration(), e),
                this.reversed(!0).paused(!1)
            }
            ,
            e.pause = function(t, e) {
                return null != t && this.seek(t, e),
                this.paused(!0)
            }
            ,
            e.resume = function() {
                return this.paused(!1)
            }
            ,
            e.reversed = function(t) {
                return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)),
                this) : this._rts < 0
            }
            ,
            e.invalidate = function() {
                return this._initted = this._act = 0,
                this._zTime = -1e-8,
                this
            }
            ,
            e.isActive = function() {
                var t, e = this.parent || this._dp, n = this._start;
                return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - x))
            }
            ,
            e.eventCallback = function(t, e, n) {
                var i = this.vars;
                return arguments.length > 1 ? (e ? (i[t] = e,
                n && (i[t + "Params"] = n),
                "onUpdate" === t && (this._onUpdate = e)) : delete i[t],
                this) : i[t]
            }
            ,
            e.then = function(t) {
                var e = this;
                return new Promise((function(n) {
                    var i = A(t) ? t : ft
                      , r = function() {
                        var t = e.then;
                        e.then = null,
                        A(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                        n(i),
                        e.then = t
                    };
                    e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                }
                ))
            }
            ,
            e.kill = function() {
                ie(this)
            }
            ,
            t
        }();
        mt(Ce.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Re = function(n) {
            function i(e, i) {
                var s;
                return void 0 === e && (e = {}),
                (s = n.call(this, e) || this).labels = {},
                s.smoothChildTiming = !!e.smoothChildTiming,
                s.autoRemoveChildren = !!e.autoRemoveChildren,
                s._sort = P(e.sortChildren),
                r && Pt(e.parent || r, t(s), i),
                e.reversed && s.reverse(),
                e.paused && s.paused(!0),
                e.scrollTrigger && Dt(t(s), e.scrollTrigger),
                s
            }
            e(i, n);
            var s = i.prototype;
            return s.to = function(t, e, n) {
                return Ft(0, arguments, this),
                this
            }
            ,
            s.from = function(t, e, n) {
                return Ft(1, arguments, this),
                this
            }
            ,
            s.fromTo = function(t, e, n, i) {
                return Ft(2, arguments, this),
                this
            }
            ,
            s.set = function(t, e, n) {
                return e.duration = 0,
                e.parent = this,
                xt(e).repeatDelay || (e.repeat = 0),
                e.immediateRender = !!e.immediateRender,
                new Be(t,e,Bt(this, n),1),
                this
            }
            ,
            s.call = function(t, e, n) {
                return Pt(this, Be.delayedCall(0, t, e), n)
            }
            ,
            s.staggerTo = function(t, e, n, i, r, s, o) {
                return n.duration = e,
                n.stagger = n.stagger || i,
                n.onComplete = s,
                n.onCompleteParams = o,
                n.parent = this,
                new Be(t,n,Bt(this, r)),
                this
            }
            ,
            s.staggerFrom = function(t, e, n, i, r, s, o) {
                return n.runBackwards = 1,
                xt(n).immediateRender = P(n.immediateRender),
                this.staggerTo(t, e, n, i, r, s, o)
            }
            ,
            s.staggerFromTo = function(t, e, n, i, r, s, o, a) {
                return i.startAt = n,
                xt(i).immediateRender = P(i.immediateRender),
                this.staggerTo(t, e, i, r, s, o, a)
            }
            ,
            s.render = function(t, e, n) {
                var i, s, o, a, l, c, u, h, d, p, f, m, g = this._time, v = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, _ = t <= 0 ? 0 : ct(t), b = this._zTime < 0 != t < 0 && (this._initted || !y);
                if (this !== r && _ > v && t >= 0 && (_ = v),
                _ !== this._tTime || n || b) {
                    if (g !== this._time && y && (_ += this._time - g,
                    t += this._time - g),
                    i = _,
                    d = this._start,
                    c = !(h = this._ts),
                    b && (y || (g = this._zTime),
                    (t || !e) && (this._zTime = t)),
                    this._repeat) {
                        if (f = this._yoyo,
                        l = y + this._rDelay,
                        this._repeat < -1 && t < 0)
                            return this.totalTime(100 * l + t, e, n);
                        if (i = ct(_ % l),
                        _ === v ? (a = this._repeat,
                        i = y) : ((a = ~~(_ / l)) && a === _ / l && (i = y,
                        a--),
                        i > y && (i = y)),
                        p = Et(this._tTime, l),
                        !g && this._tTime && p !== a && (p = a),
                        f && 1 & a && (i = y - i,
                        m = 1),
                        a !== p && !this._lock) {
                            var w = f && 1 & p
                              , M = w === (f && 1 & a);
                            if (a < p && (w = !w),
                            g = w ? 0 : y,
                            this._lock = 1,
                            this.render(g || (m ? 0 : ct(a * l)), e, !y)._lock = 0,
                            this._tTime = _,
                            !e && this.parent && ne(this, "onRepeat"),
                            this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1),
                            g && g !== this._time || c !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                                return this;
                            if (y = this._dur,
                            v = this._tDur,
                            M && (this._lock = 2,
                            g = w ? y : -1e-4,
                            this.render(g, !0),
                            this.vars.repeatRefresh && !m && this.invalidate()),
                            this._lock = 0,
                            !this._ts && !c)
                                return this;
                            be(this, m)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (u = function(t, e, n) {
                        var i;
                        if (n > e)
                            for (i = t._first; i && i._start <= n; ) {
                                if ("isPause" === i.data && i._start > e)
                                    return i;
                                i = i._next
                            }
                        else
                            for (i = t._last; i && i._start >= n; ) {
                                if ("isPause" === i.data && i._start < e)
                                    return i;
                                i = i._prev
                            }
                    }(this, ct(g), ct(i))) && (_ -= i - (i = u._start)),
                    this._tTime = _,
                    this._time = i,
                    this._act = !h,
                    this._initted || (this._onUpdate = this.vars.onUpdate,
                    this._initted = 1,
                    this._zTime = t,
                    g = 0),
                    !g && i && !e && (ne(this, "onStart"),
                    this._tTime !== _))
                        return this;
                    if (i >= g && t >= 0)
                        for (s = this._first; s; ) {
                            if (o = s._next,
                            (s._act || i >= s._start) && s._ts && u !== s) {
                                if (s.parent !== this)
                                    return this.render(t, e, n);
                                if (s.render(s._ts > 0 ? (i - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (i - s._start) * s._ts, e, n),
                                i !== this._time || !this._ts && !c) {
                                    u = 0,
                                    o && (_ += this._zTime = -1e-8);
                                    break
                                }
                            }
                            s = o
                        }
                    else {
                        s = this._last;
                        for (var S = t < 0 ? t : i; s; ) {
                            if (o = s._prev,
                            (s._act || S <= s._end) && s._ts && u !== s) {
                                if (s.parent !== this)
                                    return this.render(t, e, n);
                                if (s.render(s._ts > 0 ? (S - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (S - s._start) * s._ts, e, n),
                                i !== this._time || !this._ts && !c) {
                                    u = 0,
                                    o && (_ += this._zTime = S ? -1e-8 : x);
                                    break
                                }
                            }
                            s = o
                        }
                    }
                    if (u && !e && (this.pause(),
                    u.render(i >= g ? 0 : -1e-8)._zTime = i >= g ? 1 : -1,
                    this._ts))
                        return this._start = d,
                        Ct(this),
                        this.render(t, e, n);
                    this._onUpdate && !e && ne(this, "onUpdate", !0),
                    (_ === v && v >= this.totalDuration() || !_ && g) && (d !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !y) && (_ === v && this._ts > 0 || !_ && this._ts < 0) && bt(this, 1),
                    e || t < 0 && !g || !_ && !g && v || (ne(this, _ === v && t >= 0 ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(_ < v && this.timeScale() > 0) && this._prom())))
                }
                return this
            }
            ,
            s.add = function(t, e) {
                var n = this;
                if (C(e) || (e = Bt(this, e, t)),
                !(t instanceof Ce)) {
                    if (N(t))
                        return t.forEach((function(t) {
                            return n.add(t, e)
                        }
                        )),
                        this;
                    if (E(t))
                        return this.addLabel(t, e);
                    if (!A(t))
                        return this;
                    t = Be.delayedCall(0, t)
                }
                return this !== t ? Pt(this, t, e) : this
            }
            ,
            s.getChildren = function(t, e, n, i) {
                void 0 === t && (t = !0),
                void 0 === e && (e = !0),
                void 0 === n && (n = !0),
                void 0 === i && (i = -y);
                for (var r = [], s = this._first; s; )
                    s._start >= i && (s instanceof Be ? e && r.push(s) : (n && r.push(s),
                    t && r.push.apply(r, s.getChildren(!0, e, n)))),
                    s = s._next;
                return r
            }
            ,
            s.getById = function(t) {
                for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
                    if (e[n].vars.id === t)
                        return e[n]
            }
            ,
            s.remove = function(t) {
                return E(t) ? this.removeLabel(t) : A(t) ? this.killTweensOf(t) : (_t(this, t),
                t === this._recent && (this._recent = this._last),
                wt(this))
            }
            ,
            s.totalTime = function(t, e) {
                return arguments.length ? (this._forcing = 1,
                !this._dp && this._ts && (this._start = ct(fe.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))),
                n.prototype.totalTime.call(this, t, e),
                this._forcing = 0,
                this) : this._tTime
            }
            ,
            s.addLabel = function(t, e) {
                return this.labels[t] = Bt(this, e),
                this
            }
            ,
            s.removeLabel = function(t) {
                return delete this.labels[t],
                this
            }
            ,
            s.addPause = function(t, e, n) {
                var i = Be.delayedCall(0, e || J, n);
                return i.data = "isPause",
                this._hasPause = 1,
                Pt(this, i, Bt(this, t))
            }
            ,
            s.removePause = function(t) {
                var e = this._first;
                for (t = Bt(this, t); e; )
                    e._start === t && "isPause" === e.data && bt(e),
                    e = e._next
            }
            ,
            s.killTweensOf = function(t, e, n) {
                for (var i = this.getTweensOf(t, n), r = i.length; r--; )
                    Le !== i[r] && i[r].kill(t, e);
                return this
            }
            ,
            s.getTweensOf = function(t, e) {
                for (var n, i = [], r = qt(t), s = this._first, o = C(e); s; )
                    s instanceof Be ? ut(s._targets, r) && (o ? (!Le || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
                    s = s._next;
                return i
            }
            ,
            s.tweenTo = function(t, e) {
                e = e || {};
                var n, i = this, r = Bt(i, t), s = e, o = s.startAt, a = s.onStart, l = s.onStartParams, c = s.immediateRender, u = Be.to(i, mt({
                    ease: e.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration: e.duration || Math.abs((r - (o && "time"in o ? o.time : i._time)) / i.timeScale()) || x,
                    onStart: function() {
                        if (i.pause(),
                        !n) {
                            var t = e.duration || Math.abs((r - (o && "time"in o ? o.time : i._time)) / i.timeScale());
                            u._dur !== t && kt(u, t, 0, 1).render(u._time, !0, !0),
                            n = 1
                        }
                        a && a.apply(u, l || [])
                    }
                }, e));
                return c ? u.render(0) : u
            }
            ,
            s.tweenFromTo = function(t, e, n) {
                return this.tweenTo(e, mt({
                    startAt: {
                        time: Bt(this, t)
                    }
                }, n))
            }
            ,
            s.recent = function() {
                return this._recent
            }
            ,
            s.nextLabel = function(t) {
                return void 0 === t && (t = this._time),
                ee(this, Bt(this, t))
            }
            ,
            s.previousLabel = function(t) {
                return void 0 === t && (t = this._time),
                ee(this, Bt(this, t), 1)
            }
            ,
            s.currentLabel = function(t) {
                return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + x)
            }
            ,
            s.shiftChildren = function(t, e, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, s = this.labels; r; )
                    r._start >= n && (r._start += t,
                    r._end += t),
                    r = r._next;
                if (e)
                    for (i in s)
                        s[i] >= n && (s[i] += t);
                return wt(this)
            }
            ,
            s.invalidate = function() {
                var t = this._first;
                for (this._lock = 0; t; )
                    t.invalidate(),
                    t = t._next;
                return n.prototype.invalidate.call(this)
            }
            ,
            s.clear = function(t) {
                void 0 === t && (t = !0);
                for (var e, n = this._first; n; )
                    e = n._next,
                    this.remove(n),
                    n = e;
                return this._dp && (this._time = this._tTime = this._pTime = 0),
                t && (this.labels = {}),
                wt(this)
            }
            ,
            s.totalDuration = function(t) {
                var e, n, i, s = 0, o = this, a = o._last, l = y;
                if (arguments.length)
                    return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
                if (o._dirty) {
                    for (i = o.parent; a; )
                        e = a._prev,
                        a._dirty && a.totalDuration(),
                        (n = a._start) > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                        Pt(o, a, n - a._delay, 1)._lock = 0) : l = n,
                        n < 0 && a._ts && (s -= n,
                        (!i && !o._dp || i && i.smoothChildTiming) && (o._start += n / o._ts,
                        o._time -= n,
                        o._tTime -= n),
                        o.shiftChildren(-n, !1, -Infinity),
                        l = 0),
                        a._end > s && a._ts && (s = a._end),
                        a = e;
                    kt(o, o === r && o._time > s ? o._time : s, 1, 1),
                    o._dirty = 0
                }
                return o._tDur
            }
            ,
            i.updateRoot = function(t) {
                if (r._ts && (dt(r, At(t, r)),
                c = fe.frame),
                fe.frame >= et) {
                    et += g.autoSleep || 120;
                    var e = r._first;
                    if ((!e || !e._ts) && g.autoSleep && fe._listeners.length < 2) {
                        for (; e && !e._ts; )
                            e = e._next;
                        e || fe.sleep()
                    }
                }
            }
            ,
            i
        }(Ce);
        mt(Re.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var Le, Pe = function(t, e, n, i, r, s, o) {
            var a, l, c, u, h, d, p, f, m = new $e(this._pt,t,e,0,1,Xe,null,r), g = 0, v = 0;
            for (m.b = n,
            m.e = i,
            n += "",
            (p = ~(i += "").indexOf("random(")) && (i = $t(i)),
            s && (s(f = [n, i], t, e),
            n = f[0],
            i = f[1]),
            l = n.match(B) || []; a = B.exec(i); )
                u = a[0],
                h = i.substring(g, a.index),
                c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1),
                u !== l[v++] && (d = parseFloat(l[v - 1]) || 0,
                m._pt = {
                    _next: m._pt,
                    p: h || 1 === v ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0
                },
                g = B.lastIndex);
            return m.c = g < i.length ? i.substring(g, i.length) : "",
            m.fp = o,
            (F.test(i) || p) && (m.e = 0),
            this._pt = m,
            m
        }, De = function(t, e, n, i, r, s, o, a, l) {
            A(i) && (i = i(r || 0, t, s));
            var c, u = t[e], h = "get" !== n ? n : A(u) ? l ? t[e.indexOf("set") || !A(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u, d = A(u) ? l ? Ge : Ue : Fe;
            if (E(i) && (~i.indexOf("random(") && (i = $t(i)),
            "=" === i.charAt(1) && ((c = parseFloat(h) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Vt(h) || 0)) || 0 === c) && (i = c)),
            h !== i)
                return isNaN(h * i) || "" === i ? (!u && !(e in t) && q(e, i),
                Pe.call(this, t, e, h, i, d, a || g.stringFilter, l)) : (c = new $e(this._pt,t,e,+h || 0,i - (h || 0),"boolean" == typeof u ? qe : je,0,d),
                l && (c.fp = l),
                o && c.modifier(o, this, t),
                this._pt = c)
        }, Ie = function(t, e, n, i, r, s) {
            var o, a, l, c;
            if ($[t] && !1 !== (o = new $[t]).init(r, o.rawVars ? e[t] : function(t, e, n, i, r) {
                if (A(t) && (t = ke(t, r, e, n, i)),
                !L(t) || t.style && t.nodeType || N(t) || O(t))
                    return E(t) ? ke(t, r, e, n, i) : t;
                var s, o = {};
                for (s in t)
                    o[s] = ke(t[s], r, e, n, i);
                return o
            }(e[t], i, r, s, n), n, i, s) && (n._pt = a = new $e(n._pt,r,t,0,1,o.render,o,0,o.priority),
            n !== u))
                for (l = n._ptLookup[n._targets.indexOf(r)],
                c = o._props.length; c--; )
                    l[o._props[c]] = a;
            return o
        }, Oe = function t(e, n) {
            var s, o, a, l, c, u, h, d, p, f, m, g, _, b = e.vars, w = b.ease, M = b.startAt, S = b.immediateRender, T = b.lazy, E = b.onUpdate, A = b.onUpdateParams, C = b.callbackScope, R = b.runBackwards, L = b.yoyoEase, D = b.keyframes, I = b.autoRevert, O = e._dur, N = e._startAt, k = e._targets, z = e.parent, H = z && "nested" === z.data ? z.parent._targets : k, B = "auto" === e._overwrite && !i, F = e.timeline;
            if (F && (!D || !w) && (w = "none"),
            e._ease = we(w, v.ease),
            e._yEase = L ? _e(we(!0 === L ? w : L, v.ease)) : 0,
            L && e._yoyo && !e._repeat && (L = e._yEase,
            e._yEase = e._ease,
            e._ease = L),
            e._from = !F && !!b.runBackwards,
            !F || D && !b.stagger) {
                if (g = (d = k[0] ? st(k[0]).harness : 0) && b[d.prop],
                s = yt(b, Z),
                N && bt(N.render(-1, !0)),
                M)
                    if (bt(e._startAt = Be.set(k, mt({
                        data: "isStart",
                        overwrite: !1,
                        parent: z,
                        immediateRender: !0,
                        lazy: P(T),
                        startAt: null,
                        delay: 0,
                        onUpdate: E,
                        onUpdateParams: A,
                        callbackScope: C,
                        stagger: 0
                    }, M))),
                    n < 0 && !S && !I && e._startAt.render(-1, !0),
                    S) {
                        if (n > 0 && !I && (e._startAt = 0),
                        O && n <= 0)
                            return void (n && (e._zTime = n))
                    } else
                        !1 === I && (e._startAt = 0);
                else if (R && O)
                    if (N)
                        !I && (e._startAt = 0);
                    else if (n && (S = !1),
                    a = mt({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: S && P(T),
                        immediateRender: S,
                        stagger: 0,
                        parent: z
                    }, s),
                    g && (a[d.prop] = g),
                    bt(e._startAt = Be.set(k, a)),
                    n < 0 && e._startAt.render(-1, !0),
                    e._zTime = n,
                    S) {
                        if (!n)
                            return
                    } else
                        t(e._startAt, x);
                for (e._pt = 0,
                T = O && P(T) || T && !O,
                o = 0; o < k.length; o++) {
                    if (h = (c = k[o])._gsap || rt(k)[o]._gsap,
                    e._ptLookup[o] = f = {},
                    Q[h.id] && K.length && ht(),
                    m = H === k ? o : H.indexOf(c),
                    d && !1 !== (p = new d).init(c, g || s, e, m, H) && (e._pt = l = new $e(e._pt,c,p.name,0,1,p.render,p,0,p.priority),
                    p._props.forEach((function(t) {
                        f[t] = l
                    }
                    )),
                    p.priority && (u = 1)),
                    !d || g)
                        for (a in s)
                            $[a] && (p = Ie(a, s, e, m, c, H)) ? p.priority && (u = 1) : f[a] = l = De.call(e, c, a, "get", s[a], m, H, 0, b.stringFilter);
                    e._op && e._op[o] && e.kill(c, e._op[o]),
                    B && e._pt && (Le = e,
                    r.killTweensOf(c, f, e.globalTime(n)),
                    _ = !e.parent,
                    Le = 0),
                    e._pt && T && (Q[h.id] = 1)
                }
                u && Qe(e),
                e._onInit && e._onInit(e)
            }
            e._onUpdate = E,
            e._initted = (!e._op || e._pt) && !_,
            D && n <= 0 && F.render(y, !0, !0)
        }, Ne = function(t, e, n, i) {
            var r, s, o = e.ease || i || "power1.inOut";
            if (N(e))
                s = n[t] || (n[t] = []),
                e.forEach((function(t, n) {
                    return s.push({
                        t: n / (e.length - 1) * 100,
                        v: t,
                        e: o
                    })
                }
                ));
            else
                for (r in e)
                    s = n[r] || (n[r] = []),
                    "ease" === r || s.push({
                        t: parseFloat(t),
                        v: e[r],
                        e: o
                    })
        }, ke = function(t, e, n, i, r) {
            return A(t) ? t.call(e, n, i, r) : E(t) && ~t.indexOf("random(") ? $t(t) : t
        }, ze = it + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", He = {};
        at(ze + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
            return He[t] = 1
        }
        ));
        var Be = function(n) {
            function s(e, s, o, a) {
                var l;
                "number" == typeof s && (o.duration = s,
                s = o,
                o = null);
                var c, u, h, d, p, f, m, v, y = (l = n.call(this, a ? s : xt(s)) || this).vars, x = y.duration, _ = y.delay, b = y.immediateRender, w = y.stagger, M = y.overwrite, S = y.keyframes, T = y.defaults, E = y.scrollTrigger, A = y.yoyoEase, R = s.parent || r, D = (N(e) || O(e) ? C(e[0]) : "length"in s) ? [e] : qt(e);
                if (l._targets = D.length ? rt(D) : X("GSAP target " + e + " not found. https://greensock.com", !g.nullTargetWarn) || [],
                l._ptLookup = [],
                l._overwrite = M,
                S || w || I(x) || I(_)) {
                    if (s = l.vars,
                    (c = l.timeline = new Re({
                        data: "nested",
                        defaults: T || {}
                    })).kill(),
                    c.parent = c._dp = t(l),
                    c._start = 0,
                    w || I(x) || I(_)) {
                        if (d = D.length,
                        m = w && Yt(w),
                        L(w))
                            for (p in w)
                                ~ze.indexOf(p) && (v || (v = {}),
                                v[p] = w[p]);
                        for (u = 0; u < d; u++)
                            (h = yt(s, He)).stagger = 0,
                            A && (h.yoyoEase = A),
                            v && gt(h, v),
                            f = D[u],
                            h.duration = +ke(x, t(l), u, f, D),
                            h.delay = (+ke(_, t(l), u, f, D) || 0) - l._delay,
                            !w && 1 === d && h.delay && (l._delay = _ = h.delay,
                            l._start += _,
                            h.delay = 0),
                            c.to(f, h, m ? m(u, f, D) : 0),
                            c._ease = ge.none;
                        c.duration() ? x = _ = 0 : l.timeline = 0
                    } else if (S) {
                        xt(mt(c.vars.defaults, {
                            ease: "none"
                        })),
                        c._ease = we(S.ease || s.ease || "none");
                        var k, z, H, B = 0;
                        if (N(S))
                            S.forEach((function(t) {
                                return c.to(D, t, ">")
                            }
                            ));
                        else {
                            for (p in h = {},
                            S)
                                "ease" === p || "easeEach" === p || Ne(p, S[p], h, S.easeEach);
                            for (p in h)
                                for (k = h[p].sort((function(t, e) {
                                    return t.t - e.t
                                }
                                )),
                                B = 0,
                                u = 0; u < k.length; u++)
                                    (H = {
                                        ease: (z = k[u]).e,
                                        duration: (z.t - (u ? k[u - 1].t : 0)) / 100 * x
                                    })[p] = z.v,
                                    c.to(D, H, B),
                                    B += H.duration;
                            c.duration() < x && c.to({}, {
                                duration: x - c.duration()
                            })
                        }
                    }
                    x || l.duration(x = c.duration())
                } else
                    l.timeline = 0;
                return !0 !== M || i || (Le = t(l),
                r.killTweensOf(D),
                Le = 0),
                Pt(R, t(l), o),
                s.reversed && l.reverse(),
                s.paused && l.paused(!0),
                (b || !x && !S && l._start === ct(R._time) && P(b) && St(t(l)) && "nested" !== R.data) && (l._tTime = -1e-8,
                l.render(Math.max(0, -_))),
                E && Dt(t(l), E),
                l
            }
            e(s, n);
            var o = s.prototype;
            return o.render = function(t, e, n) {
                var i, r, s, o, a, l, c, u, h, d = this._time, p = this._tDur, f = this._dur, m = t > p - x && t >= 0 ? p : t < x ? 0 : t;
                if (f) {
                    if (m !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                        if (i = m,
                        u = this.timeline,
                        this._repeat) {
                            if (o = f + this._rDelay,
                            this._repeat < -1 && t < 0)
                                return this.totalTime(100 * o + t, e, n);
                            if (i = ct(m % o),
                            m === p ? (s = this._repeat,
                            i = f) : ((s = ~~(m / o)) && s === m / o && (i = f,
                            s--),
                            i > f && (i = f)),
                            (l = this._yoyo && 1 & s) && (h = this._yEase,
                            i = f - i),
                            a = Et(this._tTime, o),
                            i === d && !n && this._initted)
                                return this;
                            s !== a && (u && this._yEase && be(u, l),
                            !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1,
                            this.render(ct(o * s), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (It(this, t < 0 ? t : i, n, e))
                                return this._tTime = 0,
                                this;
                            if (f !== this._dur)
                                return this.render(t, e, n)
                        }
                        if (this._tTime = m,
                        this._time = i,
                        !this._act && this._ts && (this._act = 1,
                        this._lazy = 0),
                        this.ratio = c = (h || this._ease)(i / f),
                        this._from && (this.ratio = c = 1 - c),
                        i && !d && !e && (ne(this, "onStart"),
                        this._tTime !== m))
                            return this;
                        for (r = this._pt; r; )
                            r.r(c, r.d),
                            r = r._next;
                        u && u.render(t < 0 ? t : !i && l ? -1e-8 : u._dur * u._ease(i / this._dur), e, n) || this._startAt && (this._zTime = t),
                        this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n),
                        ne(this, "onUpdate")),
                        this._repeat && s !== a && this.vars.onRepeat && !e && this.parent && ne(this, "onRepeat"),
                        m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0),
                        (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && bt(this, 1),
                        e || t < 0 && !d || !m && !d || (ne(this, m === p ? "onComplete" : "onReverseComplete", !0),
                        this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                    }
                } else
                    !function(t, e, n, i) {
                        var r, s, o, a = t.ratio, l = e < 0 || !e && (!t._start && Ot(t) && (t._initted || !Nt(t)) || (t._ts < 0 || t._dp._ts < 0) && !Nt(t)) ? 0 : 1, c = t._rDelay, u = 0;
                        if (c && t._repeat && (u = Gt(0, t._tDur, e),
                        s = Et(u, c),
                        t._yoyo && 1 & s && (l = 1 - l),
                        s !== Et(t._tTime, c) && (a = 1 - l,
                        t.vars.repeatRefresh && t._initted && t.invalidate())),
                        l !== a || i || t._zTime === x || !e && t._zTime) {
                            if (!t._initted && It(t, e, i, n))
                                return;
                            for (o = t._zTime,
                            t._zTime = e || (n ? x : 0),
                            n || (n = e && !o),
                            t.ratio = l,
                            t._from && (l = 1 - l),
                            t._time = 0,
                            t._tTime = u,
                            r = t._pt; r; )
                                r.r(l, r.d),
                                r = r._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0),
                            t._onUpdate && !n && ne(t, "onUpdate"),
                            u && t._repeat && !n && t.parent && ne(t, "onRepeat"),
                            (e >= t._tDur || e < 0) && t.ratio === l && (l && bt(t, 1),
                            n || (ne(t, l ? "onComplete" : "onReverseComplete", !0),
                            t._prom && t._prom()))
                        } else
                            t._zTime || (t._zTime = e)
                    }(this, t, e, n);
                return this
            }
            ,
            o.targets = function() {
                return this._targets
            }
            ,
            o.invalidate = function() {
                return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0,
                this._ptLookup = [],
                this.timeline && this.timeline.invalidate(),
                n.prototype.invalidate.call(this)
            }
            ,
            o.kill = function(t, e) {
                if (void 0 === e && (e = "all"),
                !(t || e && "all" !== e))
                    return this._lazy = this._pt = 0,
                    this.parent ? ie(this) : this;
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(t, e, Le && !0 !== Le.vars.overwrite)._first || ie(this),
                    this.parent && n !== this.timeline.totalDuration() && kt(this, this._dur * this.timeline._tDur / n, 0, 1),
                    this
                }
                var i, r, s, o, a, l, c, u = this._targets, h = t ? qt(t) : u, d = this._ptLookup, p = this._pt;
                if ((!e || "all" === e) && function(t, e) {
                    for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n]; )
                        ;
                    return n < 0
                }(u, h))
                    return "all" === e && (this._pt = 0),
                    ie(this);
                for (i = this._op = this._op || [],
                "all" !== e && (E(e) && (a = {},
                at(e, (function(t) {
                    return a[t] = 1
                }
                )),
                e = a),
                e = function(t, e) {
                    var n, i, r, s, o = t[0] ? st(t[0]).harness : 0, a = o && o.aliases;
                    if (!a)
                        return e;
                    for (i in n = gt({}, e),
                    a)
                        if (i in n)
                            for (r = (s = a[i].split(",")).length; r--; )
                                n[s[r]] = n[i];
                    return n
                }(u, e)),
                c = u.length; c--; )
                    if (~h.indexOf(u[c]))
                        for (a in r = d[c],
                        "all" === e ? (i[c] = e,
                        o = r,
                        s = {}) : (s = i[c] = i[c] || {},
                        o = e),
                        o)
                            (l = r && r[a]) && ("kill"in l.d && !0 !== l.d.kill(a) || _t(this, l, "_pt"),
                            delete r[a]),
                            "all" !== s && (s[a] = 1);
                return this._initted && !this._pt && p && ie(this),
                this
            }
            ,
            s.to = function(t, e) {
                return new s(t,e,arguments[2])
            }
            ,
            s.from = function(t, e) {
                return Ft(1, arguments)
            }
            ,
            s.delayedCall = function(t, e, n, i) {
                return new s(e,0,{
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: t,
                    onComplete: e,
                    onReverseComplete: e,
                    onCompleteParams: n,
                    onReverseCompleteParams: n,
                    callbackScope: i
                })
            }
            ,
            s.fromTo = function(t, e, n) {
                return Ft(2, arguments)
            }
            ,
            s.set = function(t, e) {
                return e.duration = 0,
                e.repeatDelay || (e.repeat = 0),
                new s(t,e)
            }
            ,
            s.killTweensOf = function(t, e, n) {
                return r.killTweensOf(t, e, n)
            }
            ,
            s
        }(Ce);
        mt(Be.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }),
        at("staggerTo,staggerFrom,staggerFromTo", (function(t) {
            Be[t] = function() {
                var e = new Re
                  , n = Wt.call(arguments, 0);
                return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
                e[t].apply(e, n)
            }
        }
        ));
        var Fe = function(t, e, n) {
            return t[e] = n
        }
          , Ue = function(t, e, n) {
            return t[e](n)
        }
          , Ge = function(t, e, n, i) {
            return t[e](i.fp, n)
        }
          , Ve = function(t, e, n) {
            return t.setAttribute(e, n)
        }
          , We = function(t, e) {
            return A(t[e]) ? Ue : R(t[e]) && t.setAttribute ? Ve : Fe
        }
          , je = function(t, e) {
            return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
        }
          , qe = function(t, e) {
            return e.set(e.t, e.p, !!(e.s + e.c * t), e)
        }
          , Xe = function(t, e) {
            var n = e._pt
              , i = "";
            if (!t && e.b)
                i = e.b;
            else if (1 === t && e.e)
                i = e.e;
            else {
                for (; n; )
                    i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i,
                    n = n._next;
                i += e.c
            }
            e.set(e.t, e.p, i, e)
        }
          , Ye = function(t, e) {
            for (var n = e._pt; n; )
                n.r(t, n.d),
                n = n._next
        }
          , Je = function(t, e, n, i) {
            for (var r, s = this._pt; s; )
                r = s._next,
                s.p === i && s.modifier(t, e, n),
                s = r
        }
          , Ze = function(t) {
            for (var e, n, i = this._pt; i; )
                n = i._next,
                i.p === t && !i.op || i.op === t ? _t(this, i, "_pt") : i.dep || (e = 1),
                i = n;
            return !e
        }
          , Ke = function(t, e, n, i) {
            i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
        }
          , Qe = function(t) {
            for (var e, n, i, r, s = t._pt; s; ) {
                for (e = s._next,
                n = i; n && n.pr > s.pr; )
                    n = n._next;
                (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s,
                (s._next = n) ? n._prev = s : r = s,
                s = e
            }
            t._pt = i
        }
          , $e = function() {
            function t(t, e, n, i, r, s, o, a, l) {
                this.t = e,
                this.s = i,
                this.c = r,
                this.p = n,
                this.r = s || je,
                this.d = o || this,
                this.set = a || Fe,
                this.pr = l || 0,
                this._next = t,
                t && (t._prev = this)
            }
            return t.prototype.modifier = function(t, e, n) {
                this.mSet = this.mSet || this.set,
                this.set = Ke,
                this.m = t,
                this.mt = n,
                this.tween = e
            }
            ,
            t
        }();
        at(it + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
            return Z[t] = 1
        }
        )),
        V.TweenMax = V.TweenLite = Be,
        V.TimelineLite = V.TimelineMax = Re,
        r = new Re({
            sortChildren: !1,
            defaults: v,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }),
        g.stringFilter = pe;
        var tn = {
            registerPlugin: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                e.forEach((function(t) {
                    return re(t)
                }
                ))
            },
            timeline: function(t) {
                return new Re(t)
            },
            getTweensOf: function(t, e) {
                return r.getTweensOf(t, e)
            },
            getProperty: function(t, e, n, i) {
                E(t) && (t = qt(t)[0]);
                var r = st(t || {}).get
                  , s = n ? ft : pt;
                return "native" === n && (n = ""),
                t ? e ? s(($[e] && $[e].get || r)(t, e, n, i)) : function(e, n, i) {
                    return s(($[e] && $[e].get || r)(t, e, n, i))
                }
                : t
            },
            quickSetter: function(t, e, n) {
                if ((t = qt(t)).length > 1) {
                    var i = t.map((function(t) {
                        return rn.quickSetter(t, e, n)
                    }
                    ))
                      , r = i.length;
                    return function(t) {
                        for (var e = r; e--; )
                            i[e](t)
                    }
                }
                t = t[0] || {};
                var s = $[e]
                  , o = st(t)
                  , a = o.harness && (o.harness.aliases || {})[e] || e
                  , l = s ? function(e) {
                    var i = new s;
                    u._pt = 0,
                    i.init(t, n ? e + n : e, u, 0, [t]),
                    i.render(1, i),
                    u._pt && Ye(1, u)
                }
                : o.set(t, a);
                return s ? l : function(e) {
                    return l(t, a, n ? e + n : e, o, 1)
                }
            },
            isTweening: function(t) {
                return r.getTweensOf(t, !0).length > 0
            },
            defaults: function(t) {
                return t && t.ease && (t.ease = we(t.ease, v.ease)),
                vt(v, t || {})
            },
            config: function(t) {
                return vt(g, t || {})
            },
            registerEffect: function(t) {
                var e = t.name
                  , n = t.effect
                  , i = t.plugins
                  , r = t.defaults
                  , s = t.extendTimeline;
                (i || "").split(",").forEach((function(t) {
                    return t && !$[t] && !V[t] && X(e + " effect requires " + t + " plugin.")
                }
                )),
                tt[e] = function(t, e, i) {
                    return n(qt(t), mt(e || {}, r), i)
                }
                ,
                s && (Re.prototype[e] = function(t, n, i) {
                    return this.add(tt[e](t, L(n) ? n : (i = n) && {}, this), i)
                }
                )
            },
            registerEase: function(t, e) {
                ge[t] = we(e)
            },
            parseEase: function(t, e) {
                return arguments.length ? we(t, e) : ge
            },
            getById: function(t) {
                return r.getById(t)
            },
            exportRoot: function(t, e) {
                void 0 === t && (t = {});
                var n, i, s = new Re(t);
                for (s.smoothChildTiming = P(t.smoothChildTiming),
                r.remove(s),
                s._dp = 0,
                s._time = s._tTime = r._time,
                n = r._first; n; )
                    i = n._next,
                    !e && !n._dur && n instanceof Be && n.vars.onComplete === n._targets[0] || Pt(s, n, n._start - n._delay),
                    n = i;
                return Pt(r, s, 0),
                s
            },
            utils: {
                wrap: function t(e, n, i) {
                    var r = n - e;
                    return N(e) ? Qt(e, t(0, e.length), n) : Ut(i, (function(t) {
                        return (r + (t - e) % r) % r + e
                    }
                    ))
                },
                wrapYoyo: function t(e, n, i) {
                    var r = n - e
                      , s = 2 * r;
                    return N(e) ? Qt(e, t(0, e.length - 1), n) : Ut(i, (function(t) {
                        return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                    }
                    ))
                },
                distribute: Yt,
                random: Kt,
                snap: Zt,
                normalize: function(t, e, n) {
                    return te(t, e, 0, 1, n)
                },
                getUnit: Vt,
                clamp: function(t, e, n) {
                    return Ut(n, (function(n) {
                        return Gt(t, e, n)
                    }
                    ))
                },
                splitColor: le,
                toArray: qt,
                selector: function(t) {
                    return t = qt(t)[0] || X("Invalid scope") || {},
                    function(e) {
                        var n = t.current || t.nativeElement || t;
                        return qt(e, n.querySelectorAll ? n : n === t ? X("Invalid scope") || a.createElement("div") : t)
                    }
                },
                mapRange: te,
                pipe: function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                        e[n] = arguments[n];
                    return function(t) {
                        return e.reduce((function(t, e) {
                            return e(t)
                        }
                        ), t)
                    }
                },
                unitize: function(t, e) {
                    return function(n) {
                        return t(parseFloat(n)) + (e || Vt(n))
                    }
                },
                interpolate: function t(e, n, i, r) {
                    var s = isNaN(e + n) ? 0 : function(t) {
                        return (1 - t) * e + t * n
                    }
                    ;
                    if (!s) {
                        var o, a, l, c, u, h = E(e), d = {};
                        if (!0 === i && (r = 1) && (i = null),
                        h)
                            e = {
                                p: e
                            },
                            n = {
                                p: n
                            };
                        else if (N(e) && !N(n)) {
                            for (l = [],
                            c = e.length,
                            u = c - 2,
                            a = 1; a < c; a++)
                                l.push(t(e[a - 1], e[a]));
                            c--,
                            s = function(t) {
                                t *= c;
                                var e = Math.min(u, ~~t);
                                return l[e](t - e)
                            }
                            ,
                            i = n
                        } else
                            r || (e = gt(N(e) ? [] : {}, e));
                        if (!l) {
                            for (o in n)
                                De.call(d, e, o, "get", n[o]);
                            s = function(t) {
                                return Ye(t, d) || (h ? e.p : e)
                            }
                        }
                    }
                    return Ut(i, s)
                },
                shuffle: Xt
            },
            install: j,
            effects: tt,
            ticker: fe,
            updateRoot: Re.updateRoot,
            plugins: $,
            globalTimeline: r,
            core: {
                PropTween: $e,
                globals: Y,
                Tween: Be,
                Timeline: Re,
                Animation: Ce,
                getCache: st,
                _removeLinkedListItem: _t,
                suppressOverwrites: function(t) {
                    return i = t
                }
            }
        };
        at("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
            return tn[t] = Be[t]
        }
        )),
        fe.add(Re.updateRoot),
        u = tn.to({}, {
            duration: 0
        });
        var en = function(t, e) {
            for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
                n = n._next;
            return n
        }
          , nn = function(t, e) {
            return {
                name: t,
                rawVars: 1,
                init: function(t, n, i) {
                    i._onInit = function(t) {
                        var i, r;
                        if (E(n) && (i = {},
                        at(n, (function(t) {
                            return i[t] = 1
                        }
                        )),
                        n = i),
                        e) {
                            for (r in i = {},
                            n)
                                i[r] = e(n[r]);
                            n = i
                        }
                        !function(t, e) {
                            var n, i, r, s = t._targets;
                            for (n in e)
                                for (i = s.length; i--; )
                                    (r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = en(r, n)),
                                    r && r.modifier && r.modifier(e[n], t, s[i], n))
                        }(t, n)
                    }
                }
            }
        }
          , rn = tn.registerPlugin({
            name: "attr",
            init: function(t, e, n, i, r) {
                var s, o;
                for (s in e)
                    (o = this.add(t, "setAttribute", (t.getAttribute(s) || 0) + "", e[s], i, r, 0, 0, s)) && (o.op = s),
                    this._props.push(s)
            }
        }, {
            name: "endArray",
            init: function(t, e) {
                for (var n = e.length; n--; )
                    this.add(t, n, t[n] || 0, e[n])
            }
        }, nn("roundProps", Jt), nn("modifiers"), nn("snap", Zt)) || tn;
        Be.version = Re.version = rn.version = "3.9.1",
        l = 1,
        D() && me(),
        ge.Power0,
        ge.Power1,
        ge.Power2,
        ge.Power3,
        ge.Power4,
        ge.Linear,
        ge.Quad,
        ge.Cubic,
        ge.Quart,
        ge.Quint,
        ge.Strong,
        ge.Elastic,
        ge.Back,
        ge.SteppedEase,
        ge.Bounce,
        ge.Sine,
        ge.Expo,
        ge.Circ;
        var sn, on, an, ln, cn, un, hn, dn = {}, pn = 180 / Math.PI, fn = Math.PI / 180, mn = Math.atan2, gn = /([A-Z])/g, vn = /(?:left|right|width|margin|padding|x)/i, yn = /[\s,\(]\S/, xn = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        }, _n = function(t, e) {
            return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }, bn = function(t, e) {
            return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
        }, wn = function(t, e) {
            return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
        }, Mn = function(t, e) {
            var n = e.s + e.c * t;
            e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
        }, Sn = function(t, e) {
            return e.set(e.t, e.p, t ? e.e : e.b, e)
        }, Tn = function(t, e) {
            return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
        }, En = function(t, e, n) {
            return t.style[e] = n
        }, An = function(t, e, n) {
            return t.style.setProperty(e, n)
        }, Cn = function(t, e, n) {
            return t._gsap[e] = n
        }, Rn = function(t, e, n) {
            return t._gsap.scaleX = t._gsap.scaleY = n
        }, Ln = function(t, e, n, i, r) {
            var s = t._gsap;
            s.scaleX = s.scaleY = n,
            s.renderTransform(r, s)
        }, Pn = function(t, e, n, i, r) {
            var s = t._gsap;
            s[e] = n,
            s.renderTransform(r, s)
        }, Dn = "transform", In = Dn + "Origin", On = function(t, e) {
            var n = on.createElementNS ? on.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : on.createElement(t);
            return n.style ? n : on.createElement(t)
        }, Nn = function t(e, n, i) {
            var r = getComputedStyle(e);
            return r[n] || r.getPropertyValue(n.replace(gn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, zn(n) || n, 1) || ""
        }, kn = "O,Moz,ms,Ms,Webkit".split(","), zn = function(t, e, n) {
            var i = (e || cn).style
              , r = 5;
            if (t in i && !n)
                return t;
            for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(kn[r] + t in i); )
                ;
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? kn[r] : "") + t
        }, Hn = function() {
            "undefined" != typeof window && window.document && (sn = window,
            on = sn.document,
            an = on.documentElement,
            cn = On("div") || {
                style: {}
            },
            On("div"),
            Dn = zn(Dn),
            In = Dn + "Origin",
            cn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
            hn = !!zn("perspective"),
            ln = 1)
        }, Bn = function t(e) {
            var n, i = On("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, o = this.style.cssText;
            if (an.appendChild(i),
            i.appendChild(this),
            this.style.display = "block",
            e)
                try {
                    n = this.getBBox(),
                    this._gsapBBox = this.getBBox,
                    this.getBBox = t
                } catch (t) {}
            else
                this._gsapBBox && (n = this._gsapBBox());
            return r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            an.removeChild(i),
            this.style.cssText = o,
            n
        }, Fn = function(t, e) {
            for (var n = e.length; n--; )
                if (t.hasAttribute(e[n]))
                    return t.getAttribute(e[n])
        }, Un = function(t) {
            var e;
            try {
                e = t.getBBox()
            } catch (n) {
                e = Bn.call(t, !0)
            }
            return e && (e.width || e.height) || t.getBBox === Bn || (e = Bn.call(t, !0)),
            !e || e.width || e.x || e.y ? e : {
                x: +Fn(t, ["x", "cx", "x1"]) || 0,
                y: +Fn(t, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        }, Gn = function(t) {
            return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Un(t))
        }, Vn = function(t, e) {
            if (e) {
                var n = t.style;
                e in dn && e !== In && (e = Dn),
                n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
                n.removeProperty(e.replace(gn, "-$1").toLowerCase())) : n.removeAttribute(e)
            }
        }, Wn = function(t, e, n, i, r, s) {
            var o = new $e(t._pt,e,n,0,1,s ? Tn : Sn);
            return t._pt = o,
            o.b = i,
            o.e = r,
            t._props.push(n),
            o
        }, jn = {
            deg: 1,
            rad: 1,
            turn: 1
        }, qn = function t(e, n, i, r) {
            var s, o, a, l, c = parseFloat(i) || 0, u = (i + "").trim().substr((c + "").length) || "px", h = cn.style, d = vn.test(n), p = "svg" === e.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
            return r === u || !c || jn[r] || jn[u] ? c : ("px" !== u && !g && (c = t(e, n, i, "px")),
            l = e.getCTM && Gn(e),
            !v && "%" !== u || !dn[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : r),
            o = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode,
            l && (o = (e.ownerSVGElement || {}).parentNode),
            o && o !== on && o.appendChild || (o = on.body),
            (a = o._gsap) && v && a.width && d && a.time === fe.time ? lt(c / a.width * m) : ((v || "%" === u) && (h.position = Nn(e, "position")),
            o === e && (h.position = "static"),
            o.appendChild(cn),
            s = cn[f],
            o.removeChild(cn),
            h.position = "absolute",
            d && v && ((a = st(o)).time = fe.time,
            a.width = o[f]),
            lt(g ? s * c / m : s && c ? m / s * c : 0))) : (s = l ? e.getBBox()[d ? "width" : "height"] : e[f],
            lt(v ? c / s * m : c / 100 * s)))
        }, Xn = function(t, e, n, i) {
            var r;
            return ln || Hn(),
            e in xn && "transform" !== e && ~(e = xn[e]).indexOf(",") && (e = e.split(",")[0]),
            dn[e] && "transform" !== e ? (r = ri(t, i),
            r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : si(Nn(t, In)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Kn[e] && Kn[e](t, e, n) || Nn(t, e) || ot(t, e) || ("opacity" === e ? 1 : 0)),
            n && !~(r + "").trim().indexOf(" ") ? qn(t, e, r, n) + n : r
        }, Yn = function(t, e, n, i) {
            if (!n || "none" === n) {
                var r = zn(e, t, 1)
                  , s = r && Nn(t, r, 1);
                s && s !== n ? (e = r,
                n = s) : "borderColor" === e && (n = Nn(t, "borderTopColor"))
            }
            var o, a, l, c, u, h, d, p, f, m, v, y, x = new $e(this._pt,t.style,e,0,1,Xe), _ = 0, b = 0;
            if (x.b = n,
            x.e = i,
            n += "",
            "auto" == (i += "") && (t.style[e] = i,
            i = Nn(t, e) || i,
            t.style[e] = n),
            pe(o = [n, i]),
            i = o[1],
            l = (n = o[0]).match(H) || [],
            (i.match(H) || []).length) {
                for (; a = H.exec(i); )
                    d = a[0],
                    f = i.substring(_, a.index),
                    u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1),
                    d !== (h = l[b++] || "") && (c = parseFloat(h) || 0,
                    v = h.substr((c + "").length),
                    (y = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)),
                    p = parseFloat(d),
                    m = d.substr((p + "").length),
                    _ = H.lastIndex - m.length,
                    m || (m = m || g.units[e] || v,
                    _ === i.length && (i += m,
                    x.e += m)),
                    v !== m && (c = qn(t, e, h, m) || 0),
                    x._pt = {
                        _next: x._pt,
                        p: f || 1 === b ? f : ",",
                        s: c,
                        c: y ? y * p : p - c,
                        m: u && u < 4 || "zIndex" === e ? Math.round : 0
                    });
                x.c = _ < i.length ? i.substring(_, i.length) : ""
            } else
                x.r = "display" === e && "none" === i ? Tn : Sn;
            return F.test(i) && (x.e = 0),
            this._pt = x,
            x
        }, Jn = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        }, Zn = function(t, e) {
            if (e.tween && e.tween._time === e.tween._dur) {
                var n, i, r, s = e.t, o = s.style, a = e.u, l = s._gsap;
                if ("all" === a || !0 === a)
                    o.cssText = "",
                    i = 1;
                else
                    for (r = (a = a.split(",")).length; --r > -1; )
                        n = a[r],
                        dn[n] && (i = 1,
                        n = "transformOrigin" === n ? In : Dn),
                        Vn(s, n);
                i && (Vn(s, Dn),
                l && (l.svg && s.removeAttribute("transform"),
                ri(s, 1),
                l.uncache = 1))
            }
        }, Kn = {
            clearProps: function(t, e, n, i, r) {
                if ("isFromStart" !== r.data) {
                    var s = t._pt = new $e(t._pt,e,n,0,0,Zn);
                    return s.u = i,
                    s.pr = -10,
                    s.tween = r,
                    t._props.push(n),
                    1
                }
            }
        }, Qn = [1, 0, 0, 1, 0, 0], $n = {}, ti = function(t) {
            return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
        }, ei = function(t) {
            var e = Nn(t, Dn);
            return ti(e) ? Qn : e.substr(7).match(z).map(lt)
        }, ni = function(t, e) {
            var n, i, r, s, o = t._gsap || st(t), a = t.style, l = ei(t);
            return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Qn : l : (l !== Qn || t.offsetParent || t === an || o.svg || (r = a.display,
            a.display = "block",
            (n = t.parentNode) && t.offsetParent || (s = 1,
            i = t.nextSibling,
            an.appendChild(t)),
            l = ei(t),
            r ? a.display = r : Vn(t, "display"),
            s && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : an.removeChild(t))),
            e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        }, ii = function(t, e, n, i, r, s) {
            var o, a, l, c = t._gsap, u = r || ni(t, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = u[0], g = u[1], v = u[2], y = u[3], x = u[4], _ = u[5], b = e.split(" "), w = parseFloat(b[0]) || 0, M = parseFloat(b[1]) || 0;
            n ? u !== Qn && (a = m * y - g * v) && (l = w * (-g / a) + M * (m / a) - (m * _ - g * x) / a,
            w = w * (y / a) + M * (-v / a) + (v * _ - y * x) / a,
            M = l) : (w = (o = Un(t)).x + (~b[0].indexOf("%") ? w / 100 * o.width : w),
            M = o.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * o.height : M)),
            i || !1 !== i && c.smooth ? (x = w - h,
            _ = M - d,
            c.xOffset = p + (x * m + _ * v) - x,
            c.yOffset = f + (x * g + _ * y) - _) : c.xOffset = c.yOffset = 0,
            c.xOrigin = w,
            c.yOrigin = M,
            c.smooth = !!i,
            c.origin = e,
            c.originIsAbsolute = !!n,
            t.style[In] = "0px 0px",
            s && (Wn(s, c, "xOrigin", h, w),
            Wn(s, c, "yOrigin", d, M),
            Wn(s, c, "xOffset", p, c.xOffset),
            Wn(s, c, "yOffset", f, c.yOffset)),
            t.setAttribute("data-svg-origin", w + " " + M)
        }, ri = function(t, e) {
            var n = t._gsap || new Ae(t);
            if ("x"in n && !e && !n.uncache)
                return n;
            var i, r, s, o, a, l, c, u, h, d, p, f, m, v, y, x, _, b, w, M, S, T, E, A, C, R, L, P, D, I, O, N, k = t.style, z = n.scaleX < 0, H = "px", B = "deg", F = Nn(t, In) || "0";
            return i = r = s = l = c = u = h = d = p = 0,
            o = a = 1,
            n.svg = !(!t.getCTM || !Gn(t)),
            v = ni(t, n.svg),
            n.svg && (A = (!n.uncache || "0px 0px" === F) && !e && t.getAttribute("data-svg-origin"),
            ii(t, A || F, !!A || n.originIsAbsolute, !1 !== n.smooth, v)),
            f = n.xOrigin || 0,
            m = n.yOrigin || 0,
            v !== Qn && (b = v[0],
            w = v[1],
            M = v[2],
            S = v[3],
            i = T = v[4],
            r = E = v[5],
            6 === v.length ? (o = Math.sqrt(b * b + w * w),
            a = Math.sqrt(S * S + M * M),
            l = b || w ? mn(w, b) * pn : 0,
            (h = M || S ? mn(M, S) * pn + l : 0) && (a *= Math.abs(Math.cos(h * fn))),
            n.svg && (i -= f - (f * b + m * M),
            r -= m - (f * w + m * S))) : (N = v[6],
            I = v[7],
            L = v[8],
            P = v[9],
            D = v[10],
            O = v[11],
            i = v[12],
            r = v[13],
            s = v[14],
            c = (y = mn(N, D)) * pn,
            y && (A = T * (x = Math.cos(-y)) + L * (_ = Math.sin(-y)),
            C = E * x + P * _,
            R = N * x + D * _,
            L = T * -_ + L * x,
            P = E * -_ + P * x,
            D = N * -_ + D * x,
            O = I * -_ + O * x,
            T = A,
            E = C,
            N = R),
            u = (y = mn(-M, D)) * pn,
            y && (x = Math.cos(-y),
            O = S * (_ = Math.sin(-y)) + O * x,
            b = A = b * x - L * _,
            w = C = w * x - P * _,
            M = R = M * x - D * _),
            l = (y = mn(w, b)) * pn,
            y && (A = b * (x = Math.cos(y)) + w * (_ = Math.sin(y)),
            C = T * x + E * _,
            w = w * x - b * _,
            E = E * x - T * _,
            b = A,
            T = C),
            c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
            u = 180 - u),
            o = lt(Math.sqrt(b * b + w * w + M * M)),
            a = lt(Math.sqrt(E * E + N * N)),
            y = mn(T, E),
            h = Math.abs(y) > 2e-4 ? y * pn : 0,
            p = O ? 1 / (O < 0 ? -O : O) : 0),
            n.svg && (A = t.getAttribute("transform"),
            n.forceCSS = t.setAttribute("transform", "") || !ti(Nn(t, Dn)),
            A && t.setAttribute("transform", A))),
            Math.abs(h) > 90 && Math.abs(h) < 270 && (z ? (o *= -1,
            h += l <= 0 ? 180 : -180,
            l += l <= 0 ? 180 : -180) : (a *= -1,
            h += h <= 0 ? 180 : -180)),
            n.x = i - ((n.xPercent = i && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + H,
            n.y = r - ((n.yPercent = r && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + H,
            n.z = s + H,
            n.scaleX = lt(o),
            n.scaleY = lt(a),
            n.rotation = lt(l) + B,
            n.rotationX = lt(c) + B,
            n.rotationY = lt(u) + B,
            n.skewX = h + B,
            n.skewY = d + B,
            n.transformPerspective = p + H,
            (n.zOrigin = parseFloat(F.split(" ")[2]) || 0) && (k[In] = si(F)),
            n.xOffset = n.yOffset = 0,
            n.force3D = g.force3D,
            n.renderTransform = n.svg ? di : hn ? hi : ai,
            n.uncache = 0,
            n
        }, si = function(t) {
            return (t = t.split(" "))[0] + " " + t[1]
        }, oi = function(t, e, n) {
            var i = Vt(e);
            return lt(parseFloat(e) + parseFloat(qn(t, "x", n + "px", i))) + i
        }, ai = function(t, e) {
            e.z = "0px",
            e.rotationY = e.rotationX = "0deg",
            e.force3D = 0,
            hi(t, e)
        }, li = "0deg", ci = "0px", ui = ") ", hi = function(t, e) {
            var n = e || this
              , i = n.xPercent
              , r = n.yPercent
              , s = n.x
              , o = n.y
              , a = n.z
              , l = n.rotation
              , c = n.rotationY
              , u = n.rotationX
              , h = n.skewX
              , d = n.skewY
              , p = n.scaleX
              , f = n.scaleY
              , m = n.transformPerspective
              , g = n.force3D
              , v = n.target
              , y = n.zOrigin
              , x = ""
              , _ = "auto" === g && t && 1 !== t || !0 === g;
            if (y && (u !== li || c !== li)) {
                var b, w = parseFloat(c) * fn, M = Math.sin(w), S = Math.cos(w);
                w = parseFloat(u) * fn,
                b = Math.cos(w),
                s = oi(v, s, M * b * -y),
                o = oi(v, o, -Math.sin(w) * -y),
                a = oi(v, a, S * b * -y + y)
            }
            m !== ci && (x += "perspective(" + m + ui),
            (i || r) && (x += "translate(" + i + "%, " + r + "%) "),
            (_ || s !== ci || o !== ci || a !== ci) && (x += a !== ci || _ ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + ui),
            l !== li && (x += "rotate(" + l + ui),
            c !== li && (x += "rotateY(" + c + ui),
            u !== li && (x += "rotateX(" + u + ui),
            h === li && d === li || (x += "skew(" + h + ", " + d + ui),
            1 === p && 1 === f || (x += "scale(" + p + ", " + f + ui),
            v.style[Dn] = x || "translate(0, 0)"
        }, di = function(t, e) {
            var n, i, r, s, o, a = e || this, l = a.xPercent, c = a.yPercent, u = a.x, h = a.y, d = a.rotation, p = a.skewX, f = a.skewY, m = a.scaleX, g = a.scaleY, v = a.target, y = a.xOrigin, x = a.yOrigin, _ = a.xOffset, b = a.yOffset, w = a.forceCSS, M = parseFloat(u), S = parseFloat(h);
            d = parseFloat(d),
            p = parseFloat(p),
            (f = parseFloat(f)) && (p += f = parseFloat(f),
            d += f),
            d || p ? (d *= fn,
            p *= fn,
            n = Math.cos(d) * m,
            i = Math.sin(d) * m,
            r = Math.sin(d - p) * -g,
            s = Math.cos(d - p) * g,
            p && (f *= fn,
            o = Math.tan(p - f),
            r *= o = Math.sqrt(1 + o * o),
            s *= o,
            f && (o = Math.tan(f),
            n *= o = Math.sqrt(1 + o * o),
            i *= o)),
            n = lt(n),
            i = lt(i),
            r = lt(r),
            s = lt(s)) : (n = m,
            s = g,
            i = r = 0),
            (M && !~(u + "").indexOf("px") || S && !~(h + "").indexOf("px")) && (M = qn(v, "x", u, "px"),
            S = qn(v, "y", h, "px")),
            (y || x || _ || b) && (M = lt(M + y - (y * n + x * r) + _),
            S = lt(S + x - (y * i + x * s) + b)),
            (l || c) && (o = v.getBBox(),
            M = lt(M + l / 100 * o.width),
            S = lt(S + c / 100 * o.height)),
            o = "matrix(" + n + "," + i + "," + r + "," + s + "," + M + "," + S + ")",
            v.setAttribute("transform", o),
            w && (v.style[Dn] = o)
        }, pi = function(t, e, n, i, r, s) {
            var o, a, l = 360, c = E(r), u = parseFloat(r) * (c && ~r.indexOf("rad") ? pn : 1), h = s ? u * s : u - i, d = i + h + "deg";
            return c && ("short" === (o = r.split("_")[1]) && (h %= l) != h % 180 && (h += h < 0 ? l : -360),
            "cw" === o && h < 0 ? h = (h + 36e9) % l - ~~(h / l) * l : "ccw" === o && h > 0 && (h = (h - 36e9) % l - ~~(h / l) * l)),
            t._pt = a = new $e(t._pt,e,n,i,h,bn),
            a.e = d,
            a.u = "deg",
            t._props.push(n),
            a
        }, fi = function(t, e) {
            for (var n in e)
                t[n] = e[n];
            return t
        }, mi = function(t, e, n) {
            var i, r, s, o, a, l, c, u = fi({}, n._gsap), h = n.style;
            for (r in u.svg ? (s = n.getAttribute("transform"),
            n.setAttribute("transform", ""),
            h[Dn] = e,
            i = ri(n, 1),
            Vn(n, Dn),
            n.setAttribute("transform", s)) : (s = getComputedStyle(n)[Dn],
            h[Dn] = e,
            i = ri(n, 1),
            h[Dn] = s),
            dn)
                (s = u[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Vt(s) !== (c = Vt(o)) ? qn(n, r, s, c) : parseFloat(s),
                l = parseFloat(o),
                t._pt = new $e(t._pt,i,r,a,l - a,_n),
                t._pt.u = c || 0,
                t._props.push(r));
            fi(i, u)
        };
        at("padding,margin,Width,Radius", (function(t, e) {
            var n = "Top"
              , i = "Right"
              , r = "Bottom"
              , s = "Left"
              , o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function(n) {
                return e < 2 ? t + n : "border" + n + t
            }
            ));
            Kn[e > 1 ? "border" + t : t] = function(t, e, n, i, r) {
                var s, a;
                if (arguments.length < 4)
                    return s = o.map((function(e) {
                        return Xn(t, e, n)
                    }
                    )),
                    5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
                s = (i + "").split(" "),
                a = {},
                o.forEach((function(t, e) {
                    return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                }
                )),
                t.init(e, a, r)
            }
        }
        ));
        var gi, vi, yi = {
            name: "css",
            register: Hn,
            targetTest: function(t) {
                return t.style && t.nodeType
            },
            init: function(t, e, n, i, r) {
                var s, o, a, l, c, u, h, d, p, f, m, v, y, x, _, b, w, M, S, T = this._props, A = t.style, C = n.vars.startAt;
                for (h in ln || Hn(),
                e)
                    if ("autoRound" !== h && (o = e[h],
                    !$[h] || !Ie(h, e, n, i, t, r)))
                        if (c = typeof o,
                        u = Kn[h],
                        "function" === c && (c = typeof (o = o.call(n, i, t, r))),
                        "string" === c && ~o.indexOf("random(") && (o = $t(o)),
                        u)
                            u(this, t, h, o, n) && (_ = 1);
                        else if ("--" === h.substr(0, 2))
                            s = (getComputedStyle(t).getPropertyValue(h) + "").trim(),
                            o += "",
                            he.lastIndex = 0,
                            he.test(s) || (d = Vt(s),
                            p = Vt(o)),
                            p ? d !== p && (s = qn(t, h, s, p) + p) : d && (o += d),
                            this.add(A, "setProperty", s, o, i, r, 0, 0, h),
                            T.push(h);
                        else if ("undefined" !== c) {
                            if (C && h in C ? (s = "function" == typeof C[h] ? C[h].call(n, i, t, r) : C[h],
                            E(s) && ~s.indexOf("random(") && (s = $t(s)),
                            Vt(s + "") || (s += g.units[h] || Vt(Xn(t, h)) || ""),
                            "=" === (s + "").charAt(1) && (s = Xn(t, h))) : s = Xn(t, h),
                            l = parseFloat(s),
                            (f = "string" === c && "=" === o.charAt(1) ? +(o.charAt(0) + "1") : 0) && (o = o.substr(2)),
                            a = parseFloat(o),
                            h in xn && ("autoAlpha" === h && (1 === l && "hidden" === Xn(t, "visibility") && a && (l = 0),
                            Wn(this, A, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)),
                            "scale" !== h && "transform" !== h && ~(h = xn[h]).indexOf(",") && (h = h.split(",")[0])),
                            m = h in dn)
                                if (v || ((y = t._gsap).renderTransform && !e.parseTransform || ri(t, e.parseTransform),
                                x = !1 !== e.smoothOrigin && y.smooth,
                                (v = this._pt = new $e(this._pt,A,Dn,0,1,y.renderTransform,y,0,-1)).dep = 1),
                                "scale" === h)
                                    this._pt = new $e(this._pt,y,"scaleY",y.scaleY,(f ? f * a : a - y.scaleY) || 0),
                                    T.push("scaleY", h),
                                    h += "X";
                                else {
                                    if ("transformOrigin" === h) {
                                        w = void 0,
                                        M = void 0,
                                        S = void 0,
                                        M = (w = (b = o).split(" "))[0],
                                        S = w[1] || "50%",
                                        "top" !== M && "bottom" !== M && "left" !== S && "right" !== S || (b = M,
                                        M = S,
                                        S = b),
                                        w[0] = Jn[M] || M,
                                        w[1] = Jn[S] || S,
                                        o = w.join(" "),
                                        y.svg ? ii(t, o, 0, x, 0, this) : ((p = parseFloat(o.split(" ")[2]) || 0) !== y.zOrigin && Wn(this, y, "zOrigin", y.zOrigin, p),
                                        Wn(this, A, h, si(s), si(o)));
                                        continue
                                    }
                                    if ("svgOrigin" === h) {
                                        ii(t, o, 1, x, 0, this);
                                        continue
                                    }
                                    if (h in $n) {
                                        pi(this, y, h, l, o, f);
                                        continue
                                    }
                                    if ("smoothOrigin" === h) {
                                        Wn(this, y, "smooth", y.smooth, o);
                                        continue
                                    }
                                    if ("force3D" === h) {
                                        y[h] = o;
                                        continue
                                    }
                                    if ("transform" === h) {
                                        mi(this, o, t);
                                        continue
                                    }
                                }
                            else
                                h in A || (h = zn(h) || h);
                            if (m || (a || 0 === a) && (l || 0 === l) && !yn.test(o) && h in A)
                                a || (a = 0),
                                (d = (s + "").substr((l + "").length)) !== (p = Vt(o) || (h in g.units ? g.units[h] : d)) && (l = qn(t, h, s, p)),
                                this._pt = new $e(this._pt,m ? y : A,h,l,f ? f * a : a - l,m || "px" !== p && "zIndex" !== h || !1 === e.autoRound ? _n : Mn),
                                this._pt.u = p || 0,
                                d !== p && "%" !== p && (this._pt.b = s,
                                this._pt.r = wn);
                            else if (h in A)
                                Yn.call(this, t, h, s, o);
                            else {
                                if (!(h in t)) {
                                    q(h, o);
                                    continue
                                }
                                this.add(t, h, s || t[h], o, i, r)
                            }
                            T.push(h)
                        }
                _ && Qe(this)
            },
            get: Xn,
            aliases: xn,
            getSetter: function(t, e, n) {
                var i = xn[e];
                return i && i.indexOf(",") < 0 && (e = i),
                e in dn && e !== In && (t._gsap.x || Xn(t, "x")) ? n && un === n ? "scale" === e ? Rn : Cn : (un = n || {}) && ("scale" === e ? Ln : Pn) : t.style && !R(t.style[e]) ? En : ~e.indexOf("-") ? An : We(t, e)
            },
            core: {
                _removeProperty: Vn,
                _getMatrix: ni
            }
        };
        rn.utils.checkPrefix = zn,
        vi = at("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (gi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
            dn[t] = 1
        }
        )),
        at(gi, (function(t) {
            g.units[t] = "deg",
            $n[t] = 1
        }
        )),
        xn[vi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + gi,
        at("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
            var e = t.split(":");
            xn[e[1]] = vi[e[0]]
        }
        )),
        at("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
            g.units[t] = "px"
        }
        )),
        rn.registerPlugin(yi);
        var xi, _i, bi, wi, Mi, Si, Ti, Ei, Ai, Ci, Ri, Li, Pi, Di, Ii, Oi, Ni, ki, zi, Hi, Bi, Fi, Ui, Gi, Vi, Wi, ji = rn.registerPlugin(yi) || rn, qi = (ji.core.Tween,
        1), Xi = [], Yi = [], Ji = Date.now, Zi = Ji(), Ki = 0, Qi = 1, $i = function(t) {
            return t
        }, tr = function(t) {
            return Ai(t)[0] || (ur(t) && !1 !== xi.config().nullTargetWarn ? console.warn("Element not found:", t) : null)
        }, er = function(t) {
            return Math.round(1e5 * t) / 1e5 || 0
        }, nr = function() {
            return "undefined" != typeof window
        }, ir = function() {
            return xi || nr() && (xi = window.gsap) && xi.registerPlugin && xi
        }, rr = function(t) {
            return !!~Ti.indexOf(t)
        }, sr = function(t, e) {
            return ~Xi.indexOf(t) && Xi[Xi.indexOf(t) + 1][e]
        }, or = function(t, e) {
            var n = e.s
              , i = e.sc
              , r = Yi.indexOf(t)
              , s = i === Rr.sc ? 1 : 2;
            return !~r && (r = Yi.push(t) - 1),
            Yi[r + s] || (Yi[r + s] = sr(t, n) || (rr(t) ? i : function(e) {
                return arguments.length ? t[n] = e : t[n]
            }
            ))
        }, ar = function(t) {
            return sr(t, "getBoundingClientRect") || (rr(t) ? function() {
                return gs.width = bi.innerWidth,
                gs.height = bi.innerHeight,
                gs
            }
            : function() {
                return Dr(t)
            }
            )
        }, lr = function(t, e) {
            var n = e.s
              , i = e.d2
              , r = e.d
              , s = e.a;
            return (n = "scroll" + i) && (s = sr(t, n)) ? s() - ar(t)()[r] : rr(t) ? (Si[n] || Mi[n]) - (bi["inner" + i] || Mi["client" + i] || Si["client" + i]) : t[n] - t["offset" + i]
        }, cr = function(t, e) {
            for (var n = 0; n < zi.length; n += 3)
                (!e || ~e.indexOf(zi[n + 1])) && t(zi[n], zi[n + 1], zi[n + 2])
        }, ur = function(t) {
            return "string" == typeof t
        }, hr = function(t) {
            return "function" == typeof t
        }, dr = function(t) {
            return "number" == typeof t
        }, pr = function(t) {
            return "object" == typeof t
        }, fr = function(t) {
            return hr(t) && t()
        }, mr = function(t, e) {
            return function() {
                var n = fr(t)
                  , i = fr(e);
                return function() {
                    fr(n),
                    fr(i)
                }
            }
        }, gr = function(t, e, n) {
            return t && t.progress(e ? 0 : 1) && n && t.pause()
        }, vr = function(t, e) {
            if (t.enabled) {
                var n = e(t);
                n && n.totalTime && (t.callbackAnimation = n)
            }
        }, yr = Math.abs, xr = "left", _r = "right", br = "bottom", wr = "width", Mr = "height", Sr = "padding", Tr = "margin", Er = "Width", Ar = "px", Cr = {
            s: "scrollLeft",
            p: xr,
            p2: "Left",
            os: _r,
            os2: "Right",
            d: wr,
            d2: Er,
            a: "x",
            sc: function(t) {
                return arguments.length ? bi.scrollTo(t, Rr.sc()) : bi.pageXOffset || wi.scrollLeft || Mi.scrollLeft || Si.scrollLeft || 0
            }
        }, Rr = {
            s: "scrollTop",
            p: "top",
            p2: "Top",
            os: br,
            os2: "Bottom",
            d: Mr,
            d2: "Height",
            a: "y",
            op: Cr,
            sc: function(t) {
                return arguments.length ? bi.scrollTo(Cr.sc(), t) : bi.pageYOffset || wi.scrollTop || Mi.scrollTop || Si.scrollTop || 0
            }
        }, Lr = function(t) {
            return bi.getComputedStyle(t)
        }, Pr = function(t, e) {
            for (var n in e)
                n in t || (t[n] = e[n]);
            return t
        }, Dr = function(t, e) {
            var n = e && "matrix(1, 0, 0, 1, 0, 0)" !== Lr(t)[Ii] && xi.to(t, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1)
              , i = t.getBoundingClientRect();
            return n && n.progress(0).kill(),
            i
        }, Ir = function(t, e) {
            var n = e.d2;
            return t["offset" + n] || t["client" + n] || 0
        }, Or = function(t) {
            var e, n = [], i = t.labels, r = t.duration();
            for (e in i)
                n.push(i[e] / r);
            return n
        }, Nr = function(t) {
            var e = xi.utils.snap(t)
              , n = Array.isArray(t) && t.slice(0).sort((function(t, e) {
                return t - e
            }
            ));
            return n ? function(t, i, r) {
                var s;
                if (void 0 === r && (r = .001),
                !i)
                    return e(t);
                if (i > 0) {
                    for (t -= r,
                    s = 0; s < n.length; s++)
                        if (n[s] >= t)
                            return n[s];
                    return n[s - 1]
                }
                for (s = n.length,
                t += r; s--; )
                    if (n[s] <= t)
                        return n[s];
                return n[0]
            }
            : function(n, i, r) {
                void 0 === r && (r = .001);
                var s = e(n);
                return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : e(i < 0 ? n - t : n + t)
            }
        }, kr = function(t, e, n, i) {
            return n.split(",").forEach((function(n) {
                return t(e, n, i)
            }
            ))
        }, zr = function(t, e, n) {
            return t.addEventListener(e, n, {
                passive: !0
            })
        }, Hr = function(t, e, n) {
            return t.removeEventListener(e, n)
        }, Br = {
            startColor: "green",
            endColor: "red",
            indent: 0,
            fontSize: "16px",
            fontWeight: "normal"
        }, Fr = {
            toggleActions: "play",
            anticipatePin: 0
        }, Ur = {
            top: 0,
            left: 0,
            center: .5,
            bottom: 1,
            right: 1
        }, Gr = function(t, e) {
            if (ur(t)) {
                var n = t.indexOf("=")
                  , i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
                ~n && (t.indexOf("%") > n && (i *= e / 100),
                t = t.substr(0, n - 1)),
                t = i + (t in Ur ? Ur[t] * e : ~t.indexOf("%") ? parseFloat(t) * e / 100 : parseFloat(t) || 0)
            }
            return t
        }, Vr = function(t, e, n, i, r, s, o, a) {
            var l = r.startColor
              , c = r.endColor
              , u = r.fontSize
              , h = r.indent
              , d = r.fontWeight
              , p = wi.createElement("div")
              , f = rr(n) || "fixed" === sr(n, "pinType")
              , m = -1 !== t.indexOf("scroller")
              , g = f ? Si : n
              , v = -1 !== t.indexOf("start")
              , y = v ? l : c
              , x = "border-color:" + y + ";font-size:" + u + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
            return x += "position:" + ((m || a) && f ? "fixed;" : "absolute;"),
            (m || a || !f) && (x += (i === Rr ? _r : br) + ":" + (s + parseFloat(h)) + "px;"),
            o && (x += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"),
            p._isStart = v,
            p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
            p.style.cssText = x,
            p.innerText = e || 0 === e ? t + "-" + e : t,
            g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
            p._offset = p["offset" + i.op.d2],
            Wr(p, 0, i, v),
            p
        }, Wr = function(t, e, n, i) {
            var r = {
                display: "block"
            }
              , s = n[i ? "os2" : "p2"]
              , o = n[i ? "p2" : "os2"];
            t._isFlipped = i,
            r[n.a + "Percent"] = i ? -100 : 0,
            r[n.a] = i ? "1px" : 0,
            r["border" + s + Er] = 1,
            r["border" + o + Er] = 0,
            r[n.p] = e + "px",
            xi.set(t, r)
        }, jr = [], qr = {}, Xr = function() {
            return Ji() - Ki > 34 && cs()
        }, Yr = function() {
            cs(),
            Ki || es("scrollStart"),
            Ki = Ji()
        }, Jr = function() {
            return !Pi && !Fi && !wi.fullscreenElement && Ei.restart(!0)
        }, Zr = {}, Kr = [], Qr = [], $r = function(t) {
            var e, n = xi.ticker.frame, i = [], r = 0;
            if (Vi !== n || qi) {
                for (rs(); r < Qr.length; r += 4)
                    (e = bi.matchMedia(Qr[r]).matches) !== Qr[r + 3] && (Qr[r + 3] = e,
                    e ? i.push(r) : rs(1, Qr[r]) || hr(Qr[r + 2]) && Qr[r + 2]());
                for (is(),
                r = 0; r < i.length; r++)
                    e = i[r],
                    Gi = Qr[e],
                    Qr[e + 2] = Qr[e + 1](t);
                Gi = 0,
                _i && os(0, 1),
                Vi = n,
                es("matchMedia")
            }
        }, ts = function t() {
            return Hr(bs, "scrollEnd", t) || os(!0)
        }, es = function(t) {
            return Zr[t] && Zr[t].map((function(t) {
                return t()
            }
            )) || Kr
        }, ns = [], is = function(t) {
            for (var e = 0; e < ns.length; e += 5)
                t && ns[e + 4] !== t || (ns[e].style.cssText = ns[e + 1],
                ns[e].getBBox && ns[e].setAttribute("transform", ns[e + 2] || ""),
                ns[e + 3].uncache = 1)
        }, rs = function(t, e) {
            var n;
            for (Oi = 0; Oi < jr.length; Oi++)
                n = jr[Oi],
                e && n.media !== e || (t ? n.kill(1) : n.revert());
            e && is(e),
            e || es("revert")
        }, ss = function() {
            return Yi.forEach((function(t) {
                return "function" == typeof t && (t.rec = 0)
            }
            ))
        }, os = function(t, e) {
            if (!Ki || t) {
                Wi = !0;
                var n = es("refreshInit");
                Hi && bs.sort(),
                e || rs(),
                jr.forEach((function(t) {
                    return t.refresh()
                }
                )),
                jr.forEach((function(t) {
                    return "max" === t.vars.end && t.setPositions(t.start, lr(t.scroller, t._dir))
                }
                )),
                n.forEach((function(t) {
                    return t && t.render && t.render(-1)
                }
                )),
                ss(),
                Ei.pause(),
                Wi = !1,
                es("refresh")
            } else
                zr(bs, "scrollEnd", ts)
        }, as = 0, ls = 1, cs = function() {
            if (!Wi) {
                var t = jr.length
                  , e = Ji()
                  , n = e - Zi >= 50
                  , i = t && jr[0].scroll();
                if (ls = as > i ? -1 : 1,
                as = i,
                n && (Ki && !Di && e - Ki > 200 && (Ki = 0,
                es("scrollEnd")),
                Ri = Zi,
                Zi = e),
                ls < 0) {
                    for (Oi = t; Oi-- > 0; )
                        jr[Oi] && jr[Oi].update(0, n);
                    ls = 1
                } else
                    for (Oi = 0; Oi < t; Oi++)
                        jr[Oi] && jr[Oi].update(0, n)
            }
        }, us = [xr, "top", br, _r, "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], hs = us.concat([wr, Mr, "boxSizing", "maxWidth", "maxHeight", "position", Tr, Sr, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]), ds = function(t, e, n, i) {
            if (t.parentNode !== e) {
                for (var r, s = us.length, o = e.style, a = t.style; s--; )
                    o[r = us[s]] = n[r];
                o.position = "absolute" === n.position ? "absolute" : "relative",
                "inline" === n.display && (o.display = "inline-block"),
                a.bottom = a.right = o.flexBasis = "auto",
                o.overflow = "visible",
                o.boxSizing = "border-box",
                o.width = Ir(t, Cr) + Ar,
                o.height = Ir(t, Rr) + Ar,
                o.padding = a.margin = a.top = a.left = "0",
                fs(i),
                a.width = a.maxWidth = n.width,
                a.height = a.maxHeight = n.height,
                a.padding = n.padding,
                t.parentNode.insertBefore(e, t),
                e.appendChild(t)
            }
        }, ps = /([A-Z])/g, fs = function(t) {
            if (t) {
                var e, n, i = t.t.style, r = t.length, s = 0;
                for ((t.t._gsap || xi.core.getCache(t.t)).uncache = 1; s < r; s += 2)
                    n = t[s + 1],
                    e = t[s],
                    n ? i[e] = n : i[e] && i.removeProperty(e.replace(ps, "-$1").toLowerCase())
            }
        }, ms = function(t) {
            for (var e = hs.length, n = t.style, i = [], r = 0; r < e; r++)
                i.push(hs[r], n[hs[r]]);
            return i.t = t,
            i
        }, gs = {
            left: 0,
            top: 0
        }, vs = function(t, e, n, i, r, s, o, a, l, c, u, h, d) {
            hr(t) && (t = t(a)),
            ur(t) && "max" === t.substr(0, 3) && (t = h + ("=" === t.charAt(4) ? Gr("0" + t.substr(3), n) : 0));
            var p, f, m, g = d ? d.time() : 0;
            if (d && d.seek(0),
            dr(t))
                o && Wr(o, n, i, !0);
            else {
                hr(e) && (e = e(a));
                var v, y, x, _, b = t.split(" ");
                m = tr(e) || Si,
                (v = Dr(m) || {}) && (v.left || v.top) || "none" !== Lr(m).display || (_ = m.style.display,
                m.style.display = "block",
                v = Dr(m),
                _ ? m.style.display = _ : m.style.removeProperty("display")),
                y = Gr(b[0], v[i.d]),
                x = Gr(b[1] || "0", n),
                t = v[i.p] - l[i.p] - c + y + r - x,
                o && Wr(o, x, i, n - x < 20 || o._isStart && x > 20),
                n -= n - x
            }
            if (s) {
                var w = t + n
                  , M = s._isStart;
                p = "scroll" + i.d2,
                Wr(s, w, i, M && w > 20 || !M && (u ? Math.max(Si[p], Mi[p]) : s.parentNode[p]) <= w + 1),
                u && (l = Dr(o),
                u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + Ar))
            }
            return d && m && (p = Dr(m),
            d.seek(h),
            f = Dr(m),
            d._caScrollDist = p[i.p] - f[i.p],
            t = t / d._caScrollDist * h),
            d && d.seek(g),
            d ? t : Math.round(t)
        }, ys = /(?:webkit|moz|length|cssText|inset)/i, xs = function(t, e, n, i) {
            if (t.parentNode !== e) {
                var r, s, o = t.style;
                if (e === Si) {
                    for (r in t._stOrig = o.cssText,
                    s = Lr(t))
                        +r || ys.test(r) || !s[r] || "string" != typeof o[r] || "0" === r || (o[r] = s[r]);
                    o.top = n,
                    o.left = i
                } else
                    o.cssText = t._stOrig;
                xi.core.getCache(t).uncache = 1,
                e.appendChild(t)
            }
        }, _s = function(t, e) {
            var n, i, r = or(t, e), s = "_scroll" + e.p2, o = function e(o, a, l, c, u) {
                var h = e.tween
                  , d = a.onComplete
                  , p = {};
                return h && h.kill(),
                n = Math.round(l),
                a[s] = o,
                a.modifiers = p,
                p[s] = function(t) {
                    return (t = er(r())) !== n && t !== i && Math.abs(t - n) > 2 && Math.abs(t - i) > 2 ? (h.kill(),
                    e.tween = 0) : t = l + c * h.ratio + u * h.ratio * h.ratio,
                    i = n,
                    n = er(t)
                }
                ,
                a.onComplete = function() {
                    e.tween = 0,
                    d && d.call(h)
                }
                ,
                h = e.tween = xi.to(t, a)
            };
            return t[s] = r,
            zr(t, "wheel", (function() {
                return o.tween && o.tween.kill() && (o.tween = 0)
            }
            )),
            o
        };
        Cr.op = Rr;
        var bs = function() {
            function t(e, n) {
                _i || t.register(xi) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
                this.init(e, n)
            }
            return t.prototype.init = function(e, n) {
                if (this.progress = this.start = 0,
                this.vars && this.kill(1),
                Qi) {
                    var i, r, s, o, a, l, c, u, h, d, p, f, m, g, v, y, x, _, b, w, M, S, T, E, A, C, R, L, P, D, I, O, N, k, z, H, B, F, U, G, V = e = Pr(ur(e) || dr(e) || e.nodeType ? {
                        trigger: e
                    } : e, Fr), W = V.onUpdate, j = V.toggleClass, q = V.id, X = V.onToggle, Y = V.onRefresh, J = V.scrub, Z = V.trigger, K = V.pin, Q = V.pinSpacing, $ = V.invalidateOnRefresh, tt = V.anticipatePin, et = V.onScrubComplete, nt = V.onSnapComplete, it = V.once, rt = V.snap, st = V.pinReparent, ot = V.pinSpacer, at = V.containerAnimation, lt = V.fastScrollEnd, ct = V.preventOverlaps, ut = e.horizontal || e.containerAnimation && !1 !== e.horizontal ? Cr : Rr, ht = !J && 0 !== J, dt = tr(e.scroller || bi), pt = xi.core.getCache(dt), ft = rr(dt), mt = "fixed" === ("pinType"in e ? e.pinType : sr(dt, "pinType") || ft && "fixed"), gt = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack], vt = ht && e.toggleActions.split(" "), yt = "markers"in e ? e.markers : Fr.markers, xt = ft ? 0 : parseFloat(Lr(dt)["border" + ut.p2 + Er]) || 0, _t = this, bt = e.onRefreshInit && function() {
                        return e.onRefreshInit(_t)
                    }
                    , wt = function(t, e, n) {
                        var i = n.d
                          , r = n.d2
                          , s = n.a;
                        return (s = sr(t, "getBoundingClientRect")) ? function() {
                            return s()[i]
                        }
                        : function() {
                            return (e ? bi["inner" + r] : t["client" + r]) || 0
                        }
                    }(dt, ft, ut), Mt = function(t, e) {
                        return !e || ~Xi.indexOf(t) ? ar(t) : function() {
                            return gs
                        }
                    }(dt, ft), St = 0, Tt = or(dt, ut);
                    if (_t.media = Gi,
                    _t._dir = ut,
                    tt *= 45,
                    _t.scroller = dt,
                    _t.scroll = at ? at.time.bind(at) : Tt,
                    o = Tt(),
                    _t.vars = e,
                    n = n || e.animation,
                    "refreshPriority"in e && (Hi = 1),
                    pt.tweenScroll = pt.tweenScroll || {
                        top: _s(dt, Rr),
                        left: _s(dt, Cr)
                    },
                    _t.tweenTo = i = pt.tweenScroll[ut.p],
                    n && (n.vars.lazy = !1,
                    n._initted || !1 !== n.vars.immediateRender && !1 !== e.immediateRender && n.render(0, !0, !0),
                    _t.animation = n.pause(),
                    n.scrollTrigger = _t,
                    (I = dr(J) && J) && (D = xi.to(n, {
                        ease: "power3",
                        duration: I,
                        onComplete: function() {
                            return et && et(_t)
                        }
                    })),
                    L = 0,
                    q || (q = n.vars.id)),
                    jr.push(_t),
                    rt && (pr(rt) && !rt.push || (rt = {
                        snapTo: rt
                    }),
                    "scrollBehavior"in Si.style && xi.set(ft ? [Si, Mi] : dt, {
                        scrollBehavior: "auto"
                    }),
                    s = hr(rt.snapTo) ? rt.snapTo : "labels" === rt.snapTo ? function(t) {
                        return function(e) {
                            return xi.utils.snap(Or(t), e)
                        }
                    }(n) : "labelsDirectional" === rt.snapTo ? (F = n,
                    function(t, e) {
                        return Nr(Or(F))(t, e.direction)
                    }
                    ) : !1 !== rt.directional ? function(t, e) {
                        return Nr(rt.snapTo)(t, e.direction)
                    }
                    : xi.utils.snap(rt.snapTo),
                    O = rt.duration || {
                        min: .1,
                        max: 2
                    },
                    O = pr(O) ? Ci(O.min, O.max) : Ci(O, O),
                    N = xi.delayedCall(rt.delay || I / 2 || .1, (function() {
                        if (Math.abs(_t.getVelocity()) < 10 && !Di && St !== Tt()) {
                            var t = n && !ht ? n.totalProgress() : _t.progress
                              , e = (t - P) / (Ji() - Ri) * 1e3 || 0
                              , r = xi.utils.clamp(-_t.progress, 1 - _t.progress, yr(e / 2) * e / .185)
                              , o = _t.progress + (!1 === rt.inertia ? 0 : r)
                              , a = Ci(0, 1, s(o, _t))
                              , u = Tt()
                              , h = Math.round(l + a * m)
                              , d = rt
                              , p = d.onStart
                              , f = d.onInterrupt
                              , g = d.onComplete
                              , v = i.tween;
                            if (u <= c && u >= l && h !== u) {
                                if (v && !v._initted && v.data <= yr(h - u))
                                    return;
                                !1 === rt.inertia && (r = a - _t.progress),
                                i(h, {
                                    duration: O(yr(.185 * Math.max(yr(o - t), yr(a - t)) / e / .05 || 0)),
                                    ease: rt.ease || "power3",
                                    data: yr(h - u),
                                    onInterrupt: function() {
                                        return N.restart(!0) && f && f(_t)
                                    },
                                    onComplete: function() {
                                        _t.update(),
                                        St = Tt(),
                                        L = P = n && !ht ? n.totalProgress() : _t.progress,
                                        nt && nt(_t),
                                        g && g(_t)
                                    }
                                }, u, r * m, h - u - r * m),
                                p && p(_t, i.tween)
                            }
                        } else
                            _t.isActive && N.restart(!0)
                    }
                    )).pause()),
                    q && (qr[q] = _t),
                    Z = _t.trigger = tr(Z || K),
                    K = !0 === K ? Z : tr(K),
                    ur(j) && (j = {
                        targets: Z,
                        className: j
                    }),
                    K && (!1 === Q || Q === Tr || (Q = !(!Q && "flex" === Lr(K.parentNode).display) && Sr),
                    _t.pin = K,
                    !1 !== e.force3D && xi.set(K, {
                        force3D: !0
                    }),
                    (r = xi.core.getCache(K)).spacer ? g = r.pinState : (ot && ((ot = tr(ot)) && !ot.nodeType && (ot = ot.current || ot.nativeElement),
                    r.spacerIsNative = !!ot,
                    ot && (r.spacerState = ms(ot))),
                    r.spacer = x = ot || wi.createElement("div"),
                    x.classList.add("pin-spacer"),
                    q && x.classList.add("pin-spacer-" + q),
                    r.pinState = g = ms(K)),
                    _t.spacer = x = r.spacer,
                    R = Lr(K),
                    T = R[Q + ut.os2],
                    b = xi.getProperty(K),
                    w = xi.quickSetter(K, ut.a, Ar),
                    ds(K, x, R),
                    y = ms(K)),
                    yt && (f = pr(yt) ? Pr(yt, Br) : Br,
                    d = Vr("scroller-start", q, dt, ut, f, 0),
                    p = Vr("scroller-end", q, dt, ut, f, 0, d),
                    _ = d["offset" + ut.op.d2],
                    u = Vr("start", q, dt, ut, f, _, 0, at),
                    h = Vr("end", q, dt, ut, f, _, 0, at),
                    at && (B = xi.quickSetter([u, h], ut.a, Ar)),
                    mt || Xi.length && !0 === sr(dt, "fixedMarkers") || (G = Lr(U = ft ? Si : dt).position,
                    U.style.position = "absolute" === G || "fixed" === G ? G : "relative",
                    xi.set([d, p], {
                        force3D: !0
                    }),
                    A = xi.quickSetter(d, ut.a, Ar),
                    C = xi.quickSetter(p, ut.a, Ar))),
                    at) {
                        var Et = at.vars.onUpdate
                          , At = at.vars.onUpdateParams;
                        at.eventCallback("onUpdate", (function() {
                            _t.update(0, 0, 1),
                            Et && Et.apply(At || [])
                        }
                        ))
                    }
                    _t.previous = function() {
                        return jr[jr.indexOf(_t) - 1]
                    }
                    ,
                    _t.next = function() {
                        return jr[jr.indexOf(_t) + 1]
                    }
                    ,
                    _t.revert = function(t) {
                        var e = !1 !== t || !_t.enabled
                          , i = Pi;
                        e !== _t.isReverted && (e && (_t.scroll.rec || (_t.scroll.rec = Tt()),
                        z = Math.max(Tt(), _t.scroll.rec || 0),
                        k = _t.progress,
                        H = n && n.progress()),
                        u && [u, h, d, p].forEach((function(t) {
                            return t.style.display = e ? "none" : "block"
                        }
                        )),
                        e && (Pi = 1),
                        _t.update(e),
                        Pi = i,
                        K && (e ? function(t, e, n) {
                            fs(n);
                            var i = t._gsap;
                            if (i.spacerIsNative)
                                fs(i.spacerState);
                            else if (t.parentNode === e) {
                                var r = e.parentNode;
                                r && (r.insertBefore(t, e),
                                r.removeChild(e))
                            }
                        }(K, x, g) : (!st || !_t.isActive) && ds(K, x, Lr(K), E)),
                        _t.isReverted = e)
                    }
                    ,
                    _t.refresh = function(i, r) {
                        if (!Pi && _t.enabled || r)
                            if (K && i && Ki)
                                zr(t, "scrollEnd", ts);
                            else {
                                Pi = 1,
                                D && D.pause(),
                                $ && n && n.time(-.01, !0).invalidate(),
                                _t.isReverted || _t.revert();
                                for (var s, f, _, w, T, A, C, R, L, P, I = wt(), O = Mt(), N = at ? at.duration() : lr(dt, ut), B = 0, F = 0, U = e.end, G = e.endTrigger || Z, V = e.start || (0 !== e.start && Z ? K ? "0 0" : "0 100%" : 0), W = e.pinnedContainer && tr(e.pinnedContainer), j = Z && Math.max(0, jr.indexOf(_t)) || 0, q = j; q--; )
                                    (A = jr[q]).end || A.refresh(0, 1) || (Pi = 1),
                                    !(C = A.pin) || C !== Z && C !== K || A.isReverted || (P || (P = []),
                                    P.unshift(A),
                                    A.revert());
                                for (hr(V) && (V = V(_t)),
                                l = vs(V, Z, I, ut, Tt(), u, d, _t, O, xt, mt, N, at) || (K ? -.001 : 0),
                                hr(U) && (U = U(_t)),
                                ur(U) && !U.indexOf("+=") && (~U.indexOf(" ") ? U = (ur(V) ? V.split(" ")[0] : "") + U : (B = Gr(U.substr(2), I),
                                U = ur(V) ? V : l + B,
                                G = Z)),
                                c = Math.max(l, vs(U || (G ? "100% 0" : N), G, I, ut, Tt() + B, h, p, _t, O, xt, mt, N, at)) || -.001,
                                m = c - l || (l -= .01) && .001,
                                B = 0,
                                q = j; q--; )
                                    (C = (A = jr[q]).pin) && A.start - A._pinPush < l && !at && (s = A.end - A.start,
                                    C !== Z && C !== W || dr(V) || (B += s * (1 - A.progress)),
                                    C === K && (F += s));
                                if (l += B,
                                c += B,
                                _t._pinPush = F,
                                u && B && ((s = {})[ut.a] = "+=" + B,
                                W && (s[ut.p] = "-=" + Tt()),
                                xi.set([u, h], s)),
                                K)
                                    s = Lr(K),
                                    w = ut === Rr,
                                    _ = Tt(),
                                    M = parseFloat(b(ut.a)) + F,
                                    !N && c > 1 && ((ft ? Si : dt).style["overflow-" + ut.a] = "scroll"),
                                    ds(K, x, s),
                                    y = ms(K),
                                    f = Dr(K, !0),
                                    R = mt && or(dt, w ? Cr : Rr)(),
                                    Q && ((E = [Q + ut.os2, m + F + Ar]).t = x,
                                    (q = Q === Sr ? Ir(K, ut) + m + F : 0) && E.push(ut.d, q + Ar),
                                    fs(E),
                                    mt && Tt(z)),
                                    mt && ((T = {
                                        top: f.top + (w ? _ - l : R) + Ar,
                                        left: f.left + (w ? R : _ - l) + Ar,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    }).width = T.maxWidth = Math.ceil(f.width) + Ar,
                                    T.height = T.maxHeight = Math.ceil(f.height) + Ar,
                                    T.margin = T.marginTop = T.marginRight = T.marginBottom = T.marginLeft = "0",
                                    T.padding = s.padding,
                                    T.paddingTop = s.paddingTop,
                                    T.paddingRight = s.paddingRight,
                                    T.paddingBottom = s.paddingBottom,
                                    T.paddingLeft = s.paddingLeft,
                                    v = function(t, e, n) {
                                        for (var i, r = [], s = t.length, o = n ? 8 : 0; o < s; o += 2)
                                            i = t[o],
                                            r.push(i, i in e ? e[i] : t[o + 1]);
                                        return r.t = t.t,
                                        r
                                    }(g, T, st)),
                                    n ? (L = n._initted,
                                    Bi(1),
                                    n.render(n.duration(), !0, !0),
                                    S = b(ut.a) - M + m + F,
                                    m !== S && v.splice(v.length - 2, 2),
                                    n.render(0, !0, !0),
                                    L || n.invalidate(),
                                    Bi(0)) : S = m;
                                else if (Z && Tt() && !at)
                                    for (f = Z.parentNode; f && f !== Si; )
                                        f._pinOffset && (l -= f._pinOffset,
                                        c -= f._pinOffset),
                                        f = f.parentNode;
                                P && P.forEach((function(t) {
                                    return t.revert(!1)
                                }
                                )),
                                _t.start = l,
                                _t.end = c,
                                o = a = Tt(),
                                at || (o < z && Tt(z),
                                _t.scroll.rec = 0),
                                _t.revert(!1),
                                Pi = 0,
                                n && ht && n._initted && n.progress() !== H && n.progress(H, !0).render(n.time(), !0, !0),
                                (k !== _t.progress || at) && (n && !ht && n.totalProgress(k, !0),
                                _t.progress = k,
                                _t.update(0, 0, 1)),
                                K && Q && (x._pinOffset = Math.round(_t.progress * S)),
                                Y && Y(_t)
                            }
                    }
                    ,
                    _t.getVelocity = function() {
                        return (Tt() - a) / (Ji() - Ri) * 1e3 || 0
                    }
                    ,
                    _t.endAnimation = function() {
                        gr(_t.callbackAnimation),
                        n && (D ? D.progress(1) : n.paused() ? ht || gr(n, _t.direction < 0, 1) : gr(n, n.reversed()))
                    }
                    ,
                    _t.labelToScroll = function(t) {
                        return n && n.labels && (l || _t.refresh() || l) + n.labels[t] / n.duration() * m || 0
                    }
                    ,
                    _t.getTrailing = function(t) {
                        var e = jr.indexOf(_t)
                          , n = _t.direction > 0 ? jr.slice(0, e).reverse() : jr.slice(e + 1);
                        return ur(t) ? n.filter((function(e) {
                            return e.vars.preventOverlaps === t
                        }
                        )) : n
                    }
                    ,
                    _t.update = function(t, e, r) {
                        if (!at || r || t) {
                            var s, u, h, p, f, g, _, b = _t.scroll(), E = t ? 0 : (b - l) / m, R = E < 0 ? 0 : E > 1 ? 1 : E || 0, I = _t.progress;
                            if (e && (a = o,
                            o = at ? Tt() : b,
                            rt && (P = L,
                            L = n && !ht ? n.totalProgress() : R)),
                            tt && !R && K && !Pi && !qi && Ki && l < b + (b - a) / (Ji() - Ri) * tt && (R = 1e-4),
                            R !== I && _t.enabled) {
                                if (p = (f = (s = _t.isActive = !!R && R < 1) != (!!I && I < 1)) || !!R != !!I,
                                _t.direction = R > I ? 1 : -1,
                                _t.progress = R,
                                p && !Pi && (u = R && !I ? 0 : 1 === R ? 1 : 1 === I ? 2 : 3,
                                ht && (h = !f && "none" !== vt[u + 1] && vt[u + 1] || vt[u],
                                _ = n && ("complete" === h || "reset" === h || h in n))),
                                ct && f && (_ || J || !n) && (hr(ct) ? ct(_t) : _t.getTrailing(ct).forEach((function(t) {
                                    return t.endAnimation()
                                }
                                ))),
                                ht || (!D || Pi || qi ? n && n.totalProgress(R, !!Pi) : (D.vars.totalProgress = R,
                                D.invalidate().restart())),
                                K)
                                    if (t && Q && (x.style[Q + ut.os2] = T),
                                    mt) {
                                        if (p) {
                                            if (g = !t && R > I && c + 1 > b && b + 1 >= lr(dt, ut),
                                            st)
                                                if (t || !s && !g)
                                                    xs(K, x);
                                                else {
                                                    var O = Dr(K, !0)
                                                      , k = b - l;
                                                    xs(K, Si, O.top + (ut === Rr ? k : 0) + Ar, O.left + (ut === Rr ? 0 : k) + Ar)
                                                }
                                            fs(s || g ? v : y),
                                            S !== m && R < 1 && s || w(M + (1 !== R || g ? 0 : S))
                                        }
                                    } else
                                        w(M + S * R);
                                rt && !i.tween && !Pi && !qi && N.restart(!0),
                                j && (f || it && R && (R < 1 || !Ui)) && Ai(j.targets).forEach((function(t) {
                                    return t.classList[s || it ? "add" : "remove"](j.className)
                                }
                                )),
                                W && !ht && !t && W(_t),
                                p && !Pi ? (ht && (_ && ("complete" === h ? n.pause().totalProgress(1) : "reset" === h ? n.restart(!0).pause() : "restart" === h ? n.restart(!0) : n[h]()),
                                W && W(_t)),
                                !f && Ui || (X && f && vr(_t, X),
                                gt[u] && vr(_t, gt[u]),
                                it && (1 === R ? _t.kill(!1, 1) : gt[u] = 0),
                                f || gt[u = 1 === R ? 1 : 3] && vr(_t, gt[u])),
                                lt && !s && Math.abs(_t.getVelocity()) > (dr(lt) ? lt : 2500) && (gr(_t.callbackAnimation),
                                D ? D.progress(1) : gr(n, !R, 1))) : ht && W && !Pi && W(_t)
                            }
                            if (C) {
                                var z = at ? b / at.duration() * (at._caScrollDist || 0) : b;
                                A(z + (d._isFlipped ? 1 : 0)),
                                C(z)
                            }
                            B && B(-b / at.duration() * (at._caScrollDist || 0))
                        }
                    }
                    ,
                    _t.enable = function(e, n) {
                        _t.enabled || (_t.enabled = !0,
                        zr(dt, "resize", Jr),
                        zr(dt, "scroll", Yr),
                        bt && zr(t, "refreshInit", bt),
                        !1 !== e && (_t.progress = k = 0,
                        o = a = St = Tt()),
                        !1 !== n && _t.refresh())
                    }
                    ,
                    _t.getTween = function(t) {
                        return t && i ? i.tween : D
                    }
                    ,
                    _t.setPositions = function(t, e) {
                        K && (M += t - l,
                        S += e - t - m),
                        _t.start = l = t,
                        _t.end = c = e,
                        m = e - t,
                        _t.update()
                    }
                    ,
                    _t.disable = function(e, n) {
                        if (_t.enabled && (!1 !== e && _t.revert(),
                        _t.enabled = _t.isActive = !1,
                        n || D && D.pause(),
                        z = 0,
                        r && (r.uncache = 1),
                        bt && Hr(t, "refreshInit", bt),
                        N && (N.pause(),
                        i.tween && i.tween.kill() && (i.tween = 0)),
                        !ft)) {
                            for (var s = jr.length; s--; )
                                if (jr[s].scroller === dt && jr[s] !== _t)
                                    return;
                            Hr(dt, "resize", Jr),
                            Hr(dt, "scroll", Yr)
                        }
                    }
                    ,
                    _t.kill = function(t, e) {
                        _t.disable(t, e),
                        D && D.kill(),
                        q && delete qr[q];
                        var i = jr.indexOf(_t);
                        i >= 0 && jr.splice(i, 1),
                        i === Oi && ls > 0 && Oi--,
                        i = 0,
                        jr.forEach((function(t) {
                            return t.scroller === _t.scroller && (i = 1)
                        }
                        )),
                        i || (_t.scroll.rec = 0),
                        n && (n.scrollTrigger = null,
                        t && n.render(-1),
                        e || n.kill()),
                        u && [u, h, d, p].forEach((function(t) {
                            return t.parentNode && t.parentNode.removeChild(t)
                        }
                        )),
                        K && (r && (r.uncache = 1),
                        i = 0,
                        jr.forEach((function(t) {
                            return t.pin === K && i++
                        }
                        )),
                        i || (r.spacer = 0))
                    }
                    ,
                    _t.enable(!1, !1),
                    n && n.add && !m ? xi.delayedCall(.01, (function() {
                        return l || c || _t.refresh()
                    }
                    )) && (m = .01) && (l = c = 0) : _t.refresh()
                } else
                    this.update = this.refresh = this.kill = $i
            }
            ,
            t.register = function(e) {
                if (!_i && (xi = e || ir(),
                nr() && window.document && (bi = window,
                wi = document,
                Mi = wi.documentElement,
                Si = wi.body),
                xi && (Ai = xi.utils.toArray,
                Ci = xi.utils.clamp,
                Bi = xi.core.suppressOverwrites || $i,
                xi.core.globals("ScrollTrigger", t),
                Si))) {
                    zr(bi, "wheel", Yr),
                    Ti = [bi, wi, Mi, Si],
                    zr(wi, "scroll", Yr);
                    var n, i = Si.style, r = i.borderTopStyle;
                    i.borderTopStyle = "solid",
                    n = Dr(Si),
                    Rr.m = Math.round(n.top + Rr.sc()) || 0,
                    Cr.m = Math.round(n.left + Cr.sc()) || 0,
                    r ? i.borderTopStyle = r : i.removeProperty("border-top-style"),
                    Li = setInterval(Xr, 200),
                    xi.delayedCall(.5, (function() {
                        return qi = 0
                    }
                    )),
                    zr(wi, "touchcancel", $i),
                    zr(Si, "touchstart", $i),
                    kr(zr, wi, "pointerdown,touchstart,mousedown", (function() {
                        return Di = 1
                    }
                    )),
                    kr(zr, wi, "pointerup,touchend,mouseup", (function() {
                        return Di = 0
                    }
                    )),
                    Ii = xi.utils.checkPrefix("transform"),
                    hs.push(Ii),
                    _i = Ji(),
                    Ei = xi.delayedCall(.2, os).pause(),
                    zi = [wi, "visibilitychange", function() {
                        var t = bi.innerWidth
                          , e = bi.innerHeight;
                        wi.hidden ? (Ni = t,
                        ki = e) : Ni === t && ki === e || Jr()
                    }
                    , wi, "DOMContentLoaded", os, bi, "load", function() {
                        return Ki || os()
                    }
                    , bi, "resize", Jr],
                    cr(zr)
                }
                return _i
            }
            ,
            t.defaults = function(t) {
                if (t)
                    for (var e in t)
                        Fr[e] = t[e];
                return Fr
            }
            ,
            t.kill = function() {
                Qi = 0,
                jr.slice(0).forEach((function(t) {
                    return t.kill(1)
                }
                ))
            }
            ,
            t.config = function(t) {
                "limitCallbacks"in t && (Ui = !!t.limitCallbacks);
                var e = t.syncInterval;
                e && clearInterval(Li) || (Li = e) && setInterval(Xr, e),
                "autoRefreshEvents"in t && (cr(Hr) || cr(zr, t.autoRefreshEvents || "none"),
                Fi = -1 === (t.autoRefreshEvents + "").indexOf("resize"))
            }
            ,
            t.scrollerProxy = function(t, e) {
                var n = tr(t)
                  , i = Yi.indexOf(n)
                  , r = rr(n);
                ~i && Yi.splice(i, r ? 6 : 2),
                e && (r ? Xi.unshift(bi, e, Si, e, Mi, e) : Xi.unshift(n, e))
            }
            ,
            t.matchMedia = function(t) {
                var e, n, i, r, s;
                for (n in t)
                    i = Qr.indexOf(n),
                    r = t[n],
                    Gi = n,
                    "all" === n ? r() : (e = bi.matchMedia(n)) && (e.matches && (s = r()),
                    ~i ? (Qr[i + 1] = mr(Qr[i + 1], r),
                    Qr[i + 2] = mr(Qr[i + 2], s)) : (i = Qr.length,
                    Qr.push(n, r, s),
                    e.addListener ? e.addListener($r) : e.addEventListener("change", $r)),
                    Qr[i + 3] = e.matches),
                    Gi = 0;
                return Qr
            }
            ,
            t.clearMatchMedia = function(t) {
                t || (Qr.length = 0),
                (t = Qr.indexOf(t)) >= 0 && Qr.splice(t, 4)
            }
            ,
            t.isInViewport = function(t, e, n) {
                var i = (ur(t) ? tr(t) : t).getBoundingClientRect()
                  , r = i[n ? wr : Mr] * e || 0;
                return n ? i.right - r > 0 && i.left + r < bi.innerWidth : i.bottom - r > 0 && i.top + r < bi.innerHeight
            }
            ,
            t.positionInViewport = function(t, e, n) {
                ur(t) && (t = tr(t));
                var i = t.getBoundingClientRect()
                  , r = i[n ? wr : Mr]
                  , s = null == e ? r / 2 : e in Ur ? Ur[e] * r : ~e.indexOf("%") ? parseFloat(e) * r / 100 : parseFloat(e) || 0;
                return n ? (i.left + s) / bi.innerWidth : (i.top + s) / bi.innerHeight
            }
            ,
            t
        }();
        bs.version = "3.9.1",
        bs.saveStyles = function(t) {
            return t ? Ai(t).forEach((function(t) {
                if (t && t.style) {
                    var e = ns.indexOf(t);
                    e >= 0 && ns.splice(e, 5),
                    ns.push(t, t.style.cssText, t.getBBox && t.getAttribute("transform"), xi.core.getCache(t), Gi)
                }
            }
            )) : ns
        }
        ,
        bs.revert = function(t, e) {
            return rs(!t, e)
        }
        ,
        bs.create = function(t, e) {
            return new bs(t,e)
        }
        ,
        bs.refresh = function(t) {
            return t ? Jr() : (_i || bs.register()) && os(!0)
        }
        ,
        bs.update = cs,
        bs.clearScrollMemory = ss,
        bs.maxScroll = function(t, e) {
            return lr(t, e ? Cr : Rr)
        }
        ,
        bs.getScrollFunc = function(t, e) {
            return or(tr(t), e ? Cr : Rr)
        }
        ,
        bs.getById = function(t) {
            return qr[t]
        }
        ,
        bs.getAll = function() {
            return jr.slice(0)
        }
        ,
        bs.isScrolling = function() {
            return !!Ki
        }
        ,
        bs.snapDirectional = Nr,
        bs.addEventListener = function(t, e) {
            var n = Zr[t] || (Zr[t] = []);
            ~n.indexOf(e) || n.push(e)
        }
        ,
        bs.removeEventListener = function(t, e) {
            var n = Zr[t]
              , i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1)
        }
        ,
        bs.batch = function(t, e) {
            var n, i = [], r = {}, s = e.interval || .016, o = e.batchMax || 1e9, a = function(t, e) {
                var n = []
                  , i = []
                  , r = xi.delayedCall(s, (function() {
                    e(n, i),
                    n = [],
                    i = []
                }
                )).pause();
                return function(t) {
                    n.length || r.restart(!0),
                    n.push(t.trigger),
                    i.push(t),
                    o <= n.length && r.progress(1)
                }
            };
            for (n in e)
                r[n] = "on" === n.substr(0, 2) && hr(e[n]) && "onRefreshInit" !== n ? a(0, e[n]) : e[n];
            return hr(o) && (o = o(),
            zr(bs, "refresh", (function() {
                return o = e.batchMax()
            }
            ))),
            Ai(t).forEach((function(t) {
                var e = {};
                for (n in r)
                    e[n] = r[n];
                e.trigger = t,
                i.push(bs.create(e))
            }
            )),
            i
        }
        ,
        bs.sort = function(t) {
            return jr.sort(t || function(t, e) {
                return -1e6 * (t.vars.refreshPriority || 0) + t.start - (e.start + -1e6 * (e.vars.refreshPriority || 0))
            }
            )
        }
        ,
        ir() && xi.registerPlugin(bs);
        var ws, Ms, Ss, Ts, Es, As, Cs, Rs = function() {
            return "undefined" != typeof window
        }, Ls = function() {
            return ws || Rs() && (ws = window.gsap) && ws.registerPlugin && ws
        }, Ps = function(t) {
            return "string" == typeof t
        }, Ds = function(t) {
            return "function" == typeof t
        }, Is = function(t, e) {
            var n = "x" === e ? "Width" : "Height"
              , i = "scroll" + n
              , r = "client" + n;
            return t === Ss || t === Ts || t === Es ? Math.max(Ts[i], Es[i]) - (Ss["inner" + n] || Ts[r] || Es[r]) : t[i] - t["offset" + n]
        }, Os = function(t, e) {
            var n = "scroll" + ("x" === e ? "Left" : "Top");
            return t === Ss && (null != t.pageXOffset ? n = "page" + e.toUpperCase() + "Offset" : t = null != Ts[n] ? Ts : Es),
            function() {
                return t[n]
            }
        }, Ns = function(t, e) {
            if (!(t = As(t)[0]) || !t.getBoundingClientRect)
                return console.warn("scrollTo target doesn't exist. Using 0") || {
                    x: 0,
                    y: 0
                };
            var n = t.getBoundingClientRect()
              , i = !e || e === Ss || e === Es
              , r = i ? {
                top: Ts.clientTop - (Ss.pageYOffset || Ts.scrollTop || Es.scrollTop || 0),
                left: Ts.clientLeft - (Ss.pageXOffset || Ts.scrollLeft || Es.scrollLeft || 0)
            } : e.getBoundingClientRect()
              , s = {
                x: n.left - r.left,
                y: n.top - r.top
            };
            return !i && e && (s.x += Os(e, "x")(),
            s.y += Os(e, "y")()),
            s
        }, ks = function(t, e, n, i, r) {
            return isNaN(t) || "object" == typeof t ? Ps(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i - r : "max" === t ? Is(e, n) - r : Math.min(Is(e, n), Ns(t, e)[n] - r) : parseFloat(t) - r
        }, zs = function() {
            ws = Ls(),
            Rs() && ws && document.body && (Ss = window,
            Es = document.body,
            Ts = document.documentElement,
            As = ws.utils.toArray,
            ws.config({
                autoKillThreshold: 7
            }),
            Cs = ws.config(),
            Ms = 1)
        }, Hs = {
            version: "3.9.1",
            name: "scrollTo",
            rawVars: 1,
            register: function(t) {
                ws = t,
                zs()
            },
            init: function(t, e, n, i, r) {
                Ms || zs();
                var s = this
                  , o = ws.getProperty(t, "scrollSnapType");
                s.isWin = t === Ss,
                s.target = t,
                s.tween = n,
                e = function(t, e, n, i) {
                    if (Ds(t) && (t = t(e, n, i)),
                    "object" != typeof t)
                        return Ps(t) && "max" !== t && "=" !== t.charAt(1) ? {
                            x: t,
                            y: t
                        } : {
                            y: t
                        };
                    if (t.nodeType)
                        return {
                            y: t,
                            x: t
                        };
                    var r, s = {};
                    for (r in t)
                        s[r] = "onAutoKill" !== r && Ds(t[r]) ? t[r](e, n, i) : t[r];
                    return s
                }(e, i, t, r),
                s.vars = e,
                s.autoKill = !!e.autoKill,
                s.getX = Os(t, "x"),
                s.getY = Os(t, "y"),
                s.x = s.xPrev = s.getX(),
                s.y = s.yPrev = s.getY(),
                o && "none" !== o && (s.snap = 1,
                s.snapInline = t.style.scrollSnapType,
                t.style.scrollSnapType = "none"),
                null != e.x ? (s.add(s, "x", s.x, ks(e.x, t, "x", s.x, e.offsetX || 0), i, r),
                s._props.push("scrollTo_x")) : s.skipX = 1,
                null != e.y ? (s.add(s, "y", s.y, ks(e.y, t, "y", s.y, e.offsetY || 0), i, r),
                s._props.push("scrollTo_y")) : s.skipY = 1
            },
            render: function(t, e) {
                for (var n, i, r, s, o, a = e._pt, l = e.target, c = e.tween, u = e.autoKill, h = e.xPrev, d = e.yPrev, p = e.isWin, f = e.snap, m = e.snapInline; a; )
                    a.r(t, a.d),
                    a = a._next;
                n = p || !e.skipX ? e.getX() : h,
                r = (i = p || !e.skipY ? e.getY() : d) - d,
                s = n - h,
                o = Cs.autoKillThreshold,
                e.x < 0 && (e.x = 0),
                e.y < 0 && (e.y = 0),
                u && (!e.skipX && (s > o || s < -o) && n < Is(l, "x") && (e.skipX = 1),
                !e.skipY && (r > o || r < -o) && i < Is(l, "y") && (e.skipY = 1),
                e.skipX && e.skipY && (c.kill(),
                e.vars.onAutoKill && e.vars.onAutoKill.apply(c, e.vars.onAutoKillParams || []))),
                p ? Ss.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y) : (e.skipY || (l.scrollTop = e.y),
                e.skipX || (l.scrollLeft = e.x)),
                !f || 1 !== t && 0 !== t || (i = l.scrollTop,
                n = l.scrollLeft,
                m ? l.style.scrollSnapType = m : l.style.removeProperty("scroll-snap-type"),
                l.scrollTop = i + 1,
                l.scrollLeft = n + 1,
                l.scrollTop = i,
                l.scrollLeft = n),
                e.xPrev = e.x,
                e.yPrev = e.y
            },
            kill: function(t) {
                var e = "scrollTo" === t;
                (e || "scrollTo_x" === t) && (this.skipX = 1),
                (e || "scrollTo_y" === t) && (this.skipY = 1)
            }
        };
        function Bs(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        function Fs(t, e, n) {
            return e && Bs(t.prototype, e),
            n && Bs(t, n),
            t
        }
        function Us(t, e) {
            return Object.getOwnPropertyNames(Object(t)).reduce((function(n, i) {
                var r = Object.getOwnPropertyDescriptor(Object(t), i)
                  , s = Object.getOwnPropertyDescriptor(Object(e), i);
                return Object.defineProperty(n, i, s || r)
            }
            ), {})
        }
        function Gs(t) {
            var e = Us(t);
            return (e.types || e.split) && (e.types = e.types || e.split),
            (e.absolute || e.position) && (e.absolute = e.absolute || /absolute/.test(t.position)),
            e
        }
        function Vs(t) {
            return null !== t && "object" == typeof t
        }
        function Ws(t) {
            return Array.isArray(t) ? t : null == t ? [] : function(t) {
                return Vs(t) && function(t) {
                    return "number" == typeof t && t > -1 && t % 1 == 0
                }(t.length)
            }(t) ? Array.prototype.slice.call(t) : [t]
        }
        function js(t) {
            return Vs(t) && /^(1|3|11)$/.test(t.nodeType)
        }
        function qs(t) {
            return "string" == typeof t
        }
        function Xs(t, e, n) {
            var i = {}
              , r = null;
            return Vs(t) && (r = t[Xs.expando] || (t[Xs.expando] = ++Xs.uid),
            i = Xs.cache[r] || (Xs.cache[r] = {})),
            void 0 === n ? void 0 === e ? i : i[e] : void 0 !== e ? (i[e] = n,
            n) : void 0
        }
        function Ys(t) {
            var e = t && t[Xs.expando];
            e && (delete t[e],
            delete Xs.cache[e])
        }
        function Js(t, e) {
            for (var n = Ws(t), i = n.length, r = 0; r < i; r++)
                e(n[r], r, n)
        }
        Hs.max = Is,
        Hs.getOffset = Ns,
        Hs.buildGetter = Os,
        Ls() && ws.registerPlugin(Hs),
        Xs.expando = "splitType".concat(1 * new Date),
        Xs.cache = {},
        Xs.uid = 0;
        var Zs = "\\ud800-\\udfff"
          , Ks = "\\u0300-\\u036f\\ufe20-\\ufe23"
          , Qs = "\\u20d0-\\u20f0"
          , $s = "\\ufe0e\\ufe0f"
          , to = "[".concat(Zs, "]")
          , eo = "[".concat(Ks).concat(Qs, "]")
          , no = "\\ud83c[\\udffb-\\udfff]"
          , io = "(?:".concat(eo, "|").concat(no, ")")
          , ro = "[^".concat(Zs, "]")
          , so = "(?:\\ud83c[\\udde6-\\uddff]){2}"
          , oo = "[\\ud800-\\udbff][\\udc00-\\udfff]"
          , ao = "".concat(io, "?")
          , lo = "[".concat($s, "]?")
          , co = lo + ao + "(?:\\u200d(?:" + [ro, so, oo].join("|") + ")" + lo + ao + ")*"
          , uo = "(?:".concat(["".concat(ro).concat(eo, "?"), eo, so, oo, to].join("|"), "\n)")
          , ho = RegExp("".concat(no, "(?=").concat(no, ")|").concat(uo).concat(co), "g")
          , po = RegExp("[".concat(["\\u200d", Zs, Ks, Qs, $s].join(""), "]"));
        function fo(t) {
            return po.test(t)
        }
        function mo(t) {
            return fo(t) ? function(t) {
                return t.match(ho) || []
            }(t) : function(t) {
                return t.split("")
            }(t)
        }
        function go(t) {
            return null == t ? "" : String(t)
        }
        function vo(t, e) {
            var n = document.createElement(t);
            return e ? (Object.keys(e).forEach((function(t) {
                var i = e[t];
                null !== i && ("textContent" === t || "innerHTML" === t ? n[t] = i : "children" === t ? Js(i, (function(t) {
                    js(t) && n.appendChild(t)
                }
                )) : n.setAttribute(t, String(i).trim()))
            }
            )),
            n) : n
        }
        var yo = {
            splitClass: "",
            lineClass: "line",
            wordClass: "word",
            charClass: "char",
            types: "lines, words, chars",
            absolute: !1,
            tagName: "div"
        }
          , xo = function() {
            return document.createDocumentFragment()
        }
          , _o = function(t) {
            return document.createTextNode(t)
        };
        var bo = Us(yo, {})
          , wo = function() {
            function t(e, n) {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.isSplit = !1,
                this.settings = Us(bo, Gs(n)),
                this.elements = function(t) {
                    var e, n = t;
                    return qs(t) && (n = /^(#[a-z]\w+)$/.test(t.trim()) ? document.getElementById(t.trim().slice(1)) : document.querySelectorAll(t)),
                    (e = n,
                    Ws(e).reduce((function(t, e) {
                        return t.concat(Ws(e))
                    }
                    ), [])).filter(js)
                }(e) || [],
                this.elements.length && (this.originals = this.elements.map((function(t) {
                    return Xs(t, "html", Xs(t).html || t.innerHTML)
                }
                )),
                this.settings.types && this.split())
            }
            return Fs(t, null, [{
                key: "defaults",
                get: function() {
                    return bo
                },
                set: function(t) {
                    bo = Us(bo, Gs(t))
                }
            }]),
            Fs(t, [{
                key: "split",
                value: function(t) {
                    var e = this;
                    this.revert(),
                    this.lines = [],
                    this.words = [],
                    this.chars = [];
                    var n = [window.pageXOffset, window.pageYOffset];
                    void 0 !== t && (this.settings = Us(this.settings, Gs(t))),
                    this.elements.forEach((function(t) {
                        var n = function(t, e) {
                            var n, i, r = function(t) {
                                var e = qs(t) || Array.isArray(t) ? String(t) : "";
                                return {
                                    lines: /line/i.test(e),
                                    words: /word/i.test(e),
                                    chars: /(char)|(character)/i.test(e)
                                }
                            }((e = Us(yo, e)).types), s = e.tagName, o = "B".concat(1 * new Date, "R"), a = "absolute" === e.position || e.absolute, l = [], c = [];
                            if (i = r.lines ? vo("div") : xo(),
                            n = function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : " ";
                                return (t = t ? String(t) : "").split(e)
                            }(function(t, e) {
                                var n = t.textContent;
                                if (e) {
                                    var i = t.innerHTML
                                      , r = document.createElement("div");
                                    r.innerHTML = i.replace(/<br\s*\/?>/g, " ".concat(e, " ")),
                                    n = r.textContent
                                }
                                return n.replace(/\s+/g, " ").trim()
                            }(t, o)).reduce((function(t, n, a, l) {
                                var u, h;
                                return n === o ? (i.appendChild(vo("br")),
                                t) : (r.chars && (h = function(t) {
                                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                                    return (t = go(t)) && qs(t) && !e && fo(t) ? mo(t) : t.split(e)
                                }(n).map((function(t) {
                                    return vo(s, {
                                        class: "".concat(e.splitClass, " ").concat(e.charClass),
                                        style: "display: inline-block;",
                                        textContent: t
                                    })
                                }
                                )),
                                c = c.concat(h)),
                                r.words || r.lines ? (u = vo(s, {
                                    class: "".concat(e.wordClass, " ").concat(e.splitClass),
                                    style: "display: inline-block; position: ".concat(r.words ? "relative" : "static"),
                                    children: r.chars ? h : null,
                                    textContent: r.chars ? null : n
                                }),
                                i.appendChild(u)) : Js(h, (function(t) {
                                    i.appendChild(t)
                                }
                                )),
                                a !== l.length - 1 && i.appendChild(_o(" ")),
                                r.words ? t.concat(u) : t)
                            }
                            ), []),
                            t.innerHTML = "",
                            t.appendChild(i),
                            !a && !r.lines)
                                return {
                                    chars: c,
                                    words: n,
                                    lines: []
                                };
                            var u, h, d, p, f, m = [], g = [], v = Xs(t, "nodes", t.getElementsByTagName(s)), y = t.parentElement, x = t.nextElementSibling, _ = window.getComputedStyle(t).textAlign;
                            return a && (p = {
                                left: i.offsetLeft,
                                top: i.offsetTop,
                                width: i.offsetWidth
                            },
                            d = t.offsetWidth,
                            h = t.offsetHeight,
                            Xs(t).cssWidth = t.style.width,
                            Xs(t).cssHeight = t.style.height),
                            Js(v, (function(t) {
                                if (t !== i) {
                                    var e, n = t.parentElement === i;
                                    r.lines && n && ((e = Xs(t, "top", t.offsetTop)) !== f && (f = e,
                                    m.push(g = [])),
                                    g.push(t)),
                                    a && (Xs(t).top = e || t.offsetTop,
                                    Xs(t).left = t.offsetLeft,
                                    Xs(t).width = t.offsetWidth,
                                    Xs(t).height = u || (u = t.offsetHeight))
                                }
                            }
                            )),
                            y && y.removeChild(t),
                            r.lines && (i = xo(),
                            l = m.map((function(t) {
                                var n = vo(s, {
                                    class: "".concat(e.splitClass, " ").concat(e.lineClass),
                                    style: "display: block; text-align: ".concat(_, "; width: 100%;")
                                });
                                return i.appendChild(n),
                                a && (Xs(n).type = "line",
                                Xs(n).top = Xs(t[0]).top,
                                Xs(n).height = u),
                                Js(t, (function(t, e, i) {
                                    r.words ? n.appendChild(t) : r.chars ? Js(t.children, (function(t) {
                                        n.appendChild(t)
                                    }
                                    )) : n.appendChild(_o(t.textContent)),
                                    e !== i.length - 1 && n.appendChild(_o(" "))
                                }
                                )),
                                n
                            }
                            )),
                            t.replaceChild(i, t.firstChild)),
                            a && (t.style.width = "".concat(t.style.width || d, "px"),
                            t.style.height = "".concat(h, "px"),
                            Js(v, (function(t) {
                                var e = "line" === Xs(t).type
                                  , n = !e && "line" === Xs(t.parentElement).type;
                                t.style.top = "".concat(n ? 0 : Xs(t).top, "px"),
                                t.style.left = "".concat(e ? p.left : Xs(t).left - (n ? p.left : 0), "px"),
                                t.style.height = "".concat(Xs(t).height, "px"),
                                t.style.width = "".concat(e ? p.width : Xs(t).width, "px"),
                                t.style.position = "absolute"
                            }
                            ))),
                            y && (x ? y.insertBefore(t, x) : y.appendChild(t)),
                            {
                                lines: l,
                                words: r.words ? n : [],
                                chars: c
                            }
                        }(t, e.settings)
                          , i = n.lines
                          , r = n.words
                          , s = n.chars;
                        e.lines = e.lines.concat(i),
                        e.words = e.words.concat(r),
                        e.chars = e.chars.concat(s),
                        Xs(t).isSplit = !0
                    }
                    )),
                    this.isSplit = !0,
                    window.scrollTo(n[0], n[1]),
                    this.elements.forEach((function(t) {
                        Ws(Xs(t).nodes || []).forEach(Ys)
                    }
                    ))
                }
            }, {
                key: "revert",
                value: function() {
                    var t = this;
                    this.isSplit && (this.lines = null,
                    this.words = null,
                    this.chars = null),
                    this.elements.forEach((function(e) {
                        Xs(e).isSplit && Xs(e).html && (e.innerHTML = Xs(e).html,
                        e.style.height = Xs(e).cssHeight || "",
                        e.style.width = Xs(e).cssWidth || "",
                        t.isSplit = !1)
                    }
                    ))
                }
            }]),
            t
        }()
          , Mo = function(t, e, n) {
            t.forEach((function(t) {
                var i = document.createElement(e);
                i.classList = n,
                t.parentNode.appendChild(i),
                i.appendChild(t)
            }
            ))
        }
          , So = function() {
            return {
                width: window.innerWidth,
                height: window.innerHeight
            }
        };
        function To(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                    if (t) {
                        if ("string" == typeof t)
                            return Eo(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name),
                        "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Eo(t, e) : void 0
                    }
                }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0
                      , r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var s, o = !0, a = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return o = t.done,
                    t
                },
                e: function(t) {
                    a = !0,
                    s = t
                },
                f: function() {
                    try {
                        o || null == n.return || n.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
            }
        }
        function Eo(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++)
                i[n] = t[n];
            return i
        }
        function Ao(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var Co = function() {
            function t(e) {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.DOM = {
                    animationElems: Array.isArray(e) ? e : [e]
                },
                this.SplitTypeInstances = [],
                this.lines = [];
                var n, i = To(this.DOM.animationElems);
                try {
                    for (i.s(); !(n = i.n()).done; ) {
                        var r = n.value
                          , s = new wo(r,{
                            types: "lines"
                        });
                        Mo(s.lines, "div", "split"),
                        this.lines.push(s.lines),
                        this.SplitTypeInstances.push(s)
                    }
                } catch (t) {
                    i.e(t)
                } finally {
                    i.f()
                }
                this.initEvents()
            }
            var e, n;
            return e = t,
            (n = [{
                key: "in",
                value: function() {
                    return this.isVisible = !0,
                    ji.killTweensOf(this.lines),
                    ji.timeline({
                        defaults: {
                            duration: 1.2,
                            ease: "expo"
                        }
                    }).set(this.lines, {
                        y: "150%",
                        opacity: 0,
                        rotate: 15
                    }).to(this.lines, {
                        y: "0%",
                        rotate: 0,
                        opacity: 1,
                        stagger: .04
                    })
                }
            }, {
                key: "out",
                value: function() {
                    return this.isVisible = !1,
                    ji.killTweensOf(this.lines),
                    ji.timeline({
                        defaults: {
                            duration: .7,
                            ease: "power2"
                        }
                    }).to(this.lines, {
                        y: "-150%",
                        rotate: -5,
                        opacity: 0,
                        stagger: .02
                    })
                }
            }, {
                key: "initEvents",
                value: function() {
                    var t = this;
                    window.addEventListener("resize", (function() {
                        t.lines = [];
                        var e, n = To(t.SplitTypeInstances);
                        try {
                            for (n.s(); !(e = n.n()).done; ) {
                                var i = e.value;
                                i.split(),
                                Mo(i.lines, "div", "split"),
                                t.lines.push(i.lines)
                            }
                        } catch (t) {
                            n.e(t)
                        } finally {
                            n.f()
                        }
                        t.isVisible || ji.set(t.lines, {
                            y: "-150%",
                            opacity: 0
                        })
                    }
                    ))
                }
            }]) && Ao(e.prototype, n),
            t
        }();
        function Ro(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++)
                i[n] = t[n];
            return i
        }
        function Lo(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var Po = function() {
            function t(e) {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.DOM = {
                    animationElems: Array.isArray(e) ? e : [e]
                },
                this.lines = [];
                var n, i = function(t, e) {
                    var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!n) {
                        if (Array.isArray(t) || (n = function(t, e) {
                            if (t) {
                                if ("string" == typeof t)
                                    return Ro(t, e);
                                var n = Object.prototype.toString.call(t).slice(8, -1);
                                return "Object" === n && t.constructor && (n = t.constructor.name),
                                "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ro(t, e) : void 0
                            }
                        }(t)) || e && t && "number" == typeof t.length) {
                            n && (t = n);
                            var i = 0
                              , r = function() {};
                            return {
                                s: r,
                                n: function() {
                                    return i >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[i++]
                                    }
                                },
                                e: function(t) {
                                    throw t
                                },
                                f: r
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var s, o = !0, a = !1;
                    return {
                        s: function() {
                            n = n.call(t)
                        },
                        n: function() {
                            var t = n.next();
                            return o = t.done,
                            t
                        },
                        e: function(t) {
                            a = !0,
                            s = t
                        },
                        f: function() {
                            try {
                                o || null == n.return || n.return()
                            } finally {
                                if (a)
                                    throw s
                            }
                        }
                    }
                }(this.DOM.animationElems);
                try {
                    for (i.s(); !(n = i.n()).done; ) {
                        var r = n.value;
                        this.lines.push(r)
                    }
                } catch (t) {
                    i.e(t)
                } finally {
                    i.f()
                }
                this.initEvents()
            }
            var e, n;
            return e = t,
            (n = [{
                key: "in",
                value: function() {
                    return this.isVisible = !0,
                    ji.killTweensOf(this.lines),
                    ji.timeline({
                        defaults: {
                            duration: 1.2,
                            ease: "expo"
                        }
                    }).set(this.lines, {
                        y: "150%",
                        opacity: 0,
                        rotate: 15
                    }).to(this.lines, {
                        y: "0%",
                        rotate: 0,
                        opacity: 1,
                        stagger: .04
                    })
                }
            }, {
                key: "out",
                value: function() {
                    return this.isVisible = !1,
                    ji.killTweensOf(this.lines),
                    ji.timeline({
                        defaults: {
                            duration: .7,
                            ease: "power2"
                        }
                    }).to(this.lines, {
                        y: "-150%",
                        rotate: -5,
                        opacity: 0,
                        stagger: .02
                    })
                }
            }, {
                key: "initEvents",
                value: function() {
                    var t = this;
                    window.addEventListener("resize", (function() {
                        t.lines = [],
                        t.isVisible || ji.set(t.lines, {
                            y: "-150%",
                            opacity: 0
                        })
                    }
                    ))
                }
            }]) && Lo(e.prototype, n),
            t
        }()
          , Do = n(90)
          , Io = n.n(Do);
        ji.registerPlugin(bs, Hs);
        var Oo = n(755)
          , No = n.n(Oo);
        const ko = 100
          , zo = 301
          , Ho = 302
          , Bo = 306
          , Fo = 1e3
          , Uo = 1001
          , Go = 1002
          , Vo = 1003
          , Wo = 1004
          , jo = 1005
          , qo = 1006
          , Xo = 1008
          , Yo = 1009
          , Jo = 1012
          , Zo = 1014
          , Ko = 1015
          , Qo = 1016
          , $o = 1020
          , ta = 1023
          , ea = 1026
          , na = 1027
          , ia = 33776
          , ra = 33777
          , sa = 33778
          , oa = 33779
          , aa = 2300
          , la = 2301
          , ca = 2302
          , ua = 2400
          , ha = 2401
          , da = 2402
          , pa = 3e3
          , fa = 3001
          , ma = 7680
          , ga = 35044
          , va = 35048
          , ya = "300 es"
          , xa = 1035;
        class _a {
            addEventListener(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[t] && (n[t] = []),
                -1 === n[t].indexOf(e) && n[t].push(e)
            }
            hasEventListener(t, e) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[t] && -1 !== n[t].indexOf(e)
            }
            removeEventListener(t, e) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners[t];
                if (void 0 !== n) {
                    const t = n.indexOf(e);
                    -1 !== t && n.splice(t, 1)
                }
            }
            dispatchEvent(t) {
                if (void 0 === this._listeners)
                    return;
                const e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    const n = e.slice(0);
                    for (let e = 0, i = n.length; e < i; e++)
                        n[e].call(this, t);
                    t.target = null
                }
            }
        }
        const ba = [];
        for (let t = 0; t < 256; t++)
            ba[t] = (t < 16 ? "0" : "") + t.toString(16);
        let wa = 1234567;
        const Ma = Math.PI / 180
          , Sa = 180 / Math.PI;
        function Ta() {
            const t = 4294967295 * Math.random() | 0
              , e = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (ba[255 & t] + ba[t >> 8 & 255] + ba[t >> 16 & 255] + ba[t >> 24 & 255] + "-" + ba[255 & e] + ba[e >> 8 & 255] + "-" + ba[e >> 16 & 15 | 64] + ba[e >> 24 & 255] + "-" + ba[63 & n | 128] + ba[n >> 8 & 255] + "-" + ba[n >> 16 & 255] + ba[n >> 24 & 255] + ba[255 & i] + ba[i >> 8 & 255] + ba[i >> 16 & 255] + ba[i >> 24 & 255]).toUpperCase()
        }
        function Ea(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }
        function Aa(t, e) {
            return (t % e + e) % e
        }
        function Ca(t, e, n) {
            return (1 - n) * t + n * e
        }
        function Ra(t) {
            return 0 == (t & t - 1) && 0 !== t
        }
        function La(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }
        function Pa(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
        var Da = Object.freeze({
            __proto__: null,
            DEG2RAD: Ma,
            RAD2DEG: Sa,
            generateUUID: Ta,
            clamp: Ea,
            euclideanModulo: Aa,
            mapLinear: function(t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            inverseLerp: function(t, e, n) {
                return t !== e ? (n - t) / (e - t) : 0
            },
            lerp: Ca,
            damp: function(t, e, n, i) {
                return Ca(t, e, 1 - Math.exp(-n * i))
            },
            pingpong: function(t, e=1) {
                return e - Math.abs(Aa(t, 2 * e) - e)
            },
            smoothstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            seededRandom: function(t) {
                return void 0 !== t && (wa = t % 2147483647),
                wa = 16807 * wa % 2147483647,
                (wa - 1) / 2147483646
            },
            degToRad: function(t) {
                return t * Ma
            },
            radToDeg: function(t) {
                return t * Sa
            },
            isPowerOfTwo: Ra,
            ceilPowerOfTwo: La,
            floorPowerOfTwo: Pa,
            setQuaternionFromProperEuler: function(t, e, n, i, r) {
                const s = Math.cos
                  , o = Math.sin
                  , a = s(n / 2)
                  , l = o(n / 2)
                  , c = s((e + i) / 2)
                  , u = o((e + i) / 2)
                  , h = s((e - i) / 2)
                  , d = o((e - i) / 2)
                  , p = s((i - e) / 2)
                  , f = o((i - e) / 2);
                switch (r) {
                case "XYX":
                    t.set(a * u, l * h, l * d, a * c);
                    break;
                case "YZY":
                    t.set(l * d, a * u, l * h, a * c);
                    break;
                case "ZXZ":
                    t.set(l * h, l * d, a * u, a * c);
                    break;
                case "XZX":
                    t.set(a * u, l * f, l * p, a * c);
                    break;
                case "YXY":
                    t.set(l * p, a * u, l * f, a * c);
                    break;
                case "ZYZ":
                    t.set(l * f, l * p, a * u, a * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            }
        });
        class Ia {
            constructor(t=0, e=0) {
                this.x = t,
                this.y = e
            }
            get width() {
                return this.x
            }
            set width(t) {
                this.x = t
            }
            get height() {
                return this.y
            }
            set height(t) {
                this.y = t
            }
            set(t, e) {
                return this.x = t,
                this.y = e,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = t.elements;
                return this.x = i[0] * e + i[3] * n + i[6],
                this.y = i[1] * e + i[4] * n + i[7],
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y
            }
            cross(t) {
                return this.x * t.y - this.y * t.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y;
                return e * e + n * n
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this
            }
            rotateAround(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = this.x - t.x
                  , s = this.y - t.y;
                return this.x = r * n - s * i + t.x,
                this.y = r * i + s * n + t.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        Ia.prototype.isVector2 = !0;
        class Oa {
            constructor() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, i, r, s, o, a, l) {
                const c = this.elements;
                return c[0] = t,
                c[1] = i,
                c[2] = o,
                c[3] = e,
                c[4] = r,
                c[5] = a,
                c[6] = n,
                c[7] = s,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrix3Column(this, 0),
                e.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(t) {
                const e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                this
            }
            multiply(t) {
                return this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , s = n[0]
                  , o = n[3]
                  , a = n[6]
                  , l = n[1]
                  , c = n[4]
                  , u = n[7]
                  , h = n[2]
                  , d = n[5]
                  , p = n[8]
                  , f = i[0]
                  , m = i[3]
                  , g = i[6]
                  , v = i[1]
                  , y = i[4]
                  , x = i[7]
                  , _ = i[2]
                  , b = i[5]
                  , w = i[8];
                return r[0] = s * f + o * v + a * _,
                r[3] = s * m + o * y + a * b,
                r[6] = s * g + o * x + a * w,
                r[1] = l * f + c * v + u * _,
                r[4] = l * m + c * y + u * b,
                r[7] = l * g + c * x + u * w,
                r[2] = h * f + d * v + p * _,
                r[5] = h * m + d * y + p * b,
                r[8] = h * g + d * x + p * w,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[3] *= t,
                e[6] *= t,
                e[1] *= t,
                e[4] *= t,
                e[7] *= t,
                e[2] *= t,
                e[5] *= t,
                e[8] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , o = t[5]
                  , a = t[6]
                  , l = t[7]
                  , c = t[8];
                return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , o = t[5]
                  , a = t[6]
                  , l = t[7]
                  , c = t[8]
                  , u = c * s - o * l
                  , h = o * a - c * r
                  , d = l * r - s * a
                  , p = e * u + n * h + i * d;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return t[0] = u * f,
                t[1] = (i * l - c * n) * f,
                t[2] = (o * n - i * s) * f,
                t[3] = h * f,
                t[4] = (c * e - i * a) * f,
                t[5] = (i * r - o * e) * f,
                t[6] = d * f,
                t[7] = (n * a - l * e) * f,
                t[8] = (s * e - n * r) * f,
                this
            }
            transpose() {
                let t;
                const e = this.elements;
                return t = e[1],
                e[1] = e[3],
                e[3] = t,
                t = e[2],
                e[2] = e[6],
                e[6] = t,
                t = e[5],
                e[5] = e[7],
                e[7] = t,
                this
            }
            getNormalMatrix(t) {
                return this.setFromMatrix4(t).invert().transpose()
            }
            transposeIntoArray(t) {
                const e = this.elements;
                return t[0] = e[0],
                t[1] = e[3],
                t[2] = e[6],
                t[3] = e[1],
                t[4] = e[4],
                t[5] = e[7],
                t[6] = e[2],
                t[7] = e[5],
                t[8] = e[8],
                this
            }
            setUvTransform(t, e, n, i, r, s, o) {
                const a = Math.cos(r)
                  , l = Math.sin(r);
                return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1),
                this
            }
            scale(t, e) {
                const n = this.elements;
                return n[0] *= t,
                n[3] *= t,
                n[6] *= t,
                n[1] *= e,
                n[4] *= e,
                n[7] *= e,
                this
            }
            rotate(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t)
                  , i = this.elements
                  , r = i[0]
                  , s = i[3]
                  , o = i[6]
                  , a = i[1]
                  , l = i[4]
                  , c = i[7];
                return i[0] = e * r + n * a,
                i[3] = e * s + n * l,
                i[6] = e * o + n * c,
                i[1] = -n * r + e * a,
                i[4] = -n * s + e * l,
                i[7] = -n * o + e * c,
                this
            }
            translate(t, e) {
                const n = this.elements;
                return n[0] += t * n[2],
                n[3] += t * n[5],
                n[6] += t * n[8],
                n[1] += e * n[2],
                n[4] += e * n[5],
                n[7] += e * n[8],
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 9; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        function Na(t) {
            for (let e = t.length - 1; e >= 0; --e)
                if (t[e] > 65535)
                    return !0;
            return !1
        }
        function ka(t) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", t)
        }
        Oa.prototype.isMatrix3 = !0,
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
        const za = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Ha = {
            h: 0,
            s: 0,
            l: 0
        }
          , Ba = {
            h: 0,
            s: 0,
            l: 0
        };
        function Fa(t, e, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
        }
        function Ua(t) {
            return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }
        function Ga(t) {
            return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }
        class Va {
            constructor(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }
            set(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
                this
            }
            setScalar(t) {
                return this.r = t,
                this.g = t,
                this.b = t,
                this
            }
            setHex(t) {
                return t = Math.floor(t),
                this.r = (t >> 16 & 255) / 255,
                this.g = (t >> 8 & 255) / 255,
                this.b = (255 & t) / 255,
                this
            }
            setRGB(t, e, n) {
                return this.r = t,
                this.g = e,
                this.b = n,
                this
            }
            setHSL(t, e, n) {
                if (t = Aa(t, 1),
                e = Ea(e, 0, 1),
                n = Ea(n, 0, 1),
                0 === e)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + e) : n + e - n * e
                      , r = 2 * n - i;
                    this.r = Fa(r, i, t + 1 / 3),
                    this.g = Fa(r, i, t),
                    this.b = Fa(r, i, t - 1 / 3)
                }
                return this
            }
            setStyle(t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                let n;
                if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                    let t;
                    const i = n[1]
                      , r = n[2];
                    switch (i) {
                    case "rgb":
                    case "rgba":
                        if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                            return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                            this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                            this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                            e(t[4]),
                            this;
                        if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                            return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                            this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                            this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                            e(t[4]),
                            this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                            const n = parseFloat(t[1]) / 360
                              , i = parseInt(t[2], 10) / 100
                              , r = parseInt(t[3], 10) / 100;
                            return e(t[4]),
                            this.setHSL(n, i, r)
                        }
                    }
                } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                    const t = n[1]
                      , e = t.length;
                    if (3 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                        this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                        this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                        this;
                    if (6 === e)
                        return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                        this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                        this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                        this
                }
                return t && t.length > 0 ? this.setColorName(t) : this
            }
            setColorName(t) {
                const e = za[t.toLowerCase()];
                return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(t) {
                return this.r = t.r,
                this.g = t.g,
                this.b = t.b,
                this
            }
            copySRGBToLinear(t) {
                return this.r = Ua(t.r),
                this.g = Ua(t.g),
                this.b = Ua(t.b),
                this
            }
            copyLinearToSRGB(t) {
                return this.r = Ga(t.r),
                this.g = Ga(t.g),
                this.b = Ga(t.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }
            getHexString() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }
            getHSL(t) {
                const e = this.r
                  , n = this.g
                  , i = this.b
                  , r = Math.max(e, n, i)
                  , s = Math.min(e, n, i);
                let o, a;
                const l = (s + r) / 2;
                if (s === r)
                    o = 0,
                    a = 0;
                else {
                    const t = r - s;
                    switch (a = l <= .5 ? t / (r + s) : t / (2 - r - s),
                    r) {
                    case e:
                        o = (n - i) / t + (n < i ? 6 : 0);
                        break;
                    case n:
                        o = (i - e) / t + 2;
                        break;
                    case i:
                        o = (e - n) / t + 4
                    }
                    o /= 6
                }
                return t.h = o,
                t.s = a,
                t.l = l,
                t
            }
            getStyle() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }
            offsetHSL(t, e, n) {
                return this.getHSL(Ha),
                Ha.h += t,
                Ha.s += e,
                Ha.l += n,
                this.setHSL(Ha.h, Ha.s, Ha.l),
                this
            }
            add(t) {
                return this.r += t.r,
                this.g += t.g,
                this.b += t.b,
                this
            }
            addColors(t, e) {
                return this.r = t.r + e.r,
                this.g = t.g + e.g,
                this.b = t.b + e.b,
                this
            }
            addScalar(t) {
                return this.r += t,
                this.g += t,
                this.b += t,
                this
            }
            sub(t) {
                return this.r = Math.max(0, this.r - t.r),
                this.g = Math.max(0, this.g - t.g),
                this.b = Math.max(0, this.b - t.b),
                this
            }
            multiply(t) {
                return this.r *= t.r,
                this.g *= t.g,
                this.b *= t.b,
                this
            }
            multiplyScalar(t) {
                return this.r *= t,
                this.g *= t,
                this.b *= t,
                this
            }
            lerp(t, e) {
                return this.r += (t.r - this.r) * e,
                this.g += (t.g - this.g) * e,
                this.b += (t.b - this.b) * e,
                this
            }
            lerpColors(t, e, n) {
                return this.r = t.r + (e.r - t.r) * n,
                this.g = t.g + (e.g - t.g) * n,
                this.b = t.b + (e.b - t.b) * n,
                this
            }
            lerpHSL(t, e) {
                this.getHSL(Ha),
                t.getHSL(Ba);
                const n = Ca(Ha.h, Ba.h, e)
                  , i = Ca(Ha.s, Ba.s, e)
                  , r = Ca(Ha.l, Ba.l, e);
                return this.setHSL(n, i, r),
                this
            }
            equals(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }
            fromArray(t, e=0) {
                return this.r = t[e],
                this.g = t[e + 1],
                this.b = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.r,
                t[e + 1] = this.g,
                t[e + 2] = this.b,
                t
            }
            fromBufferAttribute(t, e) {
                return this.r = t.getX(e),
                this.g = t.getY(e),
                this.b = t.getZ(e),
                !0 === t.normalized && (this.r /= 255,
                this.g /= 255,
                this.b /= 255),
                this
            }
            toJSON() {
                return this.getHex()
            }
        }
        let Wa;
        Va.NAMES = za,
        Va.prototype.isColor = !0,
        Va.prototype.r = 1,
        Va.prototype.g = 1,
        Va.prototype.b = 1;
        class ja {
            static getDataURL(t) {
                if (/^data:/i.test(t.src))
                    return t.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return t.src;
                let e;
                if (t instanceof HTMLCanvasElement)
                    e = t;
                else {
                    void 0 === Wa && (Wa = ka("canvas")),
                    Wa.width = t.width,
                    Wa.height = t.height;
                    const n = Wa.getContext("2d");
                    t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                    e = Wa
                }
                return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t),
                e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
            }
            static sRGBToLinear(t) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const e = ka("canvas");
                    e.width = t.width,
                    e.height = t.height;
                    const n = e.getContext("2d");
                    n.drawImage(t, 0, 0, t.width, t.height);
                    const i = n.getImageData(0, 0, t.width, t.height)
                      , r = i.data;
                    for (let t = 0; t < r.length; t++)
                        r[t] = 255 * Ua(r[t] / 255);
                    return n.putImageData(i, 0, 0),
                    e
                }
                if (t.data) {
                    const e = t.data.slice(0);
                    for (let t = 0; t < e.length; t++)
                        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * Ua(e[t] / 255)) : e[t] = Ua(e[t]);
                    return {
                        data: e,
                        width: t.width,
                        height: t.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                t
            }
        }
        let qa = 0;
        class Xa extends _a {
            constructor(t=Xa.DEFAULT_IMAGE, e=Xa.DEFAULT_MAPPING, n=1001, i=1001, r=1006, s=1008, o=1023, a=1009, l=1, c=3e3) {
                super(),
                Object.defineProperty(this, "id", {
                    value: qa++
                }),
                this.uuid = Ta(),
                this.name = "",
                this.image = t,
                this.mipmaps = [],
                this.mapping = e,
                this.wrapS = n,
                this.wrapT = i,
                this.magFilter = r,
                this.minFilter = s,
                this.anisotropy = l,
                this.format = o,
                this.internalFormat = null,
                this.type = a,
                this.offset = new Ia(0,0),
                this.repeat = new Ia(1,1),
                this.center = new Ia(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new Oa,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.encoding = c,
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.needsPMREMUpdate = !1
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.name = t.name,
                this.image = t.image,
                this.mipmaps = t.mipmaps.slice(0),
                this.mapping = t.mapping,
                this.wrapS = t.wrapS,
                this.wrapT = t.wrapT,
                this.magFilter = t.magFilter,
                this.minFilter = t.minFilter,
                this.anisotropy = t.anisotropy,
                this.format = t.format,
                this.internalFormat = t.internalFormat,
                this.type = t.type,
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                this.rotation = t.rotation,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrix.copy(t.matrix),
                this.generateMipmaps = t.generateMipmaps,
                this.premultiplyAlpha = t.premultiplyAlpha,
                this.flipY = t.flipY,
                this.unpackAlignment = t.unpackAlignment,
                this.encoding = t.encoding,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid])
                    return t.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    const i = this.image;
                    if (void 0 === i.uuid && (i.uuid = Ta()),
                    !e && void 0 === t.images[i.uuid]) {
                        let e;
                        if (Array.isArray(i)) {
                            e = [];
                            for (let t = 0, n = i.length; t < n; t++)
                                i[t].isDataTexture ? e.push(Ya(i[t].image)) : e.push(Ya(i[t]))
                        } else
                            e = Ya(i);
                        t.images[i.uuid] = {
                            uuid: i.uuid,
                            url: e
                        }
                    }
                    n.image = i.uuid
                }
                return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                e || (t.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(t) {
                if (300 !== this.mapping)
                    return t;
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                    case Fo:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case Uo:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case Go:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                    case Fo:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case Uo:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case Go:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                return this.flipY && (t.y = 1 - t.y),
                t
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        function Ya(t) {
            return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ja.getDataURL(t) : t.data ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        Xa.DEFAULT_IMAGE = void 0,
        Xa.DEFAULT_MAPPING = 300,
        Xa.prototype.isTexture = !0;
        class Ja {
            constructor(t=0, e=0, n=0, i=1) {
                this.x = t,
                this.y = e,
                this.z = n,
                this.w = i
            }
            get width() {
                return this.z
            }
            set width(t) {
                this.z = t
            }
            get height() {
                return this.w
            }
            set height(t) {
                this.w = t
            }
            set(t, e, n, i) {
                return this.x = t,
                this.y = e,
                this.z = n,
                this.w = i,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this.w = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setW(t) {
                return this.w = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this.w = void 0 !== t.w ? t.w : 1,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this.w += t.w,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this.w += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this.w = t.w + e.w,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this.w += t.w * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this.w -= t.w,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this.w -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this.w = t.w - e.w,
                this
            }
            multiply(t) {
                return this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this.w *= t.w,
                this
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this.w *= t,
                this
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = this.w
                  , s = t.elements;
                return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r,
                this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r,
                this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r,
                this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            setAxisAngleFromQuaternion(t) {
                this.w = 2 * Math.acos(t.w);
                const e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = t.x / e,
                this.y = t.y / e,
                this.z = t.z / e),
                this
            }
            setAxisAngleFromRotationMatrix(t) {
                let e, n, i, r;
                const s = .01
                  , o = .1
                  , a = t.elements
                  , l = a[0]
                  , c = a[4]
                  , u = a[8]
                  , h = a[1]
                  , d = a[5]
                  , p = a[9]
                  , f = a[2]
                  , m = a[6]
                  , g = a[10];
                if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
                    if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o)
                        return this.set(1, 0, 0, 0),
                        this;
                    e = Math.PI;
                    const t = (l + 1) / 2
                      , a = (d + 1) / 2
                      , v = (g + 1) / 2
                      , y = (c + h) / 4
                      , x = (u + f) / 4
                      , _ = (p + m) / 4;
                    return t > a && t > v ? t < s ? (n = 0,
                    i = .707106781,
                    r = .707106781) : (n = Math.sqrt(t),
                    i = y / n,
                    r = x / n) : a > v ? a < s ? (n = .707106781,
                    i = 0,
                    r = .707106781) : (i = Math.sqrt(a),
                    n = y / i,
                    r = _ / i) : v < s ? (n = .707106781,
                    i = .707106781,
                    r = 0) : (r = Math.sqrt(v),
                    n = x / r,
                    i = _ / r),
                    this.set(n, i, r, e),
                    this
                }
                let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                return Math.abs(v) < .001 && (v = 1),
                this.x = (m - p) / v,
                this.y = (u - f) / v,
                this.z = (h - c) / v,
                this.w = Math.acos((l + d + g - 1) / 2),
                this
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this.w = Math.min(this.w, t.w),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this.w = Math.max(this.w, t.w),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this.w = Math.max(t.w, Math.min(e.w, this.w)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this.w = Math.max(t, Math.min(e, this.w)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this.w += (t.w - this.w) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this.w = t.w + (e.w - t.w) * n,
                this
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this.w = t[e + 3],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t[e + 3] = this.w,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this.w = t.getW(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        Ja.prototype.isVector4 = !0;
        class Za extends _a {
            constructor(t, e, n={}) {
                super(),
                this.width = t,
                this.height = e,
                this.depth = 1,
                this.scissor = new Ja(0,0,t,e),
                this.scissorTest = !1,
                this.viewport = new Ja(0,0,t,e),
                this.texture = new Xa(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
                this.texture.isRenderTargetTexture = !0,
                this.texture.image = {
                    width: t,
                    height: e,
                    depth: 1
                },
                this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
                this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null,
                this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : qo,
                this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
                this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
                this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }
            setTexture(t) {
                t.image = {
                    width: this.width,
                    height: this.height,
                    depth: this.depth
                },
                this.texture = t
            }
            setSize(t, e, n=1) {
                this.width === t && this.height === e && this.depth === n || (this.width = t,
                this.height = e,
                this.depth = n,
                this.texture.image.width = t,
                this.texture.image.height = e,
                this.texture.image.depth = n,
                this.dispose()),
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.width = t.width,
                this.height = t.height,
                this.depth = t.depth,
                this.viewport.copy(t.viewport),
                this.texture = t.texture.clone(),
                this.texture.image = Object.assign({}, t.texture.image),
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                this.depthTexture = t.depthTexture,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        Za.prototype.isWebGLRenderTarget = !0,
        class extends Za {
            constructor(t, e, n) {
                super(t, e);
                const i = this.texture;
                this.texture = [];
                for (let t = 0; t < n; t++)
                    this.texture[t] = i.clone()
            }
            setSize(t, e, n=1) {
                if (this.width !== t || this.height !== e || this.depth !== n) {
                    this.width = t,
                    this.height = e,
                    this.depth = n;
                    for (let i = 0, r = this.texture.length; i < r; i++)
                        this.texture[i].image.width = t,
                        this.texture[i].image.height = e,
                        this.texture[i].image.depth = n;
                    this.dispose()
                }
                return this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e),
                this
            }
            copy(t) {
                this.dispose(),
                this.width = t.width,
                this.height = t.height,
                this.depth = t.depth,
                this.viewport.set(0, 0, this.width, this.height),
                this.scissor.set(0, 0, this.width, this.height),
                this.depthBuffer = t.depthBuffer,
                this.stencilBuffer = t.stencilBuffer,
                this.depthTexture = t.depthTexture,
                this.texture.length = 0;
                for (let e = 0, n = t.texture.length; e < n; e++)
                    this.texture[e] = t.texture[e].clone();
                return this
            }
        }
        .prototype.isWebGLMultipleRenderTargets = !0;
        class Ka extends Za {
            constructor(t, e, n={}) {
                super(t, e, n),
                this.samples = 4,
                this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth,
                this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture,
                this.useRenderbuffer = !1 === this.useRenderToTexture
            }
            copy(t) {
                return super.copy.call(this, t),
                this.samples = t.samples,
                this.useRenderToTexture = t.useRenderToTexture,
                this.useRenderbuffer = t.useRenderbuffer,
                this
            }
        }
        Ka.prototype.isWebGLMultisampleRenderTarget = !0;
        class Qa {
            constructor(t=0, e=0, n=0, i=1) {
                this._x = t,
                this._y = e,
                this._z = n,
                this._w = i
            }
            static slerp(t, e, n, i) {
                return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
                n.slerpQuaternions(t, e, i)
            }
            static slerpFlat(t, e, n, i, r, s, o) {
                let a = n[i + 0]
                  , l = n[i + 1]
                  , c = n[i + 2]
                  , u = n[i + 3];
                const h = r[s + 0]
                  , d = r[s + 1]
                  , p = r[s + 2]
                  , f = r[s + 3];
                if (0 === o)
                    return t[e + 0] = a,
                    t[e + 1] = l,
                    t[e + 2] = c,
                    void (t[e + 3] = u);
                if (1 === o)
                    return t[e + 0] = h,
                    t[e + 1] = d,
                    t[e + 2] = p,
                    void (t[e + 3] = f);
                if (u !== f || a !== h || l !== d || c !== p) {
                    let t = 1 - o;
                    const e = a * h + l * d + c * p + u * f
                      , n = e >= 0 ? 1 : -1
                      , i = 1 - e * e;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                          , s = Math.atan2(r, e * n);
                        t = Math.sin(t * s) / r,
                        o = Math.sin(o * s) / r
                    }
                    const r = o * n;
                    if (a = a * t + h * r,
                    l = l * t + d * r,
                    c = c * t + p * r,
                    u = u * t + f * r,
                    t === 1 - o) {
                        const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                        a *= t,
                        l *= t,
                        c *= t,
                        u *= t
                    }
                }
                t[e] = a,
                t[e + 1] = l,
                t[e + 2] = c,
                t[e + 3] = u
            }
            static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                const o = n[i]
                  , a = n[i + 1]
                  , l = n[i + 2]
                  , c = n[i + 3]
                  , u = r[s]
                  , h = r[s + 1]
                  , d = r[s + 2]
                  , p = r[s + 3];
                return t[e] = o * p + c * u + a * d - l * h,
                t[e + 1] = a * p + c * h + l * u - o * d,
                t[e + 2] = l * p + c * d + o * h - a * u,
                t[e + 3] = c * p - o * u - a * h - l * d,
                t
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(t) {
                this._w = t,
                this._onChangeCallback()
            }
            set(t, e, n, i) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._w = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(t) {
                return this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = t.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(t, e) {
                if (!t || !t.isEuler)
                    throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , s = t._order
                  , o = Math.cos
                  , a = Math.sin
                  , l = o(n / 2)
                  , c = o(i / 2)
                  , u = o(r / 2)
                  , h = a(n / 2)
                  , d = a(i / 2)
                  , p = a(r / 2);
                switch (s) {
                case "XYZ":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "YXZ":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                case "ZXY":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "ZYX":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                case "YZX":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "XZY":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !1 !== e && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(t, e) {
                const n = e / 2
                  , i = Math.sin(n);
                return this._x = t.x * i,
                this._y = t.y * i,
                this._z = t.z * i,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t) {
                const e = t.elements
                  , n = e[0]
                  , i = e[4]
                  , r = e[8]
                  , s = e[1]
                  , o = e[5]
                  , a = e[9]
                  , l = e[2]
                  , c = e[6]
                  , u = e[10]
                  , h = n + o + u;
                if (h > 0) {
                    const t = .5 / Math.sqrt(h + 1);
                    this._w = .25 / t,
                    this._x = (c - a) * t,
                    this._y = (r - l) * t,
                    this._z = (s - i) * t
                } else if (n > o && n > u) {
                    const t = 2 * Math.sqrt(1 + n - o - u);
                    this._w = (c - a) / t,
                    this._x = .25 * t,
                    this._y = (i + s) / t,
                    this._z = (r + l) / t
                } else if (o > u) {
                    const t = 2 * Math.sqrt(1 + o - n - u);
                    this._w = (r - l) / t,
                    this._x = (i + s) / t,
                    this._y = .25 * t,
                    this._z = (a + c) / t
                } else {
                    const t = 2 * Math.sqrt(1 + u - n - o);
                    this._w = (s - i) / t,
                    this._x = (r + l) / t,
                    this._y = (a + c) / t,
                    this._z = .25 * t
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(t, e) {
                let n = t.dot(e) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
                this._y = t.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -t.z,
                this._z = t.y,
                this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
                this._y = t.z * e.x - t.x * e.z,
                this._z = t.x * e.y - t.y * e.x,
                this._w = n),
                this.normalize()
            }
            angleTo(t) {
                return 2 * Math.acos(Math.abs(Ea(this.dot(t), -1, 1)))
            }
            rotateTowards(t, e) {
                const n = this.angleTo(t);
                if (0 === n)
                    return this;
                const i = Math.min(1, e / n);
                return this.slerp(t, i),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let t = this.length();
                return 0 === t ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (t = 1 / t,
                this._x = this._x * t,
                this._y = this._y * t,
                this._z = this._z * t,
                this._w = this._w * t),
                this._onChangeCallback(),
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            }
            premultiply(t) {
                return this.multiplyQuaternions(t, this)
            }
            multiplyQuaternions(t, e) {
                const n = t._x
                  , i = t._y
                  , r = t._z
                  , s = t._w
                  , o = e._x
                  , a = e._y
                  , l = e._z
                  , c = e._w;
                return this._x = n * c + s * o + i * l - r * a,
                this._y = i * c + s * a + r * o - n * l,
                this._z = r * c + s * l + n * a - i * o,
                this._w = s * c - n * o - i * a - r * l,
                this._onChangeCallback(),
                this
            }
            slerp(t, e) {
                if (0 === e)
                    return this;
                if (1 === e)
                    return this.copy(t);
                const n = this._x
                  , i = this._y
                  , r = this._z
                  , s = this._w;
                let o = s * t._w + n * t._x + i * t._y + r * t._z;
                if (o < 0 ? (this._w = -t._w,
                this._x = -t._x,
                this._y = -t._y,
                this._z = -t._z,
                o = -o) : this.copy(t),
                o >= 1)
                    return this._w = s,
                    this._x = n,
                    this._y = i,
                    this._z = r,
                    this;
                const a = 1 - o * o;
                if (a <= Number.EPSILON) {
                    const t = 1 - e;
                    return this._w = t * s + e * this._w,
                    this._x = t * n + e * this._x,
                    this._y = t * i + e * this._y,
                    this._z = t * r + e * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const l = Math.sqrt(a)
                  , c = Math.atan2(l, o)
                  , u = Math.sin((1 - e) * c) / l
                  , h = Math.sin(e * c) / l;
                return this._w = s * u + this._w * h,
                this._x = n * u + this._x * h,
                this._y = i * u + this._y * h,
                this._z = r * u + this._z * h,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(t, e, n) {
                return this.copy(t).slerp(e, n)
            }
            random() {
                const t = Math.random()
                  , e = Math.sqrt(1 - t)
                  , n = Math.sqrt(t)
                  , i = 2 * Math.PI * Math.random()
                  , r = 2 * Math.PI * Math.random();
                return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            }
            fromArray(t, e=0) {
                return this._x = t[e],
                this._y = t[e + 1],
                this._z = t[e + 2],
                this._w = t[e + 3],
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._w,
                t
            }
            fromBufferAttribute(t, e) {
                return this._x = t.getX(e),
                this._y = t.getY(e),
                this._z = t.getZ(e),
                this._w = t.getW(e),
                this
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        Qa.prototype.isQuaternion = !0;
        class $a {
            constructor(t=0, e=0, n=0) {
                this.x = t,
                this.y = e,
                this.z = n
            }
            set(t, e, n) {
                return void 0 === n && (n = this.z),
                this.x = t,
                this.y = e,
                this.z = n,
                this
            }
            setScalar(t) {
                return this.x = t,
                this.y = t,
                this.z = t,
                this
            }
            setX(t) {
                return this.x = t,
                this
            }
            setY(t) {
                return this.y = t,
                this
            }
            setZ(t) {
                return this.z = t,
                this
            }
            setComponent(t, e) {
                switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
                }
                return this
            }
            getComponent(t) {
                switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(t) {
                return this.x = t.x,
                this.y = t.y,
                this.z = t.z,
                this
            }
            add(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                this.addVectors(t, e)) : (this.x += t.x,
                this.y += t.y,
                this.z += t.z,
                this)
            }
            addScalar(t) {
                return this.x += t,
                this.y += t,
                this.z += t,
                this
            }
            addVectors(t, e) {
                return this.x = t.x + e.x,
                this.y = t.y + e.y,
                this.z = t.z + e.z,
                this
            }
            addScaledVector(t, e) {
                return this.x += t.x * e,
                this.y += t.y * e,
                this.z += t.z * e,
                this
            }
            sub(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(t, e)) : (this.x -= t.x,
                this.y -= t.y,
                this.z -= t.z,
                this)
            }
            subScalar(t) {
                return this.x -= t,
                this.y -= t,
                this.z -= t,
                this
            }
            subVectors(t, e) {
                return this.x = t.x - e.x,
                this.y = t.y - e.y,
                this.z = t.z - e.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                this.multiplyVectors(t, e)) : (this.x *= t.x,
                this.y *= t.y,
                this.z *= t.z,
                this)
            }
            multiplyScalar(t) {
                return this.x *= t,
                this.y *= t,
                this.z *= t,
                this
            }
            multiplyVectors(t, e) {
                return this.x = t.x * e.x,
                this.y = t.y * e.y,
                this.z = t.z * e.z,
                this
            }
            applyEuler(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(el.setFromEuler(t))
            }
            applyAxisAngle(t, e) {
                return this.applyQuaternion(el.setFromAxisAngle(t, e))
            }
            applyMatrix3(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i,
                this.y = r[1] * e + r[4] * n + r[7] * i,
                this.z = r[2] * e + r[5] * n + r[8] * i,
                this
            }
            applyNormalMatrix(t) {
                return this.applyMatrix3(t).normalize()
            }
            applyMatrix4(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements
                  , s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s,
                this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s,
                this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s,
                this
            }
            applyQuaternion(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.x
                  , s = t.y
                  , o = t.z
                  , a = t.w
                  , l = a * e + s * i - o * n
                  , c = a * n + o * e - r * i
                  , u = a * i + r * n - s * e
                  , h = -r * e - s * n - o * i;
                return this.x = l * a + h * -r + c * -o - u * -s,
                this.y = c * a + h * -s + u * -r - l * -o,
                this.z = u * a + h * -o + l * -s - c * -r,
                this
            }
            project(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            }
            unproject(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            }
            transformDirection(t) {
                const e = this.x
                  , n = this.y
                  , i = this.z
                  , r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i,
                this.y = r[1] * e + r[5] * n + r[9] * i,
                this.z = r[2] * e + r[6] * n + r[10] * i,
                this.normalize()
            }
            divide(t) {
                return this.x /= t.x,
                this.y /= t.y,
                this.z /= t.z,
                this
            }
            divideScalar(t) {
                return this.multiplyScalar(1 / t)
            }
            min(t) {
                return this.x = Math.min(this.x, t.x),
                this.y = Math.min(this.y, t.y),
                this.z = Math.min(this.z, t.z),
                this
            }
            max(t) {
                return this.x = Math.max(this.x, t.x),
                this.y = Math.max(this.y, t.y),
                this.z = Math.max(this.z, t.z),
                this
            }
            clamp(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                this.y = Math.max(t.y, Math.min(e.y, this.y)),
                this.z = Math.max(t.z, Math.min(e.z, this.z)),
                this
            }
            clampScalar(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)),
                this.y = Math.max(t, Math.min(e, this.y)),
                this.z = Math.max(t, Math.min(e, this.z)),
                this
            }
            clampLength(t, e) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(t) {
                return this.normalize().multiplyScalar(t)
            }
            lerp(t, e) {
                return this.x += (t.x - this.x) * e,
                this.y += (t.y - this.y) * e,
                this.z += (t.z - this.z) * e,
                this
            }
            lerpVectors(t, e, n) {
                return this.x = t.x + (e.x - t.x) * n,
                this.y = t.y + (e.y - t.y) * n,
                this.z = t.z + (e.z - t.z) * n,
                this
            }
            cross(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                this.crossVectors(t, e)) : this.crossVectors(this, t)
            }
            crossVectors(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = e.x
                  , o = e.y
                  , a = e.z;
                return this.x = i * a - r * o,
                this.y = r * s - n * a,
                this.z = n * o - i * s,
                this
            }
            projectOnVector(t) {
                const e = t.lengthSq();
                if (0 === e)
                    return this.set(0, 0, 0);
                const n = t.dot(this) / e;
                return this.copy(t).multiplyScalar(n)
            }
            projectOnPlane(t) {
                return tl.copy(this).projectOnVector(t),
                this.sub(tl)
            }
            reflect(t) {
                return this.sub(tl.copy(t).multiplyScalar(2 * this.dot(t)))
            }
            angleTo(t) {
                const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                if (0 === e)
                    return Math.PI / 2;
                const n = this.dot(t) / e;
                return Math.acos(Ea(n, -1, 1))
            }
            distanceTo(t) {
                return Math.sqrt(this.distanceToSquared(t))
            }
            distanceToSquared(t) {
                const e = this.x - t.x
                  , n = this.y - t.y
                  , i = this.z - t.z;
                return e * e + n * n + i * i
            }
            manhattanDistanceTo(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }
            setFromSpherical(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            }
            setFromSphericalCoords(t, e, n) {
                const i = Math.sin(e) * t;
                return this.x = i * Math.sin(n),
                this.y = Math.cos(e) * t,
                this.z = i * Math.cos(n),
                this
            }
            setFromCylindrical(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            }
            setFromCylindricalCoords(t, e, n) {
                return this.x = t * Math.sin(e),
                this.y = n,
                this.z = t * Math.cos(e),
                this
            }
            setFromMatrixPosition(t) {
                const e = t.elements;
                return this.x = e[12],
                this.y = e[13],
                this.z = e[14],
                this
            }
            setFromMatrixScale(t) {
                const e = this.setFromMatrixColumn(t, 0).length()
                  , n = this.setFromMatrixColumn(t, 1).length()
                  , i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e,
                this.y = n,
                this.z = i,
                this
            }
            setFromMatrixColumn(t, e) {
                return this.fromArray(t.elements, 4 * e)
            }
            setFromMatrix3Column(t, e) {
                return this.fromArray(t.elements, 3 * e)
            }
            equals(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }
            fromArray(t, e=0) {
                return this.x = t[e],
                this.y = t[e + 1],
                this.z = t[e + 2],
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this.x,
                t[e + 1] = this.y,
                t[e + 2] = this.z,
                t
            }
            fromBufferAttribute(t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
                this.x = t.getX(e),
                this.y = t.getY(e),
                this.z = t.getZ(e),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const t = 2 * (Math.random() - .5)
                  , e = Math.random() * Math.PI * 2
                  , n = Math.sqrt(1 - t ** 2);
                return this.x = n * Math.cos(e),
                this.y = n * Math.sin(e),
                this.z = t,
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        $a.prototype.isVector3 = !0;
        const tl = new $a
          , el = new Qa;
        class nl {
            constructor(t=new $a(1 / 0,1 / 0,1 / 0), e=new $a(-1 / 0,-1 / 0,-1 / 0)) {
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromArray(t) {
                let e = 1 / 0
                  , n = 1 / 0
                  , i = 1 / 0
                  , r = -1 / 0
                  , s = -1 / 0
                  , o = -1 / 0;
                for (let a = 0, l = t.length; a < l; a += 3) {
                    const l = t[a]
                      , c = t[a + 1]
                      , u = t[a + 2];
                    l < e && (e = l),
                    c < n && (n = c),
                    u < i && (i = u),
                    l > r && (r = l),
                    c > s && (s = c),
                    u > o && (o = u)
                }
                return this.min.set(e, n, i),
                this.max.set(r, s, o),
                this
            }
            setFromBufferAttribute(t) {
                let e = 1 / 0
                  , n = 1 / 0
                  , i = 1 / 0
                  , r = -1 / 0
                  , s = -1 / 0
                  , o = -1 / 0;
                for (let a = 0, l = t.count; a < l; a++) {
                    const l = t.getX(a)
                      , c = t.getY(a)
                      , u = t.getZ(a);
                    l < e && (e = l),
                    c < n && (n = c),
                    u < i && (i = u),
                    l > r && (r = l),
                    c > s && (s = c),
                    u > o && (o = u)
                }
                return this.min.set(e, n, i),
                this.max.set(r, s, o),
                this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = rl.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
            setFromObject(t, e=!1) {
                return this.makeEmpty(),
                this.expandByObject(t, e)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            expandByObject(t, e=!1) {
                t.updateWorldMatrix(!1, !1);
                const n = t.geometry;
                if (void 0 !== n)
                    if (e && null != n.attributes && void 0 !== n.attributes.position) {
                        const e = n.attributes.position;
                        for (let n = 0, i = e.count; n < i; n++)
                            rl.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
                            this.expandByPoint(rl)
                    } else
                        null === n.boundingBox && n.computeBoundingBox(),
                        sl.copy(n.boundingBox),
                        sl.applyMatrix4(t.matrixWorld),
                        this.union(sl);
                const i = t.children;
                for (let t = 0, n = i.length; t < n; t++)
                    this.expandByObject(i[t], e);
                return this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }
            intersectsSphere(t) {
                return this.clampPoint(t.center, rl),
                rl.distanceToSquared(t.center) <= t.radius * t.radius
            }
            intersectsPlane(t) {
                let e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                n = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                n += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                n += t.normal.z * this.min.z),
                e <= -t.constant && n >= -t.constant
            }
            intersectsTriangle(t) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(dl),
                pl.subVectors(this.max, dl),
                ol.subVectors(t.a, dl),
                al.subVectors(t.b, dl),
                ll.subVectors(t.c, dl),
                cl.subVectors(al, ol),
                ul.subVectors(ll, al),
                hl.subVectors(ol, ll);
                let e = [0, -cl.z, cl.y, 0, -ul.z, ul.y, 0, -hl.z, hl.y, cl.z, 0, -cl.x, ul.z, 0, -ul.x, hl.z, 0, -hl.x, -cl.y, cl.x, 0, -ul.y, ul.x, 0, -hl.y, hl.x, 0];
                return !!gl(e, ol, al, ll, pl) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!gl(e, ol, al, ll, pl) && (fl.crossVectors(cl, ul),
                e = [fl.x, fl.y, fl.z],
                gl(e, ol, al, ll, pl)))
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return rl.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            getBoundingSphere(t) {
                return this.getCenter(t.center),
                t.radius = .5 * this.getSize(rl).length(),
                t
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            applyMatrix4(t) {
                return this.isEmpty() || (il[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                il[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                il[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                il[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                il[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                il[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                il[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                il[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(il)),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        nl.prototype.isBox3 = !0;
        const il = [new $a, new $a, new $a, new $a, new $a, new $a, new $a, new $a]
          , rl = new $a
          , sl = new nl
          , ol = new $a
          , al = new $a
          , ll = new $a
          , cl = new $a
          , ul = new $a
          , hl = new $a
          , dl = new $a
          , pl = new $a
          , fl = new $a
          , ml = new $a;
        function gl(t, e, n, i, r) {
            for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                ml.fromArray(t, s);
                const o = r.x * Math.abs(ml.x) + r.y * Math.abs(ml.y) + r.z * Math.abs(ml.z)
                  , a = e.dot(ml)
                  , l = n.dot(ml)
                  , c = i.dot(ml);
                if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o)
                    return !1
            }
            return !0
        }
        const vl = new nl
          , yl = new $a
          , xl = new $a
          , _l = new $a;
        class bl {
            constructor(t=new $a, e=-1) {
                this.center = t,
                this.radius = e
            }
            set(t, e) {
                return this.center.copy(t),
                this.radius = e,
                this
            }
            setFromPoints(t, e) {
                const n = this.center;
                void 0 !== e ? n.copy(e) : vl.setFromPoints(t).getCenter(n);
                let i = 0;
                for (let e = 0, r = t.length; e < r; e++)
                    i = Math.max(i, n.distanceToSquared(t[e]));
                return this.radius = Math.sqrt(i),
                this
            }
            copy(t) {
                return this.center.copy(t.center),
                this.radius = t.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(t) {
                return t.distanceTo(this.center) - this.radius
            }
            intersectsSphere(t) {
                const e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }
            intersectsBox(t) {
                return t.intersectsSphere(this)
            }
            intersectsPlane(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(t, e) {
                const n = this.center.distanceToSquared(t);
                return e.copy(t),
                n > this.radius * this.radius && (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
                e
            }
            getBoundingBox(t) {
                return this.isEmpty() ? (t.makeEmpty(),
                t) : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t)
            }
            applyMatrix4(t) {
                return this.center.applyMatrix4(t),
                this.radius = this.radius * t.getMaxScaleOnAxis(),
                this
            }
            translate(t) {
                return this.center.add(t),
                this
            }
            expandByPoint(t) {
                _l.subVectors(t, this.center);
                const e = _l.lengthSq();
                if (e > this.radius * this.radius) {
                    const t = Math.sqrt(e)
                      , n = .5 * (t - this.radius);
                    this.center.add(_l.multiplyScalar(n / t)),
                    this.radius += n
                }
                return this
            }
            union(t) {
                return !0 === this.center.equals(t.center) ? xl.set(0, 0, 1).multiplyScalar(t.radius) : xl.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
                this.expandByPoint(yl.copy(t.center).add(xl)),
                this.expandByPoint(yl.copy(t.center).sub(xl)),
                this
            }
            equals(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const wl = new $a
          , Ml = new $a
          , Sl = new $a
          , Tl = new $a
          , El = new $a
          , Al = new $a
          , Cl = new $a;
        class Rl {
            constructor(t=new $a, e=new $a(0,0,-1)) {
                this.origin = t,
                this.direction = e
            }
            set(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            }
            copy(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            }
            at(t, e) {
                return e.copy(this.direction).multiplyScalar(t).add(this.origin)
            }
            lookAt(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                this
            }
            recast(t) {
                return this.origin.copy(this.at(t, wl)),
                this
            }
            closestPointToPoint(t, e) {
                e.subVectors(t, this.origin);
                const n = e.dot(this.direction);
                return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
            }
            distanceToPoint(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }
            distanceSqToPoint(t) {
                const e = wl.subVectors(t, this.origin).dot(this.direction);
                return e < 0 ? this.origin.distanceToSquared(t) : (wl.copy(this.direction).multiplyScalar(e).add(this.origin),
                wl.distanceToSquared(t))
            }
            distanceSqToSegment(t, e, n, i) {
                Ml.copy(t).add(e).multiplyScalar(.5),
                Sl.copy(e).sub(t).normalize(),
                Tl.copy(this.origin).sub(Ml);
                const r = .5 * t.distanceTo(e)
                  , s = -this.direction.dot(Sl)
                  , o = Tl.dot(this.direction)
                  , a = -Tl.dot(Sl)
                  , l = Tl.lengthSq()
                  , c = Math.abs(1 - s * s);
                let u, h, d, p;
                if (c > 0)
                    if (u = s * a - o,
                    h = s * o - a,
                    p = r * c,
                    u >= 0)
                        if (h >= -p)
                            if (h <= p) {
                                const t = 1 / c;
                                u *= t,
                                h *= t,
                                d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l
                            } else
                                h = r,
                                u = Math.max(0, -(s * h + o)),
                                d = -u * u + h * (h + 2 * a) + l;
                        else
                            h = -r,
                            u = Math.max(0, -(s * h + o)),
                            d = -u * u + h * (h + 2 * a) + l;
                    else
                        h <= -p ? (u = Math.max(0, -(-s * r + o)),
                        h = u > 0 ? -r : Math.min(Math.max(-r, -a), r),
                        d = -u * u + h * (h + 2 * a) + l) : h <= p ? (u = 0,
                        h = Math.min(Math.max(-r, -a), r),
                        d = h * (h + 2 * a) + l) : (u = Math.max(0, -(s * r + o)),
                        h = u > 0 ? r : Math.min(Math.max(-r, -a), r),
                        d = -u * u + h * (h + 2 * a) + l);
                else
                    h = s > 0 ? -r : r,
                    u = Math.max(0, -(s * h + o)),
                    d = -u * u + h * (h + 2 * a) + l;
                return n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
                i && i.copy(Sl).multiplyScalar(h).add(Ml),
                d
            }
            intersectSphere(t, e) {
                wl.subVectors(t.center, this.origin);
                const n = wl.dot(this.direction)
                  , i = wl.dot(wl) - n * n
                  , r = t.radius * t.radius;
                if (i > r)
                    return null;
                const s = Math.sqrt(r - i)
                  , o = n - s
                  , a = n + s;
                return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
            }
            intersectsSphere(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            }
            distanceToPlane(t) {
                const e = t.normal.dot(this.direction);
                if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }
            intersectPlane(t, e) {
                const n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }
            intersectsPlane(t) {
                const e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            }
            intersectBox(t, e) {
                let n, i, r, s, o, a;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , u = 1 / this.direction.z
                  , h = this.origin;
                return l >= 0 ? (n = (t.min.x - h.x) * l,
                i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l,
                i = (t.min.x - h.x) * l),
                c >= 0 ? (r = (t.min.y - h.y) * c,
                s = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c,
                s = (t.min.y - h.y) * c),
                n > s || r > i ? null : ((r > n || n != n) && (n = r),
                (s < i || i != i) && (i = s),
                u >= 0 ? (o = (t.min.z - h.z) * u,
                a = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u,
                a = (t.min.z - h.z) * u),
                n > a || o > i ? null : ((o > n || n != n) && (n = o),
                (a < i || i != i) && (i = a),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }
            intersectsBox(t) {
                return null !== this.intersectBox(t, wl)
            }
            intersectTriangle(t, e, n, i, r) {
                El.subVectors(e, t),
                Al.subVectors(n, t),
                Cl.crossVectors(El, Al);
                let s, o = this.direction.dot(Cl);
                if (o > 0) {
                    if (i)
                        return null;
                    s = 1
                } else {
                    if (!(o < 0))
                        return null;
                    s = -1,
                    o = -o
                }
                Tl.subVectors(this.origin, t);
                const a = s * this.direction.dot(Al.crossVectors(Tl, Al));
                if (a < 0)
                    return null;
                const l = s * this.direction.dot(El.cross(Tl));
                if (l < 0)
                    return null;
                if (a + l > o)
                    return null;
                const c = -s * Tl.dot(Cl);
                return c < 0 ? null : this.at(c / o, r)
            }
            applyMatrix4(t) {
                return this.origin.applyMatrix4(t),
                this.direction.transformDirection(t),
                this
            }
            equals(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Ll {
            constructor() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
            set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
                const g = this.elements;
                return g[0] = t,
                g[4] = e,
                g[8] = n,
                g[12] = i,
                g[1] = r,
                g[5] = s,
                g[9] = o,
                g[13] = a,
                g[2] = l,
                g[6] = c,
                g[10] = u,
                g[14] = h,
                g[3] = d,
                g[7] = p,
                g[11] = f,
                g[15] = m,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Ll).fromArray(this.elements)
            }
            copy(t) {
                const e = this.elements
                  , n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                e[9] = n[9],
                e[10] = n[10],
                e[11] = n[11],
                e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                e[15] = n[15],
                this
            }
            copyPosition(t) {
                const e = this.elements
                  , n = t.elements;
                return e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                this
            }
            setFromMatrix3(t) {
                const e = t.elements;
                return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(t, e, n) {
                return t.setFromMatrixColumn(this, 0),
                e.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(t) {
                const e = this.elements
                  , n = t.elements
                  , i = 1 / Pl.setFromMatrixColumn(t, 0).length()
                  , r = 1 / Pl.setFromMatrixColumn(t, 1).length()
                  , s = 1 / Pl.setFromMatrixColumn(t, 2).length();
                return e[0] = n[0] * i,
                e[1] = n[1] * i,
                e[2] = n[2] * i,
                e[3] = 0,
                e[4] = n[4] * r,
                e[5] = n[5] * r,
                e[6] = n[6] * r,
                e[7] = 0,
                e[8] = n[8] * s,
                e[9] = n[9] * s,
                e[10] = n[10] * s,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromEuler(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z
                  , s = Math.cos(n)
                  , o = Math.sin(n)
                  , a = Math.cos(i)
                  , l = Math.sin(i)
                  , c = Math.cos(r)
                  , u = Math.sin(r);
                if ("XYZ" === t.order) {
                    const t = s * c
                      , n = s * u
                      , i = o * c
                      , r = o * u;
                    e[0] = a * c,
                    e[4] = -a * u,
                    e[8] = l,
                    e[1] = n + i * l,
                    e[5] = t - r * l,
                    e[9] = -o * a,
                    e[2] = r - t * l,
                    e[6] = i + n * l,
                    e[10] = s * a
                } else if ("YXZ" === t.order) {
                    const t = a * c
                      , n = a * u
                      , i = l * c
                      , r = l * u;
                    e[0] = t + r * o,
                    e[4] = i * o - n,
                    e[8] = s * l,
                    e[1] = s * u,
                    e[5] = s * c,
                    e[9] = -o,
                    e[2] = n * o - i,
                    e[6] = r + t * o,
                    e[10] = s * a
                } else if ("ZXY" === t.order) {
                    const t = a * c
                      , n = a * u
                      , i = l * c
                      , r = l * u;
                    e[0] = t - r * o,
                    e[4] = -s * u,
                    e[8] = i + n * o,
                    e[1] = n + i * o,
                    e[5] = s * c,
                    e[9] = r - t * o,
                    e[2] = -s * l,
                    e[6] = o,
                    e[10] = s * a
                } else if ("ZYX" === t.order) {
                    const t = s * c
                      , n = s * u
                      , i = o * c
                      , r = o * u;
                    e[0] = a * c,
                    e[4] = i * l - n,
                    e[8] = t * l + r,
                    e[1] = a * u,
                    e[5] = r * l + t,
                    e[9] = n * l - i,
                    e[2] = -l,
                    e[6] = o * a,
                    e[10] = s * a
                } else if ("YZX" === t.order) {
                    const t = s * a
                      , n = s * l
                      , i = o * a
                      , r = o * l;
                    e[0] = a * c,
                    e[4] = r - t * u,
                    e[8] = i * u + n,
                    e[1] = u,
                    e[5] = s * c,
                    e[9] = -o * c,
                    e[2] = -l * c,
                    e[6] = n * u + i,
                    e[10] = t - r * u
                } else if ("XZY" === t.order) {
                    const t = s * a
                      , n = s * l
                      , i = o * a
                      , r = o * l;
                    e[0] = a * c,
                    e[4] = -u,
                    e[8] = l * c,
                    e[1] = t * u + r,
                    e[5] = s * c,
                    e[9] = n * u - i,
                    e[2] = i * u - n,
                    e[6] = o * c,
                    e[10] = r * u + t
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            }
            makeRotationFromQuaternion(t) {
                return this.compose(Il, t, Ol)
            }
            lookAt(t, e, n) {
                const i = this.elements;
                return zl.subVectors(t, e),
                0 === zl.lengthSq() && (zl.z = 1),
                zl.normalize(),
                Nl.crossVectors(n, zl),
                0 === Nl.lengthSq() && (1 === Math.abs(n.z) ? zl.x += 1e-4 : zl.z += 1e-4,
                zl.normalize(),
                Nl.crossVectors(n, zl)),
                Nl.normalize(),
                kl.crossVectors(zl, Nl),
                i[0] = Nl.x,
                i[4] = kl.x,
                i[8] = zl.x,
                i[1] = Nl.y,
                i[5] = kl.y,
                i[9] = zl.y,
                i[2] = Nl.z,
                i[6] = kl.z,
                i[10] = zl.z,
                this
            }
            multiply(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            }
            premultiply(t) {
                return this.multiplyMatrices(t, this)
            }
            multiplyMatrices(t, e) {
                const n = t.elements
                  , i = e.elements
                  , r = this.elements
                  , s = n[0]
                  , o = n[4]
                  , a = n[8]
                  , l = n[12]
                  , c = n[1]
                  , u = n[5]
                  , h = n[9]
                  , d = n[13]
                  , p = n[2]
                  , f = n[6]
                  , m = n[10]
                  , g = n[14]
                  , v = n[3]
                  , y = n[7]
                  , x = n[11]
                  , _ = n[15]
                  , b = i[0]
                  , w = i[4]
                  , M = i[8]
                  , S = i[12]
                  , T = i[1]
                  , E = i[5]
                  , A = i[9]
                  , C = i[13]
                  , R = i[2]
                  , L = i[6]
                  , P = i[10]
                  , D = i[14]
                  , I = i[3]
                  , O = i[7]
                  , N = i[11]
                  , k = i[15];
                return r[0] = s * b + o * T + a * R + l * I,
                r[4] = s * w + o * E + a * L + l * O,
                r[8] = s * M + o * A + a * P + l * N,
                r[12] = s * S + o * C + a * D + l * k,
                r[1] = c * b + u * T + h * R + d * I,
                r[5] = c * w + u * E + h * L + d * O,
                r[9] = c * M + u * A + h * P + d * N,
                r[13] = c * S + u * C + h * D + d * k,
                r[2] = p * b + f * T + m * R + g * I,
                r[6] = p * w + f * E + m * L + g * O,
                r[10] = p * M + f * A + m * P + g * N,
                r[14] = p * S + f * C + m * D + g * k,
                r[3] = v * b + y * T + x * R + _ * I,
                r[7] = v * w + y * E + x * L + _ * O,
                r[11] = v * M + y * A + x * P + _ * N,
                r[15] = v * S + y * C + x * D + _ * k,
                this
            }
            multiplyScalar(t) {
                const e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            }
            determinant() {
                const t = this.elements
                  , e = t[0]
                  , n = t[4]
                  , i = t[8]
                  , r = t[12]
                  , s = t[1]
                  , o = t[5]
                  , a = t[9]
                  , l = t[13]
                  , c = t[2]
                  , u = t[6]
                  , h = t[10]
                  , d = t[14];
                return t[3] * (+r * a * u - i * l * u - r * o * h + n * l * h + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * h + r * s * h - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * u - e * o * d - r * s * u + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * u + e * o * h + i * s * u - n * s * h + n * a * c)
            }
            transpose() {
                const t = this.elements;
                let e;
                return e = t[1],
                t[1] = t[4],
                t[4] = e,
                e = t[2],
                t[2] = t[8],
                t[8] = e,
                e = t[6],
                t[6] = t[9],
                t[9] = e,
                e = t[3],
                t[3] = t[12],
                t[12] = e,
                e = t[7],
                t[7] = t[13],
                t[13] = e,
                e = t[11],
                t[11] = t[14],
                t[14] = e,
                this
            }
            setPosition(t, e, n) {
                const i = this.elements;
                return t.isVector3 ? (i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z) : (i[12] = t,
                i[13] = e,
                i[14] = n),
                this
            }
            invert() {
                const t = this.elements
                  , e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3]
                  , s = t[4]
                  , o = t[5]
                  , a = t[6]
                  , l = t[7]
                  , c = t[8]
                  , u = t[9]
                  , h = t[10]
                  , d = t[11]
                  , p = t[12]
                  , f = t[13]
                  , m = t[14]
                  , g = t[15]
                  , v = u * m * l - f * h * l + f * a * d - o * m * d - u * a * g + o * h * g
                  , y = p * h * l - c * m * l - p * a * d + s * m * d + c * a * g - s * h * g
                  , x = c * f * l - p * u * l + p * o * d - s * f * d - c * o * g + s * u * g
                  , _ = p * u * a - c * f * a - p * o * h + s * f * h + c * o * m - s * u * m
                  , b = e * v + n * y + i * x + r * _;
                if (0 === b)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const w = 1 / b;
                return t[0] = v * w,
                t[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * w,
                t[2] = (o * m * r - f * a * r + f * i * l - n * m * l - o * i * g + n * a * g) * w,
                t[3] = (u * a * r - o * h * r - u * i * l + n * h * l + o * i * d - n * a * d) * w,
                t[4] = y * w,
                t[5] = (c * m * r - p * h * r + p * i * d - e * m * d - c * i * g + e * h * g) * w,
                t[6] = (p * a * r - s * m * r - p * i * l + e * m * l + s * i * g - e * a * g) * w,
                t[7] = (s * h * r - c * a * r + c * i * l - e * h * l - s * i * d + e * a * d) * w,
                t[8] = x * w,
                t[9] = (p * u * r - c * f * r - p * n * d + e * f * d + c * n * g - e * u * g) * w,
                t[10] = (s * f * r - p * o * r + p * n * l - e * f * l - s * n * g + e * o * g) * w,
                t[11] = (c * o * r - s * u * r - c * n * l + e * u * l + s * n * d - e * o * d) * w,
                t[12] = _ * w,
                t[13] = (c * f * i - p * u * i + p * n * h - e * f * h - c * n * m + e * u * m) * w,
                t[14] = (p * o * i - s * f * i - p * n * a + e * f * a + s * n * m - e * o * m) * w,
                t[15] = (s * u * i - c * o * i + c * n * a - e * u * a - s * n * h + e * o * h) * w,
                this
            }
            scale(t) {
                const e = this.elements
                  , n = t.x
                  , i = t.y
                  , r = t.z;
                return e[0] *= n,
                e[4] *= i,
                e[8] *= r,
                e[1] *= n,
                e[5] *= i,
                e[9] *= r,
                e[2] *= n,
                e[6] *= i,
                e[10] *= r,
                e[3] *= n,
                e[7] *= i,
                e[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const t = this.elements
                  , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                  , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                  , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            }
            makeTranslation(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(t) {
                const e = Math.cos(t)
                  , n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(t, e) {
                const n = Math.cos(e)
                  , i = Math.sin(e)
                  , r = 1 - n
                  , s = t.x
                  , o = t.y
                  , a = t.z
                  , l = r * s
                  , c = r * o;
                return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(t, e, n, i, r, s) {
                return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(t, e, n) {
                const i = this.elements
                  , r = e._x
                  , s = e._y
                  , o = e._z
                  , a = e._w
                  , l = r + r
                  , c = s + s
                  , u = o + o
                  , h = r * l
                  , d = r * c
                  , p = r * u
                  , f = s * c
                  , m = s * u
                  , g = o * u
                  , v = a * l
                  , y = a * c
                  , x = a * u
                  , _ = n.x
                  , b = n.y
                  , w = n.z;
                return i[0] = (1 - (f + g)) * _,
                i[1] = (d + x) * _,
                i[2] = (p - y) * _,
                i[3] = 0,
                i[4] = (d - x) * b,
                i[5] = (1 - (h + g)) * b,
                i[6] = (m + v) * b,
                i[7] = 0,
                i[8] = (p + y) * w,
                i[9] = (m - v) * w,
                i[10] = (1 - (h + f)) * w,
                i[11] = 0,
                i[12] = t.x,
                i[13] = t.y,
                i[14] = t.z,
                i[15] = 1,
                this
            }
            decompose(t, e, n) {
                const i = this.elements;
                let r = Pl.set(i[0], i[1], i[2]).length();
                const s = Pl.set(i[4], i[5], i[6]).length()
                  , o = Pl.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r),
                t.x = i[12],
                t.y = i[13],
                t.z = i[14],
                Dl.copy(this);
                const a = 1 / r
                  , l = 1 / s
                  , c = 1 / o;
                return Dl.elements[0] *= a,
                Dl.elements[1] *= a,
                Dl.elements[2] *= a,
                Dl.elements[4] *= l,
                Dl.elements[5] *= l,
                Dl.elements[6] *= l,
                Dl.elements[8] *= c,
                Dl.elements[9] *= c,
                Dl.elements[10] *= c,
                e.setFromRotationMatrix(Dl),
                n.x = r,
                n.y = s,
                n.z = o,
                this
            }
            makePerspective(t, e, n, i, r, s) {
                void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                const o = this.elements
                  , a = 2 * r / (e - t)
                  , l = 2 * r / (n - i)
                  , c = (e + t) / (e - t)
                  , u = (n + i) / (n - i)
                  , h = -(s + r) / (s - r)
                  , d = -2 * s * r / (s - r);
                return o[0] = a,
                o[4] = 0,
                o[8] = c,
                o[12] = 0,
                o[1] = 0,
                o[5] = l,
                o[9] = u,
                o[13] = 0,
                o[2] = 0,
                o[6] = 0,
                o[10] = h,
                o[14] = d,
                o[3] = 0,
                o[7] = 0,
                o[11] = -1,
                o[15] = 0,
                this
            }
            makeOrthographic(t, e, n, i, r, s) {
                const o = this.elements
                  , a = 1 / (e - t)
                  , l = 1 / (n - i)
                  , c = 1 / (s - r)
                  , u = (e + t) * a
                  , h = (n + i) * l
                  , d = (s + r) * c;
                return o[0] = 2 * a,
                o[4] = 0,
                o[8] = 0,
                o[12] = -u,
                o[1] = 0,
                o[5] = 2 * l,
                o[9] = 0,
                o[13] = -h,
                o[2] = 0,
                o[6] = 0,
                o[10] = -2 * c,
                o[14] = -d,
                o[3] = 0,
                o[7] = 0,
                o[11] = 0,
                o[15] = 1,
                this
            }
            equals(t) {
                const e = this.elements
                  , n = t.elements;
                for (let t = 0; t < 16; t++)
                    if (e[t] !== n[t])
                        return !1;
                return !0
            }
            fromArray(t, e=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = t[n + e];
                return this
            }
            toArray(t=[], e=0) {
                const n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t[e + 9] = n[9],
                t[e + 10] = n[10],
                t[e + 11] = n[11],
                t[e + 12] = n[12],
                t[e + 13] = n[13],
                t[e + 14] = n[14],
                t[e + 15] = n[15],
                t
            }
        }
        Ll.prototype.isMatrix4 = !0;
        const Pl = new $a
          , Dl = new Ll
          , Il = new $a(0,0,0)
          , Ol = new $a(1,1,1)
          , Nl = new $a
          , kl = new $a
          , zl = new $a
          , Hl = new Ll
          , Bl = new Qa;
        class Fl {
            constructor(t=0, e=0, n=0, i=Fl.DefaultOrder) {
                this._x = t,
                this._y = e,
                this._z = n,
                this._order = i
            }
            get x() {
                return this._x
            }
            set x(t) {
                this._x = t,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(t) {
                this._y = t,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(t) {
                this._z = t,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(t) {
                this._order = t,
                this._onChangeCallback()
            }
            set(t, e, n, i=this._order) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._order = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(t, e=this._order, n=!0) {
                const i = t.elements
                  , r = i[0]
                  , s = i[4]
                  , o = i[8]
                  , a = i[1]
                  , l = i[5]
                  , c = i[9]
                  , u = i[2]
                  , h = i[6]
                  , d = i[10];
                switch (e) {
                case "XYZ":
                    this._y = Math.asin(Ea(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d),
                    this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Ea(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d),
                    this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, r),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Ea(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d),
                    this._z = Math.atan2(-s, l)) : (this._y = 0,
                    this._z = Math.atan2(a, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Ea(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d),
                    this._z = Math.atan2(a, r)) : (this._x = 0,
                    this._z = Math.atan2(-s, l));
                    break;
                case "YZX":
                    this._z = Math.asin(Ea(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-u, r)) : (this._x = 0,
                    this._y = Math.atan2(o, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-Ea(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l),
                    this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-c, d),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                }
                return this._order = e,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(t, e, n) {
                return Hl.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(Hl, e, n)
            }
            setFromVector3(t, e=this._order) {
                return this.set(t.x, t.y, t.z, e)
            }
            reorder(t) {
                return Bl.setFromEuler(this),
                this.setFromQuaternion(Bl, t)
            }
            equals(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            }
            fromArray(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                void 0 !== t[3] && (this._order = t[3]),
                this._onChangeCallback(),
                this
            }
            toArray(t=[], e=0) {
                return t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            }
            toVector3(t) {
                return t ? t.set(this._x, this._y, this._z) : new $a(this._x,this._y,this._z)
            }
            _onChange(t) {
                return this._onChangeCallback = t,
                this
            }
            _onChangeCallback() {}
        }
        Fl.prototype.isEuler = !0,
        Fl.DefaultOrder = "XYZ",
        Fl.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
        class Ul {
            constructor() {
                this.mask = 1
            }
            set(t) {
                this.mask = (1 << t | 0) >>> 0
            }
            enable(t) {
                this.mask |= 1 << t | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(t) {
                this.mask ^= 1 << t | 0
            }
            disable(t) {
                this.mask &= ~(1 << t | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(t) {
                return 0 != (this.mask & t.mask)
            }
            isEnabled(t) {
                return 0 != (this.mask & (1 << t | 0))
            }
        }
        let Gl = 0;
        const Vl = new $a
          , Wl = new Qa
          , jl = new Ll
          , ql = new $a
          , Xl = new $a
          , Yl = new $a
          , Jl = new Qa
          , Zl = new $a(1,0,0)
          , Kl = new $a(0,1,0)
          , Ql = new $a(0,0,1)
          , $l = {
            type: "added"
        }
          , tc = {
            type: "removed"
        };
        class ec extends _a {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: Gl++
                }),
                this.uuid = Ta(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = ec.DefaultUp.clone();
                const t = new $a
                  , e = new Fl
                  , n = new Qa
                  , i = new $a(1,1,1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                }
                )),
                n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Ll
                    },
                    normalMatrix: {
                        value: new Oa
                    }
                }),
                this.matrix = new Ll,
                this.matrixWorld = new Ll,
                this.matrixAutoUpdate = ec.DefaultMatrixAutoUpdate,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new Ul,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(t),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(t) {
                return this.quaternion.premultiply(t),
                this
            }
            setRotationFromAxisAngle(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            }
            setRotationFromEuler(t) {
                this.quaternion.setFromEuler(t, !0)
            }
            setRotationFromMatrix(t) {
                this.quaternion.setFromRotationMatrix(t)
            }
            setRotationFromQuaternion(t) {
                this.quaternion.copy(t)
            }
            rotateOnAxis(t, e) {
                return Wl.setFromAxisAngle(t, e),
                this.quaternion.multiply(Wl),
                this
            }
            rotateOnWorldAxis(t, e) {
                return Wl.setFromAxisAngle(t, e),
                this.quaternion.premultiply(Wl),
                this
            }
            rotateX(t) {
                return this.rotateOnAxis(Zl, t)
            }
            rotateY(t) {
                return this.rotateOnAxis(Kl, t)
            }
            rotateZ(t) {
                return this.rotateOnAxis(Ql, t)
            }
            translateOnAxis(t, e) {
                return Vl.copy(t).applyQuaternion(this.quaternion),
                this.position.add(Vl.multiplyScalar(e)),
                this
            }
            translateX(t) {
                return this.translateOnAxis(Zl, t)
            }
            translateY(t) {
                return this.translateOnAxis(Kl, t)
            }
            translateZ(t) {
                return this.translateOnAxis(Ql, t)
            }
            localToWorld(t) {
                return t.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(t) {
                return t.applyMatrix4(jl.copy(this.matrixWorld).invert())
            }
            lookAt(t, e, n) {
                t.isVector3 ? ql.copy(t) : ql.set(t, e, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1),
                Xl.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? jl.lookAt(Xl, ql, this.up) : jl.lookAt(ql, Xl, this.up),
                this.quaternion.setFromRotationMatrix(jl),
                i && (jl.extractRotation(i.matrixWorld),
                Wl.setFromRotationMatrix(jl),
                this.quaternion.premultiply(Wl.invert()))
            }
            add(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.add(arguments[t]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                t.parent = this,
                this.children.push(t),
                t.dispatchEvent($l)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                this)
            }
            remove(t) {
                if (arguments.length > 1) {
                    for (let t = 0; t < arguments.length; t++)
                        this.remove(arguments[t]);
                    return this
                }
                const e = this.children.indexOf(t);
                return -1 !== e && (t.parent = null,
                this.children.splice(e, 1),
                t.dispatchEvent(tc)),
                this
            }
            removeFromParent() {
                const t = this.parent;
                return null !== t && t.remove(this),
                this
            }
            clear() {
                for (let t = 0; t < this.children.length; t++) {
                    const e = this.children[t];
                    e.parent = null,
                    e.dispatchEvent(tc)
                }
                return this.children.length = 0,
                this
            }
            attach(t) {
                return this.updateWorldMatrix(!0, !1),
                jl.copy(this.matrixWorld).invert(),
                null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
                jl.multiply(t.parent.matrixWorld)),
                t.applyMatrix4(jl),
                this.add(t),
                t.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(t) {
                return this.getObjectByProperty("id", t)
            }
            getObjectByName(t) {
                return this.getObjectByProperty("name", t)
            }
            getObjectByProperty(t, e) {
                if (this[t] === e)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(t, e);
                    if (void 0 !== i)
                        return i
                }
            }
            getWorldPosition(t) {
                return this.updateWorldMatrix(!0, !1),
                t.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Xl, t, Yl),
                t
            }
            getWorldScale(t) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(Xl, Jl, t),
                t
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            }
            raycast() {}
            traverse(t) {
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverse(t)
            }
            traverseVisible(t) {
                if (!1 === this.visible)
                    return;
                t(this);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].traverseVisible(t)
            }
            traverseAncestors(t) {
                const e = this.parent;
                null !== e && (t(e),
                e.traverseAncestors(t))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(t) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                t = !0);
                const e = this.children;
                for (let n = 0, i = e.length; n < i; n++)
                    e[n].updateMatrixWorld(t)
            }
            updateWorldMatrix(t, e) {
                const n = this.parent;
                if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                !0 === e) {
                    const t = this.children;
                    for (let e = 0, n = t.length; e < n; e++)
                        t[e].updateWorldMatrix(!1, !0)
                }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t
                  , n = {};
                e && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                },
                n.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                function r(e, n) {
                    return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                    n.uuid
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
                i.layers = this.layers.mask,
                i.matrix = this.matrix.toArray(),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh && (i.type = "InstancedMesh",
                i.count = this.count,
                i.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)),
                    this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(t).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(t.geometries, this.geometry);
                    const e = this.geometry.parameters;
                    if (void 0 !== e && void 0 !== e.shapes) {
                        const n = e.shapes;
                        if (Array.isArray(n))
                            for (let e = 0, i = n.length; e < i; e++) {
                                const i = n[e];
                                r(t.shapes, i)
                            }
                        else
                            r(t.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                i.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
                i.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const e = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            e.push(r(t.materials, this.material[n]));
                        i.material = e
                    } else
                        i.material = r(t.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let e = 0; e < this.children.length; e++)
                        i.children.push(this.children[e].toJSON(t).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let e = 0; e < this.animations.length; e++) {
                        const n = this.animations[e];
                        i.animations.push(r(t.animations, n))
                    }
                }
                if (e) {
                    const e = s(t.geometries)
                      , i = s(t.materials)
                      , r = s(t.textures)
                      , o = s(t.images)
                      , a = s(t.shapes)
                      , l = s(t.skeletons)
                      , c = s(t.animations);
                    e.length > 0 && (n.geometries = e),
                    i.length > 0 && (n.materials = i),
                    r.length > 0 && (n.textures = r),
                    o.length > 0 && (n.images = o),
                    a.length > 0 && (n.shapes = a),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c)
                }
                return n.object = i,
                n;
                function s(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
            }
            clone(t) {
                return (new this.constructor).copy(this, t)
            }
            copy(t, e=!0) {
                if (this.name = t.name,
                this.up.copy(t.up),
                this.position.copy(t.position),
                this.rotation.order = t.rotation.order,
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                this.layers.mask = t.layers.mask,
                this.visible = t.visible,
                this.castShadow = t.castShadow,
                this.receiveShadow = t.receiveShadow,
                this.frustumCulled = t.frustumCulled,
                this.renderOrder = t.renderOrder,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                !0 === e)
                    for (let e = 0; e < t.children.length; e++) {
                        const n = t.children[e];
                        this.add(n.clone())
                    }
                return this
            }
        }
        ec.DefaultUp = new $a(0,1,0),
        ec.DefaultMatrixAutoUpdate = !0,
        ec.prototype.isObject3D = !0;
        const nc = new $a
          , ic = new $a
          , rc = new $a
          , sc = new $a
          , oc = new $a
          , ac = new $a
          , lc = new $a
          , cc = new $a
          , uc = new $a
          , hc = new $a;
        class dc {
            constructor(t=new $a, e=new $a, n=new $a) {
                this.a = t,
                this.b = e,
                this.c = n
            }
            static getNormal(t, e, n, i) {
                i.subVectors(n, e),
                nc.subVectors(t, e),
                i.cross(nc);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(t, e, n, i, r) {
                nc.subVectors(i, e),
                ic.subVectors(n, e),
                rc.subVectors(t, e);
                const s = nc.dot(nc)
                  , o = nc.dot(ic)
                  , a = nc.dot(rc)
                  , l = ic.dot(ic)
                  , c = ic.dot(rc)
                  , u = s * l - o * o;
                if (0 === u)
                    return r.set(-2, -1, -1);
                const h = 1 / u
                  , d = (l * a - o * c) * h
                  , p = (s * c - o * a) * h;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(t, e, n, i) {
                return this.getBarycoord(t, e, n, i, sc),
                sc.x >= 0 && sc.y >= 0 && sc.x + sc.y <= 1
            }
            static getUV(t, e, n, i, r, s, o, a) {
                return this.getBarycoord(t, e, n, i, sc),
                a.set(0, 0),
                a.addScaledVector(r, sc.x),
                a.addScaledVector(s, sc.y),
                a.addScaledVector(o, sc.z),
                a
            }
            static isFrontFacing(t, e, n, i) {
                return nc.subVectors(n, e),
                ic.subVectors(t, e),
                nc.cross(ic).dot(i) < 0
            }
            set(t, e, n) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(t, e, n, i) {
                return this.a.copy(t[e]),
                this.b.copy(t[n]),
                this.c.copy(t[i]),
                this
            }
            setFromAttributeAndIndices(t, e, n, i) {
                return this.a.fromBufferAttribute(t, e),
                this.b.fromBufferAttribute(t, n),
                this.c.fromBufferAttribute(t, i),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            }
            getArea() {
                return nc.subVectors(this.c, this.b),
                ic.subVectors(this.a, this.b),
                .5 * nc.cross(ic).length()
            }
            getMidpoint(t) {
                return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(t) {
                return dc.getNormal(this.a, this.b, this.c, t)
            }
            getPlane(t) {
                return t.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(t, e) {
                return dc.getBarycoord(t, this.a, this.b, this.c, e)
            }
            getUV(t, e, n, i, r) {
                return dc.getUV(t, this.a, this.b, this.c, e, n, i, r)
            }
            containsPoint(t) {
                return dc.containsPoint(t, this.a, this.b, this.c)
            }
            isFrontFacing(t) {
                return dc.isFrontFacing(this.a, this.b, this.c, t)
            }
            intersectsBox(t) {
                return t.intersectsTriangle(this)
            }
            closestPointToPoint(t, e) {
                const n = this.a
                  , i = this.b
                  , r = this.c;
                let s, o;
                oc.subVectors(i, n),
                ac.subVectors(r, n),
                cc.subVectors(t, n);
                const a = oc.dot(cc)
                  , l = ac.dot(cc);
                if (a <= 0 && l <= 0)
                    return e.copy(n);
                uc.subVectors(t, i);
                const c = oc.dot(uc)
                  , u = ac.dot(uc);
                if (c >= 0 && u <= c)
                    return e.copy(i);
                const h = a * u - c * l;
                if (h <= 0 && a >= 0 && c <= 0)
                    return s = a / (a - c),
                    e.copy(n).addScaledVector(oc, s);
                hc.subVectors(t, r);
                const d = oc.dot(hc)
                  , p = ac.dot(hc);
                if (p >= 0 && d <= p)
                    return e.copy(r);
                const f = d * l - a * p;
                if (f <= 0 && l >= 0 && p <= 0)
                    return o = l / (l - p),
                    e.copy(n).addScaledVector(ac, o);
                const m = c * p - d * u;
                if (m <= 0 && u - c >= 0 && d - p >= 0)
                    return lc.subVectors(r, i),
                    o = (u - c) / (u - c + (d - p)),
                    e.copy(i).addScaledVector(lc, o);
                const g = 1 / (m + f + h);
                return s = f * g,
                o = h * g,
                e.copy(n).addScaledVector(oc, s).addScaledVector(ac, o)
            }
            equals(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }
        let pc = 0;
        class fc extends _a {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: pc++
                }),
                this.uuid = Ta(),
                this.name = "",
                this.type = "Material",
                this.fog = !0,
                this.blending = 1,
                this.side = 0,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.blendSrc = 204,
                this.blendDst = 205,
                this.blendEquation = ko,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = 3,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = 519,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = ma,
                this.stencilZFail = ma,
                this.stencilZPass = ma,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(t) {
                this._alphaTest > 0 != t > 0 && this.version++,
                this._alphaTest = t
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(t) {
                if (void 0 !== t)
                    for (const e in t) {
                        const n = t[e];
                        if (void 0 === n) {
                            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                            continue
                        }
                        if ("shading" === e) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = 1 === n;
                            continue
                        }
                        const i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    }
            }
            toJSON(t) {
                const e = void 0 === t || "string" == typeof t;
                e && (t = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(t) {
                    const e = [];
                    for (const n in t) {
                        const i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                void 0 !== this.sheen && (n.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                1 !== this.blending && (n.blending = this.blending),
                0 !== this.side && (n.side = this.side),
                this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = this.transparent),
                n.depthFunc = this.depthFunc,
                n.depthTest = this.depthTest,
                n.depthWrite = this.depthWrite,
                n.colorWrite = this.colorWrite,
                n.stencilWrite = this.stencilWrite,
                n.stencilWriteMask = this.stencilWriteMask,
                n.stencilFunc = this.stencilFunc,
                n.stencilRef = this.stencilRef,
                n.stencilFuncMask = this.stencilFuncMask,
                n.stencilFail = this.stencilFail,
                n.stencilZFail = this.stencilZFail,
                n.stencilZPass = this.stencilZPass,
                this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
                !0 === this.wireframe && (n.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = this.flatShading),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
                e) {
                    const e = i(t.textures)
                      , r = i(t.images);
                    e.length > 0 && (n.textures = e),
                    r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.name = t.name,
                this.fog = t.fog,
                this.blending = t.blending,
                this.side = t.side,
                this.vertexColors = t.vertexColors,
                this.opacity = t.opacity,
                this.transparent = t.transparent,
                this.blendSrc = t.blendSrc,
                this.blendDst = t.blendDst,
                this.blendEquation = t.blendEquation,
                this.blendSrcAlpha = t.blendSrcAlpha,
                this.blendDstAlpha = t.blendDstAlpha,
                this.blendEquationAlpha = t.blendEquationAlpha,
                this.depthFunc = t.depthFunc,
                this.depthTest = t.depthTest,
                this.depthWrite = t.depthWrite,
                this.stencilWriteMask = t.stencilWriteMask,
                this.stencilFunc = t.stencilFunc,
                this.stencilRef = t.stencilRef,
                this.stencilFuncMask = t.stencilFuncMask,
                this.stencilFail = t.stencilFail,
                this.stencilZFail = t.stencilZFail,
                this.stencilZPass = t.stencilZPass,
                this.stencilWrite = t.stencilWrite;
                const e = t.clippingPlanes;
                let n = null;
                if (null !== e) {
                    const t = e.length;
                    n = new Array(t);
                    for (let i = 0; i !== t; ++i)
                        n[i] = e[i].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = t.clipIntersection,
                this.clipShadows = t.clipShadows,
                this.shadowSide = t.shadowSide,
                this.colorWrite = t.colorWrite,
                this.precision = t.precision,
                this.polygonOffset = t.polygonOffset,
                this.polygonOffsetFactor = t.polygonOffsetFactor,
                this.polygonOffsetUnits = t.polygonOffsetUnits,
                this.dithering = t.dithering,
                this.alphaTest = t.alphaTest,
                this.alphaToCoverage = t.alphaToCoverage,
                this.premultipliedAlpha = t.premultipliedAlpha,
                this.visible = t.visible,
                this.toneMapped = t.toneMapped,
                this.userData = JSON.parse(JSON.stringify(t.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(t) {
                !0 === t && this.version++
            }
        }
        fc.prototype.isMaterial = !0;
        class mc extends fc {
            constructor(t) {
                super(),
                this.type = "MeshBasicMaterial",
                this.color = new Va(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this
            }
        }
        mc.prototype.isMeshBasicMaterial = !0;
        const gc = new $a
          , vc = new Ia;
        class yc {
            constructor(t, e, n) {
                if (Array.isArray(t))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "",
                this.array = t,
                this.itemSize = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.normalized = !0 === n,
                this.usage = ga,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.name = t.name,
                this.array = new t.array.constructor(t.array),
                this.itemSize = t.itemSize,
                this.count = t.count,
                this.normalized = t.normalized,
                this.usage = t.usage,
                this
            }
            copyAt(t, e, n) {
                t *= this.itemSize,
                n *= e.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[t + i] = e.array[n + i];
                return this
            }
            copyArray(t) {
                return this.array.set(t),
                this
            }
            copyColorsArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                    r = new Va),
                    e[n++] = r.r,
                    e[n++] = r.g,
                    e[n++] = r.b
                }
                return this
            }
            copyVector2sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                    r = new Ia),
                    e[n++] = r.x,
                    e[n++] = r.y
                }
                return this
            }
            copyVector3sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                    r = new $a),
                    e[n++] = r.x,
                    e[n++] = r.y,
                    e[n++] = r.z
                }
                return this
            }
            copyVector4sArray(t) {
                const e = this.array;
                let n = 0;
                for (let i = 0, r = t.length; i < r; i++) {
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                    r = new Ja),
                    e[n++] = r.x,
                    e[n++] = r.y,
                    e[n++] = r.z,
                    e[n++] = r.w
                }
                return this
            }
            applyMatrix3(t) {
                if (2 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        vc.fromBufferAttribute(this, e),
                        vc.applyMatrix3(t),
                        this.setXY(e, vc.x, vc.y);
                else if (3 === this.itemSize)
                    for (let e = 0, n = this.count; e < n; e++)
                        gc.fromBufferAttribute(this, e),
                        gc.applyMatrix3(t),
                        this.setXYZ(e, gc.x, gc.y, gc.z);
                return this
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    gc.x = this.getX(e),
                    gc.y = this.getY(e),
                    gc.z = this.getZ(e),
                    gc.applyMatrix4(t),
                    this.setXYZ(e, gc.x, gc.y, gc.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    gc.x = this.getX(e),
                    gc.y = this.getY(e),
                    gc.z = this.getZ(e),
                    gc.applyNormalMatrix(t),
                    this.setXYZ(e, gc.x, gc.y, gc.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    gc.x = this.getX(e),
                    gc.y = this.getY(e),
                    gc.z = this.getZ(e),
                    gc.transformDirection(t),
                    this.setXYZ(e, gc.x, gc.y, gc.z);
                return this
            }
            set(t, e=0) {
                return this.array.set(t, e),
                this
            }
            getX(t) {
                return this.array[t * this.itemSize]
            }
            setX(t, e) {
                return this.array[t * this.itemSize] = e,
                this
            }
            getY(t) {
                return this.array[t * this.itemSize + 1]
            }
            setY(t, e) {
                return this.array[t * this.itemSize + 1] = e,
                this
            }
            getZ(t) {
                return this.array[t * this.itemSize + 2]
            }
            setZ(t, e) {
                return this.array[t * this.itemSize + 2] = e,
                this
            }
            getW(t) {
                return this.array[t * this.itemSize + 3]
            }
            setW(t, e) {
                return this.array[t * this.itemSize + 3] = e,
                this
            }
            setXY(t, e, n) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, i) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this
            }
            setXYZW(t, e, n, i, r) {
                return t *= this.itemSize,
                this.array[t + 0] = e,
                this.array[t + 1] = n,
                this.array[t + 2] = i,
                this.array[t + 3] = r,
                this
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const t = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (t.name = this.name),
                this.usage !== ga && (t.usage = this.usage),
                0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange),
                t
            }
        }
        yc.prototype.isBufferAttribute = !0;
        class xc extends yc {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        class _c extends yc {
            constructor(t, e, n) {
                super(new Uint32Array(t), e, n)
            }
        }
        (class extends yc {
            constructor(t, e, n) {
                super(new Uint16Array(t), e, n)
            }
        }
        ).prototype.isFloat16BufferAttribute = !0;
        class bc extends yc {
            constructor(t, e, n) {
                super(new Float32Array(t), e, n)
            }
        }
        let wc = 0;
        const Mc = new Ll
          , Sc = new ec
          , Tc = new $a
          , Ec = new nl
          , Ac = new nl
          , Cc = new $a;
        class Rc extends _a {
            constructor() {
                super(),
                Object.defineProperty(this, "id", {
                    value: wc++
                }),
                this.uuid = Ta(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(t) {
                return Array.isArray(t) ? this.index = new (Na(t) ? _c : xc)(t,1) : this.index = t,
                this
            }
            getAttribute(t) {
                return this.attributes[t]
            }
            setAttribute(t, e) {
                return this.attributes[t] = e,
                this
            }
            deleteAttribute(t) {
                return delete this.attributes[t],
                this
            }
            hasAttribute(t) {
                return void 0 !== this.attributes[t]
            }
            addGroup(t, e, n=0) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            }
            applyMatrix4(t) {
                const e = this.attributes.position;
                void 0 !== e && (e.applyMatrix4(t),
                e.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const e = (new Oa).getNormalMatrix(t);
                    n.applyNormalMatrix(e),
                    n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(t),
                i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(t) {
                return Mc.makeRotationFromQuaternion(t),
                this.applyMatrix4(Mc),
                this
            }
            rotateX(t) {
                return Mc.makeRotationX(t),
                this.applyMatrix4(Mc),
                this
            }
            rotateY(t) {
                return Mc.makeRotationY(t),
                this.applyMatrix4(Mc),
                this
            }
            rotateZ(t) {
                return Mc.makeRotationZ(t),
                this.applyMatrix4(Mc),
                this
            }
            translate(t, e, n) {
                return Mc.makeTranslation(t, e, n),
                this.applyMatrix4(Mc),
                this
            }
            scale(t, e, n) {
                return Mc.makeScale(t, e, n),
                this.applyMatrix4(Mc),
                this
            }
            lookAt(t) {
                return Sc.lookAt(t),
                Sc.updateMatrix(),
                this.applyMatrix4(Sc.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Tc).negate(),
                this.translate(Tc.x, Tc.y, Tc.z),
                this
            }
            setFromPoints(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    e.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new bc(e,3)),
                this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new nl);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new $a(-1 / 0,-1 / 0,-1 / 0), new $a(1 / 0,1 / 0,1 / 0));
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Ec.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Cc.addVectors(this.boundingBox.min, Ec.min),
                            this.boundingBox.expandByPoint(Cc),
                            Cc.addVectors(this.boundingBox.max, Ec.max),
                            this.boundingBox.expandByPoint(Cc)) : (this.boundingBox.expandByPoint(Ec.min),
                            this.boundingBox.expandByPoint(Ec.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new bl);
                const t = this.attributes.position
                  , e = this.morphAttributes.position;
                if (t && t.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new $a, 1 / 0);
                if (t) {
                    const n = this.boundingSphere.center;
                    if (Ec.setFromBufferAttribute(t),
                    e)
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            Ac.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Cc.addVectors(Ec.min, Ac.min),
                            Ec.expandByPoint(Cc),
                            Cc.addVectors(Ec.max, Ac.max),
                            Ec.expandByPoint(Cc)) : (Ec.expandByPoint(Ac.min),
                            Ec.expandByPoint(Ac.max))
                        }
                    Ec.getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.count; e < r; e++)
                        Cc.fromBufferAttribute(t, e),
                        i = Math.max(i, n.distanceToSquared(Cc));
                    if (e)
                        for (let r = 0, s = e.length; r < s; r++) {
                            const s = e[r]
                              , o = this.morphTargetsRelative;
                            for (let e = 0, r = s.count; e < r; e++)
                                Cc.fromBufferAttribute(s, e),
                                o && (Tc.fromBufferAttribute(t, e),
                                Cc.add(Tc)),
                                i = Math.max(i, n.distanceToSquared(Cc))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const t = this.index
                  , e = this.attributes;
                if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.array
                  , i = e.position.array
                  , r = e.normal.array
                  , s = e.uv.array
                  , o = i.length / 3;
                void 0 === e.tangent && this.setAttribute("tangent", new yc(new Float32Array(4 * o),4));
                const a = e.tangent.array
                  , l = []
                  , c = [];
                for (let t = 0; t < o; t++)
                    l[t] = new $a,
                    c[t] = new $a;
                const u = new $a
                  , h = new $a
                  , d = new $a
                  , p = new Ia
                  , f = new Ia
                  , m = new Ia
                  , g = new $a
                  , v = new $a;
                function y(t, e, n) {
                    u.fromArray(i, 3 * t),
                    h.fromArray(i, 3 * e),
                    d.fromArray(i, 3 * n),
                    p.fromArray(s, 2 * t),
                    f.fromArray(s, 2 * e),
                    m.fromArray(s, 2 * n),
                    h.sub(u),
                    d.sub(u),
                    f.sub(p),
                    m.sub(p);
                    const r = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r),
                    v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r),
                    l[t].add(g),
                    l[e].add(g),
                    l[n].add(g),
                    c[t].add(v),
                    c[e].add(v),
                    c[n].add(v))
                }
                let x = this.groups;
                0 === x.length && (x = [{
                    start: 0,
                    count: n.length
                }]);
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t]
                      , i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3)
                        y(n[t + 0], n[t + 1], n[t + 2])
                }
                const _ = new $a
                  , b = new $a
                  , w = new $a
                  , M = new $a;
                function S(t) {
                    w.fromArray(r, 3 * t),
                    M.copy(w);
                    const e = l[t];
                    _.copy(e),
                    _.sub(w.multiplyScalar(w.dot(e))).normalize(),
                    b.crossVectors(M, e);
                    const n = b.dot(c[t]) < 0 ? -1 : 1;
                    a[4 * t] = _.x,
                    a[4 * t + 1] = _.y,
                    a[4 * t + 2] = _.z,
                    a[4 * t + 3] = n
                }
                for (let t = 0, e = x.length; t < e; ++t) {
                    const e = x[t]
                      , i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3)
                        S(n[t + 0]),
                        S(n[t + 1]),
                        S(n[t + 2])
                }
            }
            computeVertexNormals() {
                const t = this.index
                  , e = this.getAttribute("position");
                if (void 0 !== e) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new yc(new Float32Array(3 * e.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let t = 0, e = n.count; t < e; t++)
                            n.setXYZ(t, 0, 0, 0);
                    const i = new $a
                      , r = new $a
                      , s = new $a
                      , o = new $a
                      , a = new $a
                      , l = new $a
                      , c = new $a
                      , u = new $a;
                    if (t)
                        for (let h = 0, d = t.count; h < d; h += 3) {
                            const d = t.getX(h + 0)
                              , p = t.getX(h + 1)
                              , f = t.getX(h + 2);
                            i.fromBufferAttribute(e, d),
                            r.fromBufferAttribute(e, p),
                            s.fromBufferAttribute(e, f),
                            c.subVectors(s, r),
                            u.subVectors(i, r),
                            c.cross(u),
                            o.fromBufferAttribute(n, d),
                            a.fromBufferAttribute(n, p),
                            l.fromBufferAttribute(n, f),
                            o.add(c),
                            a.add(c),
                            l.add(c),
                            n.setXYZ(d, o.x, o.y, o.z),
                            n.setXYZ(p, a.x, a.y, a.z),
                            n.setXYZ(f, l.x, l.y, l.z)
                        }
                    else
                        for (let t = 0, o = e.count; t < o; t += 3)
                            i.fromBufferAttribute(e, t + 0),
                            r.fromBufferAttribute(e, t + 1),
                            s.fromBufferAttribute(e, t + 2),
                            c.subVectors(s, r),
                            u.subVectors(i, r),
                            c.cross(u),
                            n.setXYZ(t + 0, c.x, c.y, c.z),
                            n.setXYZ(t + 1, c.x, c.y, c.z),
                            n.setXYZ(t + 2, c.x, c.y, c.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            merge(t, e) {
                if (!t || !t.isBufferGeometry)
                    return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                const n = this.attributes;
                for (const i in n) {
                    if (void 0 === t.attributes[i])
                        continue;
                    const r = n[i].array
                      , s = t.attributes[i]
                      , o = s.array
                      , a = s.itemSize * e
                      , l = Math.min(o.length, r.length - a);
                    for (let t = 0, e = a; t < l; t++,
                    e++)
                        r[e] = o[t]
                }
                return this
            }
            normalizeNormals() {
                const t = this.attributes.normal;
                for (let e = 0, n = t.count; e < n; e++)
                    Cc.fromBufferAttribute(t, e),
                    Cc.normalize(),
                    t.setXYZ(e, Cc.x, Cc.y, Cc.z)
            }
            toNonIndexed() {
                function t(t, e) {
                    const n = t.array
                      , i = t.itemSize
                      , r = t.normalized
                      , s = new n.constructor(e.length * i);
                    let o = 0
                      , a = 0;
                    for (let r = 0, l = e.length; r < l; r++) {
                        o = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                        for (let t = 0; t < i; t++)
                            s[a++] = n[o++]
                    }
                    return new yc(s,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const e = new Rc
                  , n = this.index.array
                  , i = this.attributes;
                for (const r in i) {
                    const s = t(i[r], n);
                    e.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = []
                      , o = r[i];
                    for (let e = 0, i = o.length; e < i; e++) {
                        const i = t(o[e], n);
                        s.push(i)
                    }
                    e.morphAttributes[i] = s
                }
                e.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.addGroup(n.start, n.count, n.materialIndex)
                }
                return e
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid,
                t.type = this.type,
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 && (t.userData = this.userData),
                void 0 !== this.parameters) {
                    const e = this.parameters;
                    for (const n in e)
                        void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                const e = this.index;
                null !== e && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                const n = this.attributes;
                for (const e in n) {
                    const i = n[e];
                    t.data.attributes[e] = i.toJSON(t.data)
                }
                const i = {};
                let r = !1;
                for (const e in this.morphAttributes) {
                    const n = this.morphAttributes[e]
                      , s = [];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        s.push(i.toJSON(t.data))
                    }
                    s.length > 0 && (i[e] = s,
                    r = !0)
                }
                r && (t.data.morphAttributes = i,
                t.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                const o = this.boundingSphere;
                return null !== o && (t.data.boundingSphere = {
                    center: o.center.toArray(),
                    radius: o.radius
                }),
                t
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const e = {};
                this.name = t.name;
                const n = t.index;
                null !== n && this.setIndex(n.clone(e));
                const i = t.attributes;
                for (const t in i) {
                    const n = i[t];
                    this.setAttribute(t, n.clone(e))
                }
                const r = t.morphAttributes;
                for (const t in r) {
                    const n = []
                      , i = r[t];
                    for (let t = 0, r = i.length; t < r; t++)
                        n.push(i[t].clone(e));
                    this.morphAttributes[t] = n
                }
                this.morphTargetsRelative = t.morphTargetsRelative;
                const s = t.groups;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const o = t.boundingBox;
                null !== o && (this.boundingBox = o.clone());
                const a = t.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()),
                this.drawRange.start = t.drawRange.start,
                this.drawRange.count = t.drawRange.count,
                this.userData = t.userData,
                void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        Rc.prototype.isBufferGeometry = !0;
        const Lc = new Ll
          , Pc = new Rl
          , Dc = new bl
          , Ic = new $a
          , Oc = new $a
          , Nc = new $a
          , kc = new $a
          , zc = new $a
          , Hc = new $a
          , Bc = new $a
          , Fc = new $a
          , Uc = new $a
          , Gc = new Ia
          , Vc = new Ia
          , Wc = new Ia
          , jc = new $a
          , qc = new $a;
        class Xc extends ec {
            constructor(t=new Rc, e=new mc) {
                super(),
                this.type = "Mesh",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
                void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.material
                  , r = this.matrixWorld;
                if (void 0 === i)
                    return;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                Dc.copy(n.boundingSphere),
                Dc.applyMatrix4(r),
                !1 === t.ray.intersectsSphere(Dc))
                    return;
                if (Lc.copy(r).invert(),
                Pc.copy(t.ray).applyMatrix4(Lc),
                null !== n.boundingBox && !1 === Pc.intersectsBox(n.boundingBox))
                    return;
                let s;
                if (n.isBufferGeometry) {
                    const r = n.index
                      , o = n.attributes.position
                      , a = n.morphAttributes.position
                      , l = n.morphTargetsRelative
                      , c = n.attributes.uv
                      , u = n.attributes.uv2
                      , h = n.groups
                      , d = n.drawRange;
                    if (null !== r)
                        if (Array.isArray(i))
                            for (let n = 0, p = h.length; n < p; n++) {
                                const p = h[n]
                                  , f = i[p.materialIndex];
                                for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                    const i = r.getX(n)
                                      , h = r.getX(n + 1)
                                      , d = r.getX(n + 2);
                                    s = Yc(this, f, t, Pc, o, a, l, c, u, i, h, d),
                                    s && (s.faceIndex = Math.floor(n / 3),
                                    s.face.materialIndex = p.materialIndex,
                                    e.push(s))
                                }
                            }
                        else
                            for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
                                const h = r.getX(n)
                                  , d = r.getX(n + 1)
                                  , p = r.getX(n + 2);
                                s = Yc(this, i, t, Pc, o, a, l, c, u, h, d, p),
                                s && (s.faceIndex = Math.floor(n / 3),
                                e.push(s))
                            }
                    else if (void 0 !== o)
                        if (Array.isArray(i))
                            for (let n = 0, r = h.length; n < r; n++) {
                                const r = h[n]
                                  , p = i[r.materialIndex];
                                for (let n = Math.max(r.start, d.start), i = Math.min(o.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3)
                                    s = Yc(this, p, t, Pc, o, a, l, c, u, n, n + 1, n + 2),
                                    s && (s.faceIndex = Math.floor(n / 3),
                                    s.face.materialIndex = r.materialIndex,
                                    e.push(s))
                            }
                        else
                            for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3)
                                s = Yc(this, i, t, Pc, o, a, l, c, u, n, n + 1, n + 2),
                                s && (s.faceIndex = Math.floor(n / 3),
                                e.push(s))
                } else
                    n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
        function Yc(t, e, n, i, r, s, o, a, l, c, u, h) {
            Ic.fromBufferAttribute(r, c),
            Oc.fromBufferAttribute(r, u),
            Nc.fromBufferAttribute(r, h);
            const d = t.morphTargetInfluences;
            if (s && d) {
                Bc.set(0, 0, 0),
                Fc.set(0, 0, 0),
                Uc.set(0, 0, 0);
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = d[t]
                      , n = s[t];
                    0 !== e && (kc.fromBufferAttribute(n, c),
                    zc.fromBufferAttribute(n, u),
                    Hc.fromBufferAttribute(n, h),
                    o ? (Bc.addScaledVector(kc, e),
                    Fc.addScaledVector(zc, e),
                    Uc.addScaledVector(Hc, e)) : (Bc.addScaledVector(kc.sub(Ic), e),
                    Fc.addScaledVector(zc.sub(Oc), e),
                    Uc.addScaledVector(Hc.sub(Nc), e)))
                }
                Ic.add(Bc),
                Oc.add(Fc),
                Nc.add(Uc)
            }
            t.isSkinnedMesh && (t.boneTransform(c, Ic),
            t.boneTransform(u, Oc),
            t.boneTransform(h, Nc));
            const p = function(t, e, n, i, r, s, o, a) {
                let l;
                if (l = 1 === e.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 2 !== e.side, a),
                null === l)
                    return null;
                qc.copy(a),
                qc.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(qc);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: qc.clone(),
                    object: t
                }
            }(t, e, n, i, Ic, Oc, Nc, jc);
            if (p) {
                a && (Gc.fromBufferAttribute(a, c),
                Vc.fromBufferAttribute(a, u),
                Wc.fromBufferAttribute(a, h),
                p.uv = dc.getUV(jc, Ic, Oc, Nc, Gc, Vc, Wc, new Ia)),
                l && (Gc.fromBufferAttribute(l, c),
                Vc.fromBufferAttribute(l, u),
                Wc.fromBufferAttribute(l, h),
                p.uv2 = dc.getUV(jc, Ic, Oc, Nc, Gc, Vc, Wc, new Ia));
                const t = {
                    a: c,
                    b: u,
                    c: h,
                    normal: new $a,
                    materialIndex: 0
                };
                dc.getNormal(Ic, Oc, Nc, t.normal),
                p.face = t
            }
            return p
        }
        Xc.prototype.isMesh = !0;
        class Jc extends Rc {
            constructor(t=1, e=1, n=1, i=1, r=1, s=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const o = this;
                i = Math.floor(i),
                r = Math.floor(r),
                s = Math.floor(s);
                const a = []
                  , l = []
                  , c = []
                  , u = [];
                let h = 0
                  , d = 0;
                function p(t, e, n, i, r, s, p, f, m, g, v) {
                    const y = s / m
                      , x = p / g
                      , _ = s / 2
                      , b = p / 2
                      , w = f / 2
                      , M = m + 1
                      , S = g + 1;
                    let T = 0
                      , E = 0;
                    const A = new $a;
                    for (let s = 0; s < S; s++) {
                        const o = s * x - b;
                        for (let a = 0; a < M; a++) {
                            const h = a * y - _;
                            A[t] = h * i,
                            A[e] = o * r,
                            A[n] = w,
                            l.push(A.x, A.y, A.z),
                            A[t] = 0,
                            A[e] = 0,
                            A[n] = f > 0 ? 1 : -1,
                            c.push(A.x, A.y, A.z),
                            u.push(a / m),
                            u.push(1 - s / g),
                            T += 1
                        }
                    }
                    for (let t = 0; t < g; t++)
                        for (let e = 0; e < m; e++) {
                            const n = h + e + M * t
                              , i = h + e + M * (t + 1)
                              , r = h + (e + 1) + M * (t + 1)
                              , s = h + (e + 1) + M * t;
                            a.push(n, i, s),
                            a.push(i, r, s),
                            E += 6
                        }
                    o.addGroup(d, E, v),
                    d += E,
                    h += T
                }
                p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
                p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
                p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
                p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
                p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
                p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
                this.setIndex(a),
                this.setAttribute("position", new bc(l,3)),
                this.setAttribute("normal", new bc(c,3)),
                this.setAttribute("uv", new bc(u,2))
            }
            static fromJSON(t) {
                return new Jc(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)
            }
        }
        function Zc(t) {
            const e = {};
            for (const n in t) {
                e[n] = {};
                for (const i in t[n]) {
                    const r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }
        function Kc(t) {
            const e = {};
            for (let n = 0; n < t.length; n++) {
                const i = Zc(t[n]);
                for (const t in i)
                    e[t] = i[t]
            }
            return e
        }
        const Qc = {
            clone: Zc,
            merge: Kc
        };
        class $c extends fc {
            constructor(t) {
                super(),
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                this.setValues(t))
            }
            copy(t) {
                return super.copy(t),
                this.fragmentShader = t.fragmentShader,
                this.vertexShader = t.vertexShader,
                this.uniforms = Zc(t.uniforms),
                this.defines = Object.assign({}, t.defines),
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.lights = t.lights,
                this.clipping = t.clipping,
                this.extensions = Object.assign({}, t.extensions),
                this.glslVersion = t.glslVersion,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                e.glslVersion = this.glslVersion,
                e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines),
                e.vertexShader = this.vertexShader,
                e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const t in this.extensions)
                    !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n),
                e
            }
        }
        $c.prototype.isShaderMaterial = !0;
        class tu extends ec {
            constructor() {
                super(),
                this.type = "Camera",
                this.matrixWorldInverse = new Ll,
                this.projectionMatrix = new Ll,
                this.projectionMatrixInverse = new Ll
            }
            copy(t, e) {
                return super.copy(t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                this
            }
            getWorldDirection(t) {
                this.updateWorldMatrix(!0, !1);
                const e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(t, e) {
                super.updateWorldMatrix(t, e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        tu.prototype.isCamera = !0;
        class eu extends tu {
            constructor(t=50, e=1, n=.1, i=2e3) {
                super(),
                this.type = "PerspectiveCamera",
                this.fov = t,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = e,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.fov = t.fov,
                this.zoom = t.zoom,
                this.near = t.near,
                this.far = t.far,
                this.focus = t.focus,
                this.aspect = t.aspect,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this.filmGauge = t.filmGauge,
                this.filmOffset = t.filmOffset,
                this
            }
            setFocalLength(t) {
                const e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Sa * Math.atan(e),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const t = Math.tan(.5 * Ma * this.fov);
                return .5 * this.getFilmHeight() / t
            }
            getEffectiveFOV() {
                return 2 * Sa * Math.atan(Math.tan(.5 * Ma * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(t, e, n, i, r, s) {
                this.aspect = t / e,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = this.near;
                let e = t * Math.tan(.5 * Ma * this.fov) / this.zoom
                  , n = 2 * e
                  , i = this.aspect * n
                  , r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const t = s.fullWidth
                      , o = s.fullHeight;
                    r += s.offsetX * i / t,
                    e -= s.offsetY * n / o,
                    i *= s.width / t,
                    n *= s.height / o
                }
                const o = this.filmOffset;
                0 !== o && (r += t * o / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.fov = this.fov,
                e.object.zoom = this.zoom,
                e.object.near = this.near,
                e.object.far = this.far,
                e.object.focus = this.focus,
                e.object.aspect = this.aspect,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e.object.filmGauge = this.filmGauge,
                e.object.filmOffset = this.filmOffset,
                e
            }
        }
        eu.prototype.isPerspectiveCamera = !0;
        const nu = 90;
        class iu extends ec {
            constructor(t, e, n) {
                if (super(),
                this.type = "CubeCamera",
                !0 !== n.isWebGLCubeRenderTarget)
                    return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const i = new eu(nu,1,t,e);
                i.layers = this.layers,
                i.up.set(0, -1, 0),
                i.lookAt(new $a(1,0,0)),
                this.add(i);
                const r = new eu(nu,1,t,e);
                r.layers = this.layers,
                r.up.set(0, -1, 0),
                r.lookAt(new $a(-1,0,0)),
                this.add(r);
                const s = new eu(nu,1,t,e);
                s.layers = this.layers,
                s.up.set(0, 0, 1),
                s.lookAt(new $a(0,1,0)),
                this.add(s);
                const o = new eu(nu,1,t,e);
                o.layers = this.layers,
                o.up.set(0, 0, -1),
                o.lookAt(new $a(0,-1,0)),
                this.add(o);
                const a = new eu(nu,1,t,e);
                a.layers = this.layers,
                a.up.set(0, -1, 0),
                a.lookAt(new $a(0,0,1)),
                this.add(a);
                const l = new eu(nu,1,t,e);
                l.layers = this.layers,
                l.up.set(0, -1, 0),
                l.lookAt(new $a(0,0,-1)),
                this.add(l)
            }
            update(t, e) {
                null === this.parent && this.updateMatrixWorld();
                const n = this.renderTarget
                  , [i,r,s,o,a,l] = this.children
                  , c = t.xr.enabled
                  , u = t.getRenderTarget();
                t.xr.enabled = !1;
                const h = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                t.setRenderTarget(n, 0),
                t.render(e, i),
                t.setRenderTarget(n, 1),
                t.render(e, r),
                t.setRenderTarget(n, 2),
                t.render(e, s),
                t.setRenderTarget(n, 3),
                t.render(e, o),
                t.setRenderTarget(n, 4),
                t.render(e, a),
                n.texture.generateMipmaps = h,
                t.setRenderTarget(n, 5),
                t.render(e, l),
                t.setRenderTarget(u),
                t.xr.enabled = c,
                n.texture.needsPMREMUpdate = !0
            }
        }
        class ru extends Xa {
            constructor(t, e, n, i, r, s, o, a, l, c) {
                super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : zo, n, i, r, s, o, a, l, c),
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(t) {
                this.image = t
            }
        }
        ru.prototype.isCubeTexture = !0;
        class su extends Za {
            constructor(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
                e = n),
                super(t, t, e),
                e = e || {},
                this.texture = new ru(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps,
                this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : qo
            }
            fromEquirectangularTexture(t, e) {
                this.texture.type = e.type,
                this.texture.format = ta,
                this.texture.encoding = e.encoding,
                this.texture.generateMipmaps = e.generateMipmaps,
                this.texture.minFilter = e.minFilter,
                this.texture.magFilter = e.magFilter;
                const n = {
                    tEquirect: {
                        value: null
                    }
                }
                  , i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t"
                  , r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                  , s = new Jc(5,5,5)
                  , o = new $c({
                    name: "CubemapFromEquirect",
                    uniforms: Zc(n),
                    vertexShader: i,
                    fragmentShader: r,
                    side: 1,
                    blending: 0
                });
                o.uniforms.tEquirect.value = e;
                const a = new Xc(s,o)
                  , l = e.minFilter;
                return e.minFilter === Xo && (e.minFilter = qo),
                new iu(1,10,this).update(t, a),
                e.minFilter = l,
                a.geometry.dispose(),
                a.material.dispose(),
                this
            }
            clear(t, e, n, i) {
                const r = t.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    t.setRenderTarget(this, r),
                    t.clear(e, n, i);
                t.setRenderTarget(r)
            }
        }
        su.prototype.isWebGLCubeRenderTarget = !0;
        const ou = new $a
          , au = new $a
          , lu = new Oa;
        class cu {
            constructor(t=new $a(1,0,0), e=0) {
                this.normal = t,
                this.constant = e
            }
            set(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            }
            setComponents(t, e, n, i) {
                return this.normal.set(t, e, n),
                this.constant = i,
                this
            }
            setFromNormalAndCoplanarPoint(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            }
            setFromCoplanarPoints(t, e, n) {
                const i = ou.subVectors(n, e).cross(au.subVectors(t, e)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, t),
                this
            }
            copy(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            }
            normalize() {
                const t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(t) {
                return this.normal.dot(t) + this.constant
            }
            distanceToSphere(t) {
                return this.distanceToPoint(t.center) - t.radius
            }
            projectPoint(t, e) {
                return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            }
            intersectLine(t, e) {
                const n = t.delta(ou)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                const r = -(t.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start)
            }
            intersectsLine(t) {
                const e = this.distanceToPoint(t.start)
                  , n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }
            intersectsBox(t) {
                return t.intersectsPlane(this)
            }
            intersectsSphere(t) {
                return t.intersectsPlane(this)
            }
            coplanarPoint(t) {
                return t.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(t, e) {
                const n = e || lu.getNormalMatrix(t)
                  , i = this.coplanarPoint(ou).applyMatrix4(t)
                  , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                this
            }
            translate(t) {
                return this.constant -= t.dot(this.normal),
                this
            }
            equals(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        cu.prototype.isPlane = !0;
        const uu = new bl
          , hu = new $a;
        class du {
            constructor(t=new cu, e=new cu, n=new cu, i=new cu, r=new cu, s=new cu) {
                this.planes = [t, e, n, i, r, s]
            }
            set(t, e, n, i, r, s) {
                const o = this.planes;
                return o[0].copy(t),
                o[1].copy(e),
                o[2].copy(n),
                o[3].copy(i),
                o[4].copy(r),
                o[5].copy(s),
                this
            }
            copy(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    e[n].copy(t.planes[n]);
                return this
            }
            setFromProjectionMatrix(t) {
                const e = this.planes
                  , n = t.elements
                  , i = n[0]
                  , r = n[1]
                  , s = n[2]
                  , o = n[3]
                  , a = n[4]
                  , l = n[5]
                  , c = n[6]
                  , u = n[7]
                  , h = n[8]
                  , d = n[9]
                  , p = n[10]
                  , f = n[11]
                  , m = n[12]
                  , g = n[13]
                  , v = n[14]
                  , y = n[15];
                return e[0].setComponents(o - i, u - a, f - h, y - m).normalize(),
                e[1].setComponents(o + i, u + a, f + h, y + m).normalize(),
                e[2].setComponents(o + r, u + l, f + d, y + g).normalize(),
                e[3].setComponents(o - r, u - l, f - d, y - g).normalize(),
                e[4].setComponents(o - s, u - c, f - p, y - v).normalize(),
                e[5].setComponents(o + s, u + c, f + p, y + v).normalize(),
                this
            }
            intersectsObject(t) {
                const e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(),
                uu.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                this.intersectsSphere(uu)
            }
            intersectsSprite(t) {
                return uu.center.set(0, 0, 0),
                uu.radius = .7071067811865476,
                uu.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(uu)
            }
            intersectsSphere(t) {
                const e = this.planes
                  , n = t.center
                  , i = -t.radius;
                for (let t = 0; t < 6; t++)
                    if (e[t].distanceToPoint(n) < i)
                        return !1;
                return !0
            }
            intersectsBox(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = e[n];
                    if (hu.x = i.normal.x > 0 ? t.max.x : t.min.x,
                    hu.y = i.normal.y > 0 ? t.max.y : t.min.y,
                    hu.z = i.normal.z > 0 ? t.max.z : t.min.z,
                    i.distanceToPoint(hu) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(t) {
                const e = this.planes;
                for (let n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function pu() {
            let t = null
              , e = !1
              , n = null
              , i = null;
            function r(e, s) {
                n(e, s),
                i = t.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== e && null !== n && (i = t.requestAnimationFrame(r),
                    e = !0)
                },
                stop: function() {
                    t.cancelAnimationFrame(i),
                    e = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(e) {
                    t = e
                }
            }
        }
        function fu(t, e) {
            const n = e.isWebGL2
              , i = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data),
                    i.get(t)
                },
                remove: function(e) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const n = i.get(e);
                    n && (t.deleteBuffer(n.buffer),
                    i.delete(e))
                },
                update: function(e, r) {
                    if (e.isGLBufferAttribute) {
                        const t = i.get(e);
                        return void ((!t || t.version < e.version) && i.set(e, {
                            buffer: e.buffer,
                            type: e.type,
                            bytesPerElement: e.elementSize,
                            version: e.version
                        }))
                    }
                    e.isInterleavedBufferAttribute && (e = e.data);
                    const s = i.get(e);
                    void 0 === s ? i.set(e, function(e, i) {
                        const r = e.array
                          , s = e.usage
                          , o = t.createBuffer();
                        t.bindBuffer(i, o),
                        t.bufferData(i, r, s),
                        e.onUploadCallback();
                        let a = 5126;
                        return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (a = 5121),
                        {
                            buffer: o,
                            type: a,
                            bytesPerElement: r.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(e, r)) : s.version < e.version && (function(e, i, r) {
                        const s = i.array
                          , o = i.updateRange;
                        t.bindBuffer(r, e),
                        -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)),
                        o.count = -1)
                    }(s.buffer, e, r),
                    s.version = e.version)
                }
            }
        }
        class mu extends Rc {
            constructor(t=1, e=1, n=1, i=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = t / 2
                  , s = e / 2
                  , o = Math.floor(n)
                  , a = Math.floor(i)
                  , l = o + 1
                  , c = a + 1
                  , u = t / o
                  , h = e / a
                  , d = []
                  , p = []
                  , f = []
                  , m = [];
                for (let t = 0; t < c; t++) {
                    const e = t * h - s;
                    for (let n = 0; n < l; n++) {
                        const i = n * u - r;
                        p.push(i, -e, 0),
                        f.push(0, 0, 1),
                        m.push(n / o),
                        m.push(1 - t / a)
                    }
                }
                for (let t = 0; t < a; t++)
                    for (let e = 0; e < o; e++) {
                        const n = e + l * t
                          , i = e + l * (t + 1)
                          , r = e + 1 + l * (t + 1)
                          , s = e + 1 + l * t;
                        d.push(n, i, s),
                        d.push(i, r, s)
                    }
                this.setIndex(d),
                this.setAttribute("position", new bc(p,3)),
                this.setAttribute("normal", new bc(f,3)),
                this.setAttribute("uv", new bc(m,2))
            }
            static fromJSON(t) {
                return new mu(t.width,t.height,t.widthSegments,t.heightSegments)
            }
        }
        const gu = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
            uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
        }
          , vu = {
            common: {
                diffuse: {
                    value: new Va(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new Oa
                },
                uv2Transform: {
                    value: new Oa
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new Ia(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Va(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Va(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Oa
                }
            },
            sprite: {
                diffuse: {
                    value: new Va(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Ia(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Oa
                }
            }
        }
          , yu = {
            basic: {
                uniforms: Kc([vu.common, vu.specularmap, vu.envmap, vu.aomap, vu.lightmap, vu.fog]),
                vertexShader: gu.meshbasic_vert,
                fragmentShader: gu.meshbasic_frag
            },
            lambert: {
                uniforms: Kc([vu.common, vu.specularmap, vu.envmap, vu.aomap, vu.lightmap, vu.emissivemap, vu.fog, vu.lights, {
                    emissive: {
                        value: new Va(0)
                    }
                }]),
                vertexShader: gu.meshlambert_vert,
                fragmentShader: gu.meshlambert_frag
            },
            phong: {
                uniforms: Kc([vu.common, vu.specularmap, vu.envmap, vu.aomap, vu.lightmap, vu.emissivemap, vu.bumpmap, vu.normalmap, vu.displacementmap, vu.fog, vu.lights, {
                    emissive: {
                        value: new Va(0)
                    },
                    specular: {
                        value: new Va(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: gu.meshphong_vert,
                fragmentShader: gu.meshphong_frag
            },
            standard: {
                uniforms: Kc([vu.common, vu.envmap, vu.aomap, vu.lightmap, vu.emissivemap, vu.bumpmap, vu.normalmap, vu.displacementmap, vu.roughnessmap, vu.metalnessmap, vu.fog, vu.lights, {
                    emissive: {
                        value: new Va(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: gu.meshphysical_vert,
                fragmentShader: gu.meshphysical_frag
            },
            toon: {
                uniforms: Kc([vu.common, vu.aomap, vu.lightmap, vu.emissivemap, vu.bumpmap, vu.normalmap, vu.displacementmap, vu.gradientmap, vu.fog, vu.lights, {
                    emissive: {
                        value: new Va(0)
                    }
                }]),
                vertexShader: gu.meshtoon_vert,
                fragmentShader: gu.meshtoon_frag
            },
            matcap: {
                uniforms: Kc([vu.common, vu.bumpmap, vu.normalmap, vu.displacementmap, vu.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: gu.meshmatcap_vert,
                fragmentShader: gu.meshmatcap_frag
            },
            points: {
                uniforms: Kc([vu.points, vu.fog]),
                vertexShader: gu.points_vert,
                fragmentShader: gu.points_frag
            },
            dashed: {
                uniforms: Kc([vu.common, vu.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: gu.linedashed_vert,
                fragmentShader: gu.linedashed_frag
            },
            depth: {
                uniforms: Kc([vu.common, vu.displacementmap]),
                vertexShader: gu.depth_vert,
                fragmentShader: gu.depth_frag
            },
            normal: {
                uniforms: Kc([vu.common, vu.bumpmap, vu.normalmap, vu.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: gu.meshnormal_vert,
                fragmentShader: gu.meshnormal_frag
            },
            sprite: {
                uniforms: Kc([vu.sprite, vu.fog]),
                vertexShader: gu.sprite_vert,
                fragmentShader: gu.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Oa
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: gu.background_vert,
                fragmentShader: gu.background_frag
            },
            cube: {
                uniforms: Kc([vu.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: gu.cube_vert,
                fragmentShader: gu.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: gu.equirect_vert,
                fragmentShader: gu.equirect_frag
            },
            distanceRGBA: {
                uniforms: Kc([vu.common, vu.displacementmap, {
                    referencePosition: {
                        value: new $a
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: gu.distanceRGBA_vert,
                fragmentShader: gu.distanceRGBA_frag
            },
            shadow: {
                uniforms: Kc([vu.lights, vu.fog, {
                    color: {
                        value: new Va(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: gu.shadow_vert,
                fragmentShader: gu.shadow_frag
            }
        };
        function xu(t, e, n, i, r, s) {
            const o = new Va(0);
            let a, l, c = !0 === r ? 0 : 1, u = null, h = 0, d = null;
            function p(t, e) {
                n.buffers.color.setClear(t.r, t.g, t.b, e, s)
            }
            return {
                getClearColor: function() {
                    return o
                },
                setClearColor: function(t, e=1) {
                    o.set(t),
                    c = e,
                    p(o, c)
                },
                getClearAlpha: function() {
                    return c
                },
                setClearAlpha: function(t) {
                    c = t,
                    p(o, c)
                },
                render: function(n, r) {
                    let s = !1
                      , f = !0 === r.isScene ? r.background : null;
                    f && f.isTexture && (f = e.get(f));
                    const m = t.xr
                      , g = m.getSession && m.getSession();
                    g && "additive" === g.environmentBlendMode && (f = null),
                    null === f ? p(o, c) : f && f.isColor && (p(f, 1),
                    s = !0),
                    (t.autoClear || s) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                    f && (f.isCubeTexture || f.mapping === Bo) ? (void 0 === l && (l = new Xc(new Jc(1,1,1),new $c({
                        name: "BackgroundCubeMaterial",
                        uniforms: Zc(yu.cube.uniforms),
                        vertexShader: yu.cube.vertexShader,
                        fragmentShader: yu.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    l.geometry.deleteAttribute("normal"),
                    l.geometry.deleteAttribute("uv"),
                    l.onBeforeRender = function(t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(l.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    i.update(l)),
                    l.material.uniforms.envMap.value = f,
                    l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1,
                    u === f && h === f.version && d === t.toneMapping || (l.material.needsUpdate = !0,
                    u = f,
                    h = f.version,
                    d = t.toneMapping),
                    n.unshift(l, l.geometry, l.material, 0, 0, null)) : f && f.isTexture && (void 0 === a && (a = new Xc(new mu(2,2),new $c({
                        name: "BackgroundMaterial",
                        uniforms: Zc(yu.background.uniforms),
                        vertexShader: yu.background.vertexShader,
                        fragmentShader: yu.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    a.geometry.deleteAttribute("normal"),
                    Object.defineProperty(a.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    i.update(a)),
                    a.material.uniforms.t2D.value = f,
                    !0 === f.matrixAutoUpdate && f.updateMatrix(),
                    a.material.uniforms.uvTransform.value.copy(f.matrix),
                    u === f && h === f.version && d === t.toneMapping || (a.material.needsUpdate = !0,
                    u = f,
                    h = f.version,
                    d = t.toneMapping),
                    n.unshift(a, a.geometry, a.material, 0, 0, null))
                }
            }
        }
        function _u(t, e, n, i) {
            const r = t.getParameter(34921)
              , s = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
              , o = i.isWebGL2 || null !== s
              , a = {}
              , l = d(null);
            let c = l;
            function u(e) {
                return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
            }
            function h(e) {
                return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
            }
            function d(t) {
                const e = []
                  , n = []
                  , i = [];
                for (let t = 0; t < r; t++)
                    e[t] = 0,
                    n[t] = 0,
                    i[t] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: i,
                    object: t,
                    attributes: {},
                    index: null
                }
            }
            function p() {
                const t = c.newAttributes;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e] = 0
            }
            function f(t) {
                m(t, 0)
            }
            function m(n, r) {
                const s = c.newAttributes
                  , o = c.enabledAttributes
                  , a = c.attributeDivisors;
                s[n] = 1,
                0 === o[n] && (t.enableVertexAttribArray(n),
                o[n] = 1),
                a[n] !== r && ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
                a[n] = r)
            }
            function g() {
                const e = c.newAttributes
                  , n = c.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== e[i] && (t.disableVertexAttribArray(i),
                    n[i] = 0)
            }
            function v(e, n, r, s, o, a) {
                !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a)
            }
            function y() {
                x(),
                c !== l && (c = l,
                u(c.object))
            }
            function x() {
                l.geometry = null,
                l.program = null,
                l.wireframe = !1
            }
            return {
                setup: function(r, l, h, y, x) {
                    let _ = !1;
                    if (o) {
                        const e = function(e, n, r) {
                            const o = !0 === r.wireframe;
                            let l = a[e.id];
                            void 0 === l && (l = {},
                            a[e.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {},
                            l[n.id] = c);
                            let u = c[o];
                            return void 0 === u && (u = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()),
                            c[o] = u),
                            u
                        }(y, h, l);
                        c !== e && (c = e,
                        u(c.object)),
                        _ = function(t, e) {
                            const n = c.attributes
                              , i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = n[t]
                                  , s = i[t];
                                if (void 0 === e)
                                    return !0;
                                if (e.attribute !== s)
                                    return !0;
                                if (e.data !== s.data)
                                    return !0;
                                r++
                            }
                            return c.attributesNum !== r || c.index !== e
                        }(y, x),
                        _ && function(t, e) {
                            const n = {}
                              , i = t.attributes;
                            let r = 0;
                            for (const t in i) {
                                const e = i[t]
                                  , s = {};
                                s.attribute = e,
                                e.data && (s.data = e.data),
                                n[t] = s,
                                r++
                            }
                            c.attributes = n,
                            c.attributesNum = r,
                            c.index = e
                        }(y, x)
                    } else {
                        const t = !0 === l.wireframe;
                        c.geometry === y.id && c.program === h.id && c.wireframe === t || (c.geometry = y.id,
                        c.program = h.id,
                        c.wireframe = t,
                        _ = !0)
                    }
                    !0 === r.isInstancedMesh && (_ = !0),
                    null !== x && n.update(x, 34963),
                    _ && (function(r, s, o, a) {
                        if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                            return;
                        p();
                        const l = a.attributes
                          , c = o.getAttributes()
                          , u = s.defaultAttributeValues;
                        for (const e in c) {
                            const i = c[e];
                            if (i.location >= 0) {
                                let s = l[e];
                                if (void 0 === s && ("instanceMatrix" === e && r.instanceMatrix && (s = r.instanceMatrix),
                                "instanceColor" === e && r.instanceColor && (s = r.instanceColor)),
                                void 0 !== s) {
                                    const e = s.normalized
                                      , o = s.itemSize
                                      , l = n.get(s);
                                    if (void 0 === l)
                                        continue;
                                    const c = l.buffer
                                      , u = l.type
                                      , h = l.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data
                                          , l = n.stride
                                          , d = s.offset;
                                        if (n && n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < i.locationSize; t++)
                                                m(i.location + t, n.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < i.locationSize; t++)
                                                f(i.location + t);
                                        t.bindBuffer(34962, c);
                                        for (let t = 0; t < i.locationSize; t++)
                                            v(i.location + t, o / i.locationSize, u, e, l * h, (d + o / i.locationSize * t) * h)
                                    } else {
                                        if (s.isInstancedBufferAttribute) {
                                            for (let t = 0; t < i.locationSize; t++)
                                                m(i.location + t, s.meshPerAttribute);
                                            !0 !== r.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)
                                        } else
                                            for (let t = 0; t < i.locationSize; t++)
                                                f(i.location + t);
                                        t.bindBuffer(34962, c);
                                        for (let t = 0; t < i.locationSize; t++)
                                            v(i.location + t, o / i.locationSize, u, e, o * h, o / i.locationSize * t * h)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[e];
                                    if (void 0 !== n)
                                        switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(i.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(i.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(i.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(i.location, n)
                                        }
                                }
                            }
                        }
                        g()
                    }(r, l, h, y),
                    null !== x && t.bindBuffer(34963, n.get(x).buffer))
                },
                reset: y,
                resetDefaultState: x,
                dispose: function() {
                    y();
                    for (const t in a) {
                        const e = a[t];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n)
                                h(n[t].object),
                                delete n[t];
                            delete e[t]
                        }
                        delete a[t]
                    }
                },
                releaseStatesOfGeometry: function(t) {
                    if (void 0 === a[t.id])
                        return;
                    const e = a[t.id];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            h(n[t].object),
                            delete n[t];
                        delete e[t]
                    }
                    delete a[t.id]
                },
                releaseStatesOfProgram: function(t) {
                    for (const e in a) {
                        const n = a[e];
                        if (void 0 === n[t.id])
                            continue;
                        const i = n[t.id];
                        for (const t in i)
                            h(i[t].object),
                            delete i[t];
                        delete n[t.id]
                    }
                },
                initAttributes: p,
                enableAttribute: f,
                disableUnusedAttributes: g
            }
        }
        function bu(t, e, n, i) {
            const r = i.isWebGL2;
            let s;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.render = function(e, i) {
                t.drawArrays(s, e, i),
                n.update(i, s, 1)
            }
            ,
            this.renderInstances = function(i, o, a) {
                if (0 === a)
                    return;
                let l, c;
                if (r)
                    l = t,
                    c = "drawArraysInstanced";
                else if (l = e.get("ANGLE_instanced_arrays"),
                c = "drawArraysInstancedANGLE",
                null === l)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](s, i, o, a),
                n.update(o, s, a)
            }
        }
        function wu(t, e, n) {
            let i;
            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                        return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
            }
            const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
            let o = void 0 !== n.precision ? n.precision : "highp";
            const a = r(o);
            a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."),
            o = a);
            const l = s || e.has("WEBGL_draw_buffers")
              , c = !0 === n.logarithmicDepthBuffer
              , u = t.getParameter(34930)
              , h = t.getParameter(35660)
              , d = t.getParameter(3379)
              , p = t.getParameter(34076)
              , f = t.getParameter(34921)
              , m = t.getParameter(36347)
              , g = t.getParameter(36348)
              , v = t.getParameter(36349)
              , y = h > 0
              , x = s || e.has("OES_texture_float");
            return {
                isWebGL2: s,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== i)
                        return i;
                    if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                        const n = e.get("EXT_texture_filter_anisotropic");
                        i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        i = 0;
                    return i
                },
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: d,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: x,
                floatVertexTextures: y && x,
                maxSamples: s ? t.getParameter(36183) : 0
            }
        }
        function Mu(t) {
            const e = this;
            let n = null
              , i = 0
              , r = !1
              , s = !1;
            const o = new cu
              , a = new Oa
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c() {
                l.value !== n && (l.value = n,
                l.needsUpdate = i > 0),
                e.numPlanes = i,
                e.numIntersection = 0
            }
            function u(t, n, i, r) {
                const s = null !== t ? t.length : 0;
                let c = null;
                if (0 !== s) {
                    if (c = l.value,
                    !0 !== r || null === c) {
                        const e = i + 4 * s
                          , r = n.matrixWorldInverse;
                        a.getNormalMatrix(r),
                        (null === c || c.length < e) && (c = new Float32Array(e));
                        for (let e = 0, n = i; e !== s; ++e,
                        n += 4)
                            o.copy(t[e]).applyMatrix4(r, a),
                            o.normal.toArray(c, n),
                            c[n + 3] = o.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return e.numPlanes = s,
                e.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(t, e, s) {
                const o = 0 !== t.length || e || 0 !== i || r;
                return r = e,
                n = u(t, s, 0),
                i = t.length,
                o
            }
            ,
            this.beginShadows = function() {
                s = !0,
                u(null)
            }
            ,
            this.endShadows = function() {
                s = !1,
                c()
            }
            ,
            this.setState = function(e, o, a) {
                const h = e.clippingPlanes
                  , d = e.clipIntersection
                  , p = e.clipShadows
                  , f = t.get(e);
                if (!r || null === h || 0 === h.length || s && !p)
                    s ? u(null) : c();
                else {
                    const t = s ? 0 : i
                      , e = 4 * t;
                    let r = f.clippingState || null;
                    l.value = r,
                    r = u(h, o, e, a);
                    for (let t = 0; t !== e; ++t)
                        r[t] = n[t];
                    f.clippingState = r,
                    this.numIntersection = d ? this.numPlanes : 0,
                    this.numPlanes += t
                }
            }
        }
        function Su(t) {
            let e = new WeakMap;
            function n(t, e) {
                return 303 === e ? t.mapping = zo : 304 === e && (t.mapping = Ho),
                t
            }
            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                        const s = r.mapping;
                        if (303 === s || 304 === s) {
                            if (e.has(r))
                                return n(e.get(r).texture, r.mapping);
                            {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const o = new su(s.height / 2);
                                    return o.fromEquirectangularTexture(t, r),
                                    e.set(r, o),
                                    r.addEventListener("dispose", i),
                                    n(o.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        yu.physical = {
            uniforms: Kc([yu.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new Ia(1,1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Va(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new Ia
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Va(0)
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularColor: {
                    value: new Va(1,1,1)
                },
                specularColorMap: {
                    value: null
                }
            }]),
            vertexShader: gu.meshphysical_vert,
            fragmentShader: gu.meshphysical_frag
        };
        class Tu extends tu {
            constructor(t=-1, e=1, n=1, i=-1, r=.1, s=2e3) {
                super(),
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = t,
                this.right = e,
                this.top = n,
                this.bottom = i,
                this.near = r,
                this.far = s,
                this.updateProjectionMatrix()
            }
            copy(t, e) {
                return super.copy(t, e),
                this.left = t.left,
                this.right = t.right,
                this.top = t.top,
                this.bottom = t.bottom,
                this.near = t.near,
                this.far = t.far,
                this.zoom = t.zoom,
                this.view = null === t.view ? null : Object.assign({}, t.view),
                this
            }
            setViewOffset(t, e, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = t,
                this.view.fullHeight = e,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const t = (this.right - this.left) / (2 * this.zoom)
                  , e = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , i = (this.top + this.bottom) / 2;
                let r = n - t
                  , s = n + t
                  , o = i + e
                  , a = i - e;
                if (null !== this.view && this.view.enabled) {
                    const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += t * this.view.offsetX,
                    s = r + t * this.view.width,
                    o -= e * this.view.offsetY,
                    a = o - e * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.zoom = this.zoom,
                e.object.left = this.left,
                e.object.right = this.right,
                e.object.top = this.top,
                e.object.bottom = this.bottom,
                e.object.near = this.near,
                e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({}, this.view)),
                e
            }
        }
        Tu.prototype.isOrthographicCamera = !0;
        class Eu extends $c {
            constructor(t) {
                super(t),
                this.type = "RawShaderMaterial"
            }
        }
        Eu.prototype.isRawShaderMaterial = !0;
        const Au = Math.pow(2, 8)
          , Cu = [.125, .215, .35, .446, .526, .582]
          , Ru = 5 + Cu.length
          , Lu = new Tu
          , {_lodPlanes: Pu, _sizeLods: Du, _sigmas: Iu} = Fu()
          , Ou = new Va;
        let Nu = null;
        const ku = (1 + Math.sqrt(5)) / 2
          , zu = 1 / ku
          , Hu = [new $a(1,1,1), new $a(-1,1,1), new $a(1,1,-1), new $a(-1,1,-1), new $a(0,ku,zu), new $a(0,ku,-zu), new $a(zu,0,ku), new $a(-zu,0,ku), new $a(ku,zu,0), new $a(-ku,zu,0)];
        class Bu {
            constructor(t) {
                this._renderer = t,
                this._pingPongRenderTarget = null,
                this._blurMaterial = function(t) {
                    const e = new Float32Array(20)
                      , n = new $a(0,1,0);
                    return new Eu({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: 20
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: e
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: n
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }(),
                this._equirectShader = null,
                this._cubemapShader = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(t, e=0, n=.1, i=100) {
                Nu = this._renderer.getRenderTarget();
                const r = this._allocateTargets();
                return this._sceneToCubeUV(t, n, i, r),
                e > 0 && this._blur(r, 0, 0, e),
                this._applyPMREM(r),
                this._cleanup(r),
                r
            }
            fromEquirectangular(t, e=null) {
                return this._fromTexture(t, e)
            }
            fromCubemap(t, e=null) {
                return this._fromTexture(t, e)
            }
            compileCubemapShader() {
                null === this._cubemapShader && (this._cubemapShader = Wu(),
                this._compileMaterial(this._cubemapShader))
            }
            compileEquirectangularShader() {
                null === this._equirectShader && (this._equirectShader = Vu(),
                this._compileMaterial(this._equirectShader))
            }
            dispose() {
                this._blurMaterial.dispose(),
                null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(),
                null !== this._cubemapShader && this._cubemapShader.dispose(),
                null !== this._equirectShader && this._equirectShader.dispose();
                for (let t = 0; t < Pu.length; t++)
                    Pu[t].dispose()
            }
            _cleanup(t) {
                this._renderer.setRenderTarget(Nu),
                t.scissorTest = !1,
                Gu(t, 0, 0, t.width, t.height)
            }
            _fromTexture(t, e) {
                Nu = this._renderer.getRenderTarget();
                const n = e || this._allocateTargets(t);
                return this._textureToCubeUV(t, n),
                this._applyPMREM(n),
                this._cleanup(n),
                n
            }
            _allocateTargets(t) {
                const e = {
                    magFilter: qo,
                    minFilter: qo,
                    generateMipmaps: !1,
                    type: Qo,
                    format: ta,
                    encoding: pa,
                    depthBuffer: !1
                }
                  , n = Uu(e);
                return n.depthBuffer = !t,
                null === this._pingPongRenderTarget && (this._pingPongRenderTarget = Uu(e)),
                n
            }
            _compileMaterial(t) {
                const e = new Xc(Pu[0],t);
                this._renderer.compile(e, Lu)
            }
            _sceneToCubeUV(t, e, n, i) {
                const r = new eu(90,1,e,n)
                  , s = [1, -1, 1, 1, 1, 1]
                  , o = [1, 1, 1, -1, -1, -1]
                  , a = this._renderer
                  , l = a.autoClear
                  , c = a.toneMapping;
                a.getClearColor(Ou),
                a.toneMapping = 0,
                a.autoClear = !1;
                const u = new mc({
                    name: "PMREM.Background",
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , h = new Xc(new Jc,u);
                let d = !1;
                const p = t.background;
                p ? p.isColor && (u.color.copy(p),
                t.background = null,
                d = !0) : (u.color.copy(Ou),
                d = !0);
                for (let e = 0; e < 6; e++) {
                    const n = e % 3;
                    0 === n ? (r.up.set(0, s[e], 0),
                    r.lookAt(o[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]),
                    r.lookAt(0, o[e], 0)) : (r.up.set(0, s[e], 0),
                    r.lookAt(0, 0, o[e])),
                    Gu(i, n * Au, e > 2 ? Au : 0, Au, Au),
                    a.setRenderTarget(i),
                    d && a.render(h, r),
                    a.render(t, r)
                }
                h.geometry.dispose(),
                h.material.dispose(),
                a.toneMapping = c,
                a.autoClear = l,
                t.background = p
            }
            _textureToCubeUV(t, e) {
                const n = this._renderer
                  , i = t.mapping === zo || t.mapping === Ho;
                i ? (null === this._cubemapShader && (this._cubemapShader = Wu()),
                this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = Vu());
                const r = i ? this._cubemapShader : this._equirectShader
                  , s = new Xc(Pu[0],r)
                  , o = r.uniforms;
                o.envMap.value = t,
                i || o.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
                Gu(e, 0, 0, 3 * Au, 2 * Au),
                n.setRenderTarget(e),
                n.render(s, Lu)
            }
            _applyPMREM(t) {
                const e = this._renderer
                  , n = e.autoClear;
                e.autoClear = !1;
                for (let e = 1; e < Ru; e++) {
                    const n = Math.sqrt(Iu[e] * Iu[e] - Iu[e - 1] * Iu[e - 1])
                      , i = Hu[(e - 1) % Hu.length];
                    this._blur(t, e - 1, e, n, i)
                }
                e.autoClear = n
            }
            _blur(t, e, n, i, r) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(t, s, e, n, i, "latitudinal", r),
                this._halfBlur(s, t, n, n, i, "longitudinal", r)
            }
            _halfBlur(t, e, n, i, r, s, o) {
                const a = this._renderer
                  , l = this._blurMaterial;
                "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new Xc(Pu[i],l)
                  , u = l.uniforms
                  , h = Du[n] - 1
                  , d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39
                  , p = r / d
                  , f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const m = [];
                let g = 0;
                for (let t = 0; t < 20; ++t) {
                    const e = t / p
                      , n = Math.exp(-e * e / 2);
                    m.push(n),
                    0 === t ? g += n : t < f && (g += 2 * n)
                }
                for (let t = 0; t < m.length; t++)
                    m[t] = m[t] / g;
                u.envMap.value = t.texture,
                u.samples.value = f,
                u.weights.value = m,
                u.latitudinal.value = "latitudinal" === s,
                o && (u.poleAxis.value = o),
                u.dTheta.value = d,
                u.mipInt.value = 8 - n;
                const v = Du[i];
                Gu(e, 3 * Math.max(0, Au - 2 * v), (0 === i ? 0 : 2 * Au) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v),
                a.setRenderTarget(e),
                a.render(c, Lu)
            }
        }
        function Fu() {
            const t = []
              , e = []
              , n = [];
            let i = 8;
            for (let r = 0; r < Ru; r++) {
                const s = Math.pow(2, i);
                e.push(s);
                let o = 1 / s;
                r > 4 ? o = Cu[r - 8 + 4 - 1] : 0 === r && (o = 0),
                n.push(o);
                const a = 1 / (s - 1)
                  , l = -a / 2
                  , c = 1 + a / 2
                  , u = [l, l, c, l, c, c, l, l, c, c, l, c]
                  , h = 6
                  , d = 6
                  , p = 3
                  , f = 2
                  , m = 1
                  , g = new Float32Array(p * d * h)
                  , v = new Float32Array(f * d * h)
                  , y = new Float32Array(m * d * h);
                for (let t = 0; t < h; t++) {
                    const e = t % 3 * 2 / 3 - 1
                      , n = t > 2 ? 0 : -1
                      , i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                    g.set(i, p * d * t),
                    v.set(u, f * d * t);
                    const r = [t, t, t, t, t, t];
                    y.set(r, m * d * t)
                }
                const x = new Rc;
                x.setAttribute("position", new yc(g,p)),
                x.setAttribute("uv", new yc(v,f)),
                x.setAttribute("faceIndex", new yc(y,m)),
                t.push(x),
                i > 4 && i--
            }
            return {
                _lodPlanes: t,
                _sizeLods: e,
                _sigmas: n
            }
        }
        function Uu(t) {
            const e = new Za(3 * Au,3 * Au,t);
            return e.texture.mapping = Bo,
            e.texture.name = "PMREM.cubeUv",
            e.scissorTest = !0,
            e
        }
        function Gu(t, e, n, i, r) {
            t.viewport.set(e, n, i, r),
            t.scissor.set(e, n, i, r)
        }
        function Vu() {
            const t = new Ia(1,1);
            return new Eu({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    texelSize: {
                        value: t
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Wu() {
            return new Eu({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function ju(t) {
            let e = new WeakMap
              , n = null;
            function i(t) {
                const n = t.target;
                n.removeEventListener("dispose", i);
                const r = e.get(n);
                void 0 !== r && (e.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const s = r.mapping
                          , o = 303 === s || 304 === s
                          , a = s === zo || s === Ho;
                        if (o || a) {
                            if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                                r.needsPMREMUpdate = !1;
                                let i = e.get(r);
                                return null === n && (n = new Bu(t)),
                                i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i),
                                e.set(r, i),
                                i.texture
                            }
                            if (e.has(r))
                                return e.get(r).texture;
                            {
                                const s = r.image;
                                if (o && s && s.height > 0 || a && s && function(t) {
                                    let e = 0;
                                    for (let n = 0; n < 6; n++)
                                        void 0 !== t[n] && e++;
                                    return 6 === e
                                }(s)) {
                                    null === n && (n = new Bu(t));
                                    const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                    return e.set(r, s),
                                    r.addEventListener("dispose", i),
                                    s.texture
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    e = new WeakMap,
                    null !== n && (n.dispose(),
                    n = null)
                }
            }
        }
        function qu(t) {
            const e = {};
            function n(n) {
                if (void 0 !== e[n])
                    return e[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = t.getExtension(n)
                }
                return e[n] = i,
                i
            }
            return {
                has: function(t) {
                    return null !== n(t)
                },
                init: function(t) {
                    t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                    n("OES_texture_float"),
                    n("OES_texture_half_float"),
                    n("OES_texture_half_float_linear"),
                    n("OES_standard_derivatives"),
                    n("OES_element_index_uint"),
                    n("OES_vertex_array_object"),
                    n("ANGLE_instanced_arrays")),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float"),
                    n("WEBGL_multisampled_render_to_texture")
                },
                get: function(t) {
                    const e = n(t);
                    return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                    e
                }
            }
        }
        function Xu(t, e, n, i) {
            const r = {}
              , s = new WeakMap;
            function o(t) {
                const a = t.target;
                null !== a.index && e.remove(a.index);
                for (const t in a.attributes)
                    e.remove(a.attributes[t]);
                a.removeEventListener("dispose", o),
                delete r[a.id];
                const l = s.get(a);
                l && (e.remove(l),
                s.delete(a)),
                i.releaseStatesOfGeometry(a),
                !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
                n.memory.geometries--
            }
            function a(t) {
                const n = []
                  , i = t.index
                  , r = t.attributes.position;
                let o = 0;
                if (null !== i) {
                    const t = i.array;
                    o = i.version;
                    for (let e = 0, i = t.length; e < i; e += 3) {
                        const i = t[e + 0]
                          , r = t[e + 1]
                          , s = t[e + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    const t = r.array;
                    o = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0
                          , i = e + 1
                          , r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
                const a = new (Na(n) ? _c : xc)(n,1);
                a.version = o;
                const l = s.get(t);
                l && e.remove(l),
                s.set(t, a)
            }
            return {
                get: function(t, e) {
                    return !0 === r[e.id] || (e.addEventListener("dispose", o),
                    r[e.id] = !0,
                    n.memory.geometries++),
                    e
                },
                update: function(t) {
                    const n = t.attributes;
                    for (const t in n)
                        e.update(n[t], 34962);
                    const i = t.morphAttributes;
                    for (const t in i) {
                        const n = i[t];
                        for (let t = 0, i = n.length; t < i; t++)
                            e.update(n[t], 34962)
                    }
                },
                getWireframeAttribute: function(t) {
                    const e = s.get(t);
                    if (e) {
                        const n = t.index;
                        null !== n && e.version < n.version && a(t)
                    } else
                        a(t);
                    return s.get(t)
                }
            }
        }
        function Yu(t, e, n, i) {
            const r = i.isWebGL2;
            let s, o, a;
            this.setMode = function(t) {
                s = t
            }
            ,
            this.setIndex = function(t) {
                o = t.type,
                a = t.bytesPerElement
            }
            ,
            this.render = function(e, i) {
                t.drawElements(s, i, o, e * a),
                n.update(i, s, 1)
            }
            ,
            this.renderInstances = function(i, l, c) {
                if (0 === c)
                    return;
                let u, h;
                if (r)
                    u = t,
                    h = "drawElementsInstanced";
                else if (u = e.get("ANGLE_instanced_arrays"),
                h = "drawElementsInstancedANGLE",
                null === u)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[h](s, l, o, i * a, c),
                n.update(l, s, c)
            }
        }
        function Ju(t) {
            const e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++,
                    e.calls = 0,
                    e.triangles = 0,
                    e.points = 0,
                    e.lines = 0
                },
                update: function(t, n, i) {
                    switch (e.calls++,
                    n) {
                    case 4:
                        e.triangles += i * (t / 3);
                        break;
                    case 1:
                        e.lines += i * (t / 2);
                        break;
                    case 3:
                        e.lines += i * (t - 1);
                        break;
                    case 2:
                        e.lines += i * t;
                        break;
                    case 0:
                        e.points += i * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                    }
                }
            }
        }
        class Zu extends Xa {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = Vo,
                this.minFilter = Vo,
                this.wrapR = Uo,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        function Ku(t, e) {
            return t[0] - e[0]
        }
        function Qu(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }
        function $u(t, e) {
            let n = 1;
            const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
            i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i),
            t.divideScalar(n)
        }
        function th(t, e, n) {
            const i = {}
              , r = new Float32Array(8)
              , s = new WeakMap
              , o = new $a
              , a = [];
            for (let t = 0; t < 8; t++)
                a[t] = [t, 0];
            return {
                update: function(l, c, u, h) {
                    const d = l.morphTargetInfluences;
                    if (!0 === e.isWebGL2) {
                        const i = c.morphAttributes.position.length;
                        let r = s.get(c);
                        if (void 0 === r || r.count !== i) {
                            void 0 !== r && r.texture.dispose();
                            const t = void 0 !== c.morphAttributes.normal
                              , n = c.morphAttributes.position
                              , a = c.morphAttributes.normal || []
                              , l = !0 === t ? 2 : 1;
                            let u = c.attributes.position.count * l
                              , h = 1;
                            u > e.maxTextureSize && (h = Math.ceil(u / e.maxTextureSize),
                            u = e.maxTextureSize);
                            const d = new Float32Array(u * h * 4 * i)
                              , p = new Zu(d,u,h,i);
                            p.format = ta,
                            p.type = Ko,
                            p.needsUpdate = !0;
                            const f = 4 * l;
                            for (let e = 0; e < i; e++) {
                                const i = n[e]
                                  , r = a[e]
                                  , s = u * h * 4 * e;
                                for (let e = 0; e < i.count; e++) {
                                    o.fromBufferAttribute(i, e),
                                    !0 === i.normalized && $u(o, i);
                                    const n = e * f;
                                    d[s + n + 0] = o.x,
                                    d[s + n + 1] = o.y,
                                    d[s + n + 2] = o.z,
                                    d[s + n + 3] = 0,
                                    !0 === t && (o.fromBufferAttribute(r, e),
                                    !0 === r.normalized && $u(o, r),
                                    d[s + n + 4] = o.x,
                                    d[s + n + 5] = o.y,
                                    d[s + n + 6] = o.z,
                                    d[s + n + 7] = 0)
                                }
                            }
                            r = {
                                count: i,
                                texture: p,
                                size: new Ia(u,h)
                            },
                            s.set(c, r),
                            c.addEventListener("dispose", (function t() {
                                p.dispose(),
                                s.delete(c),
                                c.removeEventListener("dispose", t)
                            }
                            ))
                        }
                        let a = 0;
                        for (let t = 0; t < d.length; t++)
                            a += d[t];
                        const l = c.morphTargetsRelative ? 1 : 1 - a;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", l),
                        h.getUniforms().setValue(t, "morphTargetInfluences", d),
                        h.getUniforms().setValue(t, "morphTargetsTexture", r.texture, n),
                        h.getUniforms().setValue(t, "morphTargetsTextureSize", r.size)
                    } else {
                        const e = void 0 === d ? 0 : d.length;
                        let n = i[c.id];
                        if (void 0 === n || n.length !== e) {
                            n = [];
                            for (let t = 0; t < e; t++)
                                n[t] = [t, 0];
                            i[c.id] = n
                        }
                        for (let t = 0; t < e; t++) {
                            const e = n[t];
                            e[0] = t,
                            e[1] = d[t]
                        }
                        n.sort(Qu);
                        for (let t = 0; t < 8; t++)
                            t < e && n[t][1] ? (a[t][0] = n[t][0],
                            a[t][1] = n[t][1]) : (a[t][0] = Number.MAX_SAFE_INTEGER,
                            a[t][1] = 0);
                        a.sort(Ku);
                        const s = c.morphAttributes.position
                          , o = c.morphAttributes.normal;
                        let l = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = a[t]
                              , n = e[0]
                              , i = e[1];
                            n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + t) !== s[n] && c.setAttribute("morphTarget" + t, s[n]),
                            o && c.getAttribute("morphNormal" + t) !== o[n] && c.setAttribute("morphNormal" + t, o[n]),
                            r[t] = i,
                            l += i) : (s && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t),
                            o && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t),
                            r[t] = 0)
                        }
                        const u = c.morphTargetsRelative ? 1 : 1 - l;
                        h.getUniforms().setValue(t, "morphTargetBaseInfluence", u),
                        h.getUniforms().setValue(t, "morphTargetInfluences", r)
                    }
                }
            }
        }
        function eh(t, e, n, i) {
            let r = new WeakMap;
            function s(t) {
                const e = t.target;
                e.removeEventListener("dispose", s),
                n.remove(e.instanceMatrix),
                null !== e.instanceColor && n.remove(e.instanceColor)
            }
            return {
                update: function(t) {
                    const o = i.render.frame
                      , a = t.geometry
                      , l = e.get(t, a);
                    return r.get(l) !== o && (e.update(l),
                    r.set(l, o)),
                    t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s),
                    n.update(t.instanceMatrix, 34962),
                    null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                    l
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        Zu.prototype.isDataTexture2DArray = !0;
        class nh extends Xa {
            constructor(t=null, e=1, n=1, i=1) {
                super(null),
                this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: i
                },
                this.magFilter = Vo,
                this.minFilter = Vo,
                this.wrapR = Uo,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        nh.prototype.isDataTexture3D = !0;
        const ih = new Xa
          , rh = new Zu
          , sh = new nh
          , oh = new ru
          , ah = []
          , lh = []
          , ch = new Float32Array(16)
          , uh = new Float32Array(9)
          , hh = new Float32Array(4);
        function dh(t, e, n) {
            const i = t[0];
            if (i <= 0 || i > 0)
                return t;
            const r = e * n;
            let s = ah[r];
            if (void 0 === s && (s = new Float32Array(r),
            ah[r] = s),
            0 !== e) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== e; ++i)
                    r += n,
                    t[i].toArray(s, r)
            }
            return s
        }
        function ph(t, e) {
            if (t.length !== e.length)
                return !1;
            for (let n = 0, i = t.length; n < i; n++)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        function fh(t, e) {
            for (let n = 0, i = e.length; n < i; n++)
                t[n] = e[n]
        }
        function mh(t, e) {
            let n = lh[e];
            void 0 === n && (n = new Int32Array(e),
            lh[e] = n);
            for (let i = 0; i !== e; ++i)
                n[i] = t.allocateTextureUnit();
            return n
        }
        function gh(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1f(this.addr, e),
            n[0] = e)
        }
        function vh(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
                n[0] = e.x,
                n[1] = e.y);
            else {
                if (ph(n, e))
                    return;
                t.uniform2fv(this.addr, e),
                fh(n, e)
            }
        }
        function yh(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z);
            else if (void 0 !== e.r)
                n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
                n[0] = e.r,
                n[1] = e.g,
                n[2] = e.b);
            else {
                if (ph(n, e))
                    return;
                t.uniform3fv(this.addr, e),
                fh(n, e)
            }
        }
        function xh(t, e) {
            const n = this.cache;
            if (void 0 !== e.x)
                n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                n[0] = e.x,
                n[1] = e.y,
                n[2] = e.z,
                n[3] = e.w);
            else {
                if (ph(n, e))
                    return;
                t.uniform4fv(this.addr, e),
                fh(n, e)
            }
        }
        function _h(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (ph(n, e))
                    return;
                t.uniformMatrix2fv(this.addr, !1, e),
                fh(n, e)
            } else {
                if (ph(n, i))
                    return;
                hh.set(i),
                t.uniformMatrix2fv(this.addr, !1, hh),
                fh(n, i)
            }
        }
        function bh(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (ph(n, e))
                    return;
                t.uniformMatrix3fv(this.addr, !1, e),
                fh(n, e)
            } else {
                if (ph(n, i))
                    return;
                uh.set(i),
                t.uniformMatrix3fv(this.addr, !1, uh),
                fh(n, i)
            }
        }
        function wh(t, e) {
            const n = this.cache
              , i = e.elements;
            if (void 0 === i) {
                if (ph(n, e))
                    return;
                t.uniformMatrix4fv(this.addr, !1, e),
                fh(n, e)
            } else {
                if (ph(n, i))
                    return;
                ch.set(i),
                t.uniformMatrix4fv(this.addr, !1, ch),
                fh(n, i)
            }
        }
        function Mh(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1i(this.addr, e),
            n[0] = e)
        }
        function Sh(t, e) {
            const n = this.cache;
            ph(n, e) || (t.uniform2iv(this.addr, e),
            fh(n, e))
        }
        function Th(t, e) {
            const n = this.cache;
            ph(n, e) || (t.uniform3iv(this.addr, e),
            fh(n, e))
        }
        function Eh(t, e) {
            const n = this.cache;
            ph(n, e) || (t.uniform4iv(this.addr, e),
            fh(n, e))
        }
        function Ah(t, e) {
            const n = this.cache;
            n[0] !== e && (t.uniform1ui(this.addr, e),
            n[0] = e)
        }
        function Ch(t, e) {
            const n = this.cache;
            ph(n, e) || (t.uniform2uiv(this.addr, e),
            fh(n, e))
        }
        function Rh(t, e) {
            const n = this.cache;
            ph(n, e) || (t.uniform3uiv(this.addr, e),
            fh(n, e))
        }
        function Lh(t, e) {
            const n = this.cache;
            ph(n, e) || (t.uniform4uiv(this.addr, e),
            fh(n, e))
        }
        function Ph(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.safeSetTexture2D(e || ih, r)
        }
        function Dh(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture3D(e || sh, r)
        }
        function Ih(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.safeSetTextureCube(e || oh, r)
        }
        function Oh(t, e, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (t.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2DArray(e || rh, r)
        }
        function Nh(t, e) {
            t.uniform1fv(this.addr, e)
        }
        function kh(t, e) {
            const n = dh(e, this.size, 2);
            t.uniform2fv(this.addr, n)
        }
        function zh(t, e) {
            const n = dh(e, this.size, 3);
            t.uniform3fv(this.addr, n)
        }
        function Hh(t, e) {
            const n = dh(e, this.size, 4);
            t.uniform4fv(this.addr, n)
        }
        function Bh(t, e) {
            const n = dh(e, this.size, 4);
            t.uniformMatrix2fv(this.addr, !1, n)
        }
        function Fh(t, e) {
            const n = dh(e, this.size, 9);
            t.uniformMatrix3fv(this.addr, !1, n)
        }
        function Uh(t, e) {
            const n = dh(e, this.size, 16);
            t.uniformMatrix4fv(this.addr, !1, n)
        }
        function Gh(t, e) {
            t.uniform1iv(this.addr, e)
        }
        function Vh(t, e) {
            t.uniform2iv(this.addr, e)
        }
        function Wh(t, e) {
            t.uniform3iv(this.addr, e)
        }
        function jh(t, e) {
            t.uniform4iv(this.addr, e)
        }
        function qh(t, e) {
            t.uniform1uiv(this.addr, e)
        }
        function Xh(t, e) {
            t.uniform2uiv(this.addr, e)
        }
        function Yh(t, e) {
            t.uniform3uiv(this.addr, e)
        }
        function Jh(t, e) {
            t.uniform4uiv(this.addr, e)
        }
        function Zh(t, e, n) {
            const i = e.length
              , r = mh(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t)
                n.safeSetTexture2D(e[t] || ih, r[t])
        }
        function Kh(t, e, n) {
            const i = e.length
              , r = mh(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t)
                n.setTexture3D(e[t] || sh, r[t])
        }
        function Qh(t, e, n) {
            const i = e.length
              , r = mh(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t)
                n.safeSetTextureCube(e[t] || oh, r[t])
        }
        function $h(t, e, n) {
            const i = e.length
              , r = mh(n, i);
            t.uniform1iv(this.addr, r);
            for (let t = 0; t !== i; ++t)
                n.setTexture2DArray(e[t] || rh, r[t])
        }
        function td(t, e, n) {
            this.id = t,
            this.addr = n,
            this.cache = [],
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return gh;
                case 35664:
                    return vh;
                case 35665:
                    return yh;
                case 35666:
                    return xh;
                case 35674:
                    return _h;
                case 35675:
                    return bh;
                case 35676:
                    return wh;
                case 5124:
                case 35670:
                    return Mh;
                case 35667:
                case 35671:
                    return Sh;
                case 35668:
                case 35672:
                    return Th;
                case 35669:
                case 35673:
                    return Eh;
                case 5125:
                    return Ah;
                case 36294:
                    return Ch;
                case 36295:
                    return Rh;
                case 36296:
                    return Lh;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Ph;
                case 35679:
                case 36299:
                case 36307:
                    return Dh;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Ih;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return Oh
                }
            }(e.type)
        }
        function ed(t, e, n) {
            this.id = t,
            this.addr = n,
            this.cache = [],
            this.size = e.size,
            this.setValue = function(t) {
                switch (t) {
                case 5126:
                    return Nh;
                case 35664:
                    return kh;
                case 35665:
                    return zh;
                case 35666:
                    return Hh;
                case 35674:
                    return Bh;
                case 35675:
                    return Fh;
                case 35676:
                    return Uh;
                case 5124:
                case 35670:
                    return Gh;
                case 35667:
                case 35671:
                    return Vh;
                case 35668:
                case 35672:
                    return Wh;
                case 35669:
                case 35673:
                    return jh;
                case 5125:
                    return qh;
                case 36294:
                    return Xh;
                case 36295:
                    return Yh;
                case 36296:
                    return Jh;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Zh;
                case 35679:
                case 36299:
                case 36307:
                    return Kh;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Qh;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return $h
                }
            }(e.type)
        }
        function nd(t) {
            this.id = t,
            this.seq = [],
            this.map = {}
        }
        ed.prototype.updateCache = function(t) {
            const e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
            fh(e, t)
        }
        ,
        nd.prototype.setValue = function(t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
                const s = i[r];
                s.setValue(t, e[s.id], n)
            }
        }
        ;
        const id = /(\w+)(\])?(\[|\.)?/g;
        function rd(t, e) {
            t.seq.push(e),
            t.map[e.id] = e
        }
        function sd(t, e, n) {
            const i = t.name
              , r = i.length;
            for (id.lastIndex = 0; ; ) {
                const s = id.exec(i)
                  , o = id.lastIndex;
                let a = s[1];
                const l = "]" === s[2]
                  , c = s[3];
                if (l && (a |= 0),
                void 0 === c || "[" === c && o + 2 === r) {
                    rd(n, void 0 === c ? new td(a,t,e) : new ed(a,t,e));
                    break
                }
                {
                    let t = n.map[a];
                    void 0 === t && (t = new nd(a),
                    rd(n, t)),
                    n = t
                }
            }
        }
        function od(t, e) {
            this.seq = [],
            this.map = {};
            const n = t.getProgramParameter(e, 35718);
            for (let i = 0; i < n; ++i) {
                const n = t.getActiveUniform(e, i);
                sd(n, t.getUniformLocation(e, n.name), this)
            }
        }
        function ad(t, e, n) {
            const i = t.createShader(e);
            return t.shaderSource(i, n),
            t.compileShader(i),
            i
        }
        od.prototype.setValue = function(t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i)
        }
        ,
        od.prototype.setOptional = function(t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i)
        }
        ,
        od.upload = function(t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
                const s = e[r]
                  , o = n[s.id];
                !1 !== o.needsUpdate && s.setValue(t, o.value, i)
            }
        }
        ,
        od.seqWithValue = function(t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
                const r = t[i];
                r.id in e && n.push(r)
            }
            return n
        }
        ;
        let ld = 0;
        function cd(t, e, n) {
            const i = t.getShaderParameter(e, 35713)
              , r = t.getShaderInfoLog(e).trim();
            return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(t) {
                const e = t.split("\n");
                for (let t = 0; t < e.length; t++)
                    e[t] = t + 1 + ": " + e[t];
                return e.join("\n")
            }(t.getShaderSource(e))
        }
        function ud(t, e) {
            const n = function(t) {
                switch (t) {
                case pa:
                    return ["Linear", "( value )"];
                case fa:
                    return ["sRGB", "( value )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                    ["Linear", "( value )"]
                }
            }(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }
        function hd(t, e) {
            let n;
            switch (e) {
            case 1:
                n = "Linear";
                break;
            case 2:
                n = "Reinhard";
                break;
            case 3:
                n = "OptimizedCineon";
                break;
            case 4:
                n = "ACESFilmic";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                n = "Linear"
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        function dd(t) {
            return "" !== t
        }
        function pd(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }
        function fd(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }
        const md = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function gd(t) {
            return t.replace(md, vd)
        }
        function vd(t, e) {
            const n = gu[e];
            if (void 0 === n)
                throw new Error("Can not resolve #include <" + e + ">");
            return gd(n)
        }
        const yd = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
          , xd = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function _d(t) {
            return t.replace(xd, wd).replace(yd, bd)
        }
        function bd(t, e, n, i) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
            wd(0, e, n, i)
        }
        function wd(t, e, n, i) {
            let r = "";
            for (let t = parseInt(e); t < parseInt(n); t++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
            return r
        }
        function Md(t) {
            let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
        }
        function Sd(t, e, n, i) {
            const r = t.getContext()
              , s = n.defines;
            let o = n.vertexShader
              , a = n.fragmentShader;
            const l = function(t) {
                let e = "SHADOWMAP_TYPE_BASIC";
                return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
                e
            }(n)
              , c = function(t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case zo:
                    case Ho:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case Bo:
                    case 307:
                        e = "ENVMAP_TYPE_CUBE_UV"
                    }
                return e
            }(n)
              , u = function(t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap)
                    switch (t.envMapMode) {
                    case Ho:
                    case 307:
                        e = "ENVMAP_MODE_REFRACTION"
                    }
                return e
            }(n)
              , h = function(t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap)
                    switch (t.combine) {
                    case 0:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        e = "ENVMAP_BLENDING_ADD"
                    }
                return e
            }(n)
              , d = n.isWebGL2 ? "" : function(t) {
                return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(dd).join("\n")
            }(n)
              , p = function(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(s)
              , f = r.createProgram();
            let m, g, v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (m = [p].filter(dd).join("\n"),
            m.length > 0 && (m += "\n"),
            g = [d, p].filter(dd).join("\n"),
            g.length > 0 && (g += "\n")) : (m = [Md(n), "#define SHADER_NAME " + n.shaderName, p, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(dd).join("\n"),
            g = [d, Md(n), "#define SHADER_NAME " + n.shaderName, p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? gu.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? hd("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.transparent ? "" : "#define OPAQUE", gu.encodings_pars_fragment, ud("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(dd).join("\n")),
            o = gd(o),
            o = pd(o, n),
            o = fd(o, n),
            a = gd(a),
            a = pd(a, n),
            a = fd(a, n),
            o = _d(o),
            a = _d(a),
            n.isWebGL2 && !0 !== n.isRawShaderMaterial && (v = "#version 300 es\n",
            m = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m,
            g = ["#define varying in", n.glslVersion === ya ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === ya ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + g);
            const y = v + g + a
              , x = ad(r, 35633, v + m + o)
              , _ = ad(r, 35632, y);
            if (r.attachShader(f, x),
            r.attachShader(f, _),
            void 0 !== n.index0AttributeName ? r.bindAttribLocation(f, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"),
            r.linkProgram(f),
            t.debug.checkShaderErrors) {
                const t = r.getProgramInfoLog(f).trim()
                  , e = r.getShaderInfoLog(x).trim()
                  , n = r.getShaderInfoLog(_).trim();
                let i = !0
                  , s = !0;
                if (!1 === r.getProgramParameter(f, 35714)) {
                    i = !1;
                    const e = cd(r, x, "vertex")
                      , n = cd(r, _, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(f, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                } else
                    "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
                s && (this.diagnostics = {
                    runnable: i,
                    programLog: t,
                    vertexShader: {
                        log: e,
                        prefix: m
                    },
                    fragmentShader: {
                        log: n,
                        prefix: g
                    }
                })
            }
            let b, w;
            return r.deleteShader(x),
            r.deleteShader(_),
            this.getUniforms = function() {
                return void 0 === b && (b = new od(r,f)),
                b
            }
            ,
            this.getAttributes = function() {
                return void 0 === w && (w = function(t, e) {
                    const n = {}
                      , i = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < i; r++) {
                        const i = t.getActiveAttrib(e, r)
                          , s = i.name;
                        let o = 1;
                        35674 === i.type && (o = 2),
                        35675 === i.type && (o = 3),
                        35676 === i.type && (o = 4),
                        n[s] = {
                            type: i.type,
                            location: t.getAttribLocation(e, s),
                            locationSize: o
                        }
                    }
                    return n
                }(r, f)),
                w
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                r.deleteProgram(f),
                this.program = void 0
            }
            ,
            this.name = n.shaderName,
            this.id = ld++,
            this.cacheKey = e,
            this.usedTimes = 1,
            this.program = f,
            this.vertexShader = x,
            this.fragmentShader = _,
            this
        }
        let Td = 0;
        class Ed {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(t) {
                const e = t.vertexShader
                  , n = t.fragmentShader
                  , i = this._getShaderStage(e)
                  , r = this._getShaderStage(n)
                  , s = this._getShaderCacheForMaterial(t);
                return !1 === s.has(i) && (s.add(i),
                i.usedTimes++),
                !1 === s.has(r) && (s.add(r),
                r.usedTimes++),
                this
            }
            remove(t) {
                const e = this.materialCache.get(t);
                for (const t of e)
                    t.usedTimes--,
                    0 === t.usedTimes && this.shaderCache.delete(t);
                return this.materialCache.delete(t),
                this
            }
            getVertexShaderID(t) {
                return this._getShaderStage(t.vertexShader).id
            }
            getFragmentShaderID(t) {
                return this._getShaderStage(t.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(t) {
                const e = this.materialCache;
                return !1 === e.has(t) && e.set(t, new Set),
                e.get(t)
            }
            _getShaderStage(t) {
                const e = this.shaderCache;
                if (!1 === e.has(t)) {
                    const n = new Ad;
                    e.set(t, n)
                }
                return e.get(t)
            }
        }
        class Ad {
            constructor() {
                this.id = Td++,
                this.usedTimes = 0
            }
        }
        function Cd(t, e, n, i, r, s, o) {
            const a = new Ul
              , l = new Ed
              , c = []
              , u = r.isWebGL2
              , h = r.logarithmicDepthBuffer
              , d = r.floatVertexTextures
              , p = r.maxVertexUniforms
              , f = r.vertexTextures;
            let m = r.precision;
            const g = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            return {
                getParameters: function(s, a, c, v, y) {
                    const x = v.fog
                      , _ = s.isMeshStandardMaterial ? v.environment : null
                      , b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || _)
                      , w = g[s.type]
                      , M = y.isSkinnedMesh ? function(t) {
                        const e = t.skeleton.bones;
                        if (d)
                            return 1024;
                        {
                            const t = p
                              , n = Math.floor((t - 20) / 4)
                              , i = Math.min(n, e.length);
                            return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."),
                            0) : i
                        }
                    }(y) : 0;
                    let S, T, E, A;
                    if (null !== s.precision && (m = r.getMaxPrecision(s.precision),
                    m !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", m, "instead.")),
                    w) {
                        const t = yu[w];
                        S = t.vertexShader,
                        T = t.fragmentShader
                    } else
                        S = s.vertexShader,
                        T = s.fragmentShader,
                        l.update(s),
                        E = l.getVertexShaderID(s),
                        A = l.getFragmentShaderID(s);
                    const C = t.getRenderTarget()
                      , R = s.alphaTest > 0
                      , L = s.clearcoat > 0;
                    return {
                        isWebGL2: u,
                        shaderID: w,
                        shaderName: s.type,
                        vertexShader: S,
                        fragmentShader: T,
                        defines: s.defines,
                        customVertexShaderID: E,
                        customFragmentShaderID: A,
                        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                        glslVersion: s.glslVersion,
                        precision: m,
                        instancing: !0 === y.isInstancedMesh,
                        instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
                        supportsVertexTextures: f,
                        outputEncoding: null === C ? t.outputEncoding : !0 === C.isXRRenderTarget ? C.texture.encoding : pa,
                        map: !!s.map,
                        matcap: !!s.matcap,
                        envMap: !!b,
                        envMapMode: b && b.mapping,
                        envMapCubeUV: !!b && (b.mapping === Bo || 307 === b.mapping),
                        lightMap: !!s.lightMap,
                        aoMap: !!s.aoMap,
                        emissiveMap: !!s.emissiveMap,
                        bumpMap: !!s.bumpMap,
                        normalMap: !!s.normalMap,
                        objectSpaceNormalMap: 1 === s.normalMapType,
                        tangentSpaceNormalMap: 0 === s.normalMapType,
                        decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === fa,
                        clearcoat: L,
                        clearcoatMap: L && !!s.clearcoatMap,
                        clearcoatRoughnessMap: L && !!s.clearcoatRoughnessMap,
                        clearcoatNormalMap: L && !!s.clearcoatNormalMap,
                        displacementMap: !!s.displacementMap,
                        roughnessMap: !!s.roughnessMap,
                        metalnessMap: !!s.metalnessMap,
                        specularMap: !!s.specularMap,
                        specularIntensityMap: !!s.specularIntensityMap,
                        specularColorMap: !!s.specularColorMap,
                        transparent: s.transparent,
                        alphaMap: !!s.alphaMap,
                        alphaTest: R,
                        gradientMap: !!s.gradientMap,
                        sheen: s.sheen > 0,
                        sheenColorMap: !!s.sheenColorMap,
                        sheenRoughnessMap: !!s.sheenRoughnessMap,
                        transmission: s.transmission > 0,
                        transmissionMap: !!s.transmissionMap,
                        thicknessMap: !!s.thicknessMap,
                        combine: s.combine,
                        vertexTangents: !!s.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
                        vertexColors: s.vertexColors,
                        vertexAlphas: !0 === s.vertexColors && !!y.geometry && !!y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
                        vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                        uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                        fog: !!x,
                        useFog: s.fog,
                        fogExp2: x && x.isFogExp2,
                        flatShading: !!s.flatShading,
                        sizeAttenuation: s.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === y.isSkinnedMesh && M > 0,
                        maxBones: M,
                        useVertexTexture: d,
                        morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
                        morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
                        morphTargetsCount: y.geometry && y.geometry.morphAttributes.position ? y.geometry.morphAttributes.position.length : 0,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numClippingPlanes: o.numPlanes,
                        numClipIntersection: o.numIntersection,
                        dithering: s.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: s.toneMapped ? t.toneMapping : 0,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: s.premultipliedAlpha,
                        doubleSided: 2 === s.side,
                        flipSided: 1 === s.side,
                        depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                        index0AttributeName: s.index0AttributeName,
                        extensionDerivatives: s.extensions && s.extensions.derivatives,
                        extensionFragDepth: s.extensions && s.extensions.fragDepth,
                        extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                        extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: s.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(e) {
                    const n = [];
                    if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID),
                    n.push(e.customFragmentShaderID)),
                    void 0 !== e.defines)
                        for (const t in e.defines)
                            n.push(t),
                            n.push(e.defines[t]);
                    return !1 === e.isRawShaderMaterial && (function(t, e) {
                        t.push(e.precision),
                        t.push(e.outputEncoding),
                        t.push(e.envMapMode),
                        t.push(e.combine),
                        t.push(e.vertexUvs),
                        t.push(e.fogExp2),
                        t.push(e.sizeAttenuation),
                        t.push(e.maxBones),
                        t.push(e.morphTargetsCount),
                        t.push(e.numDirLights),
                        t.push(e.numPointLights),
                        t.push(e.numSpotLights),
                        t.push(e.numHemiLights),
                        t.push(e.numRectAreaLights),
                        t.push(e.numDirLightShadows),
                        t.push(e.numPointLightShadows),
                        t.push(e.numSpotLightShadows),
                        t.push(e.shadowMapType),
                        t.push(e.toneMapping),
                        t.push(e.numClippingPlanes),
                        t.push(e.numClipIntersection)
                    }(n, e),
                    function(t, e) {
                        a.disableAll(),
                        e.isWebGL2 && a.enable(0),
                        e.supportsVertexTextures && a.enable(1),
                        e.instancing && a.enable(2),
                        e.instancingColor && a.enable(3),
                        e.map && a.enable(4),
                        e.matcap && a.enable(5),
                        e.envMap && a.enable(6),
                        e.envMapCubeUV && a.enable(7),
                        e.lightMap && a.enable(8),
                        e.aoMap && a.enable(9),
                        e.emissiveMap && a.enable(10),
                        e.bumpMap && a.enable(11),
                        e.normalMap && a.enable(12),
                        e.objectSpaceNormalMap && a.enable(13),
                        e.tangentSpaceNormalMap && a.enable(14),
                        e.clearcoat && a.enable(15),
                        e.clearcoatMap && a.enable(16),
                        e.clearcoatRoughnessMap && a.enable(17),
                        e.clearcoatNormalMap && a.enable(18),
                        e.displacementMap && a.enable(19),
                        e.specularMap && a.enable(20),
                        e.roughnessMap && a.enable(21),
                        e.metalnessMap && a.enable(22),
                        e.gradientMap && a.enable(23),
                        e.alphaMap && a.enable(24),
                        e.alphaTest && a.enable(25),
                        e.vertexColors && a.enable(26),
                        e.vertexAlphas && a.enable(27),
                        e.vertexUvs && a.enable(28),
                        e.vertexTangents && a.enable(29),
                        e.uvsVertexOnly && a.enable(30),
                        e.fog && a.enable(31),
                        t.push(a.mask),
                        a.disableAll(),
                        e.useFog && a.enable(0),
                        e.flatShading && a.enable(1),
                        e.logarithmicDepthBuffer && a.enable(2),
                        e.skinning && a.enable(3),
                        e.useVertexTexture && a.enable(4),
                        e.morphTargets && a.enable(5),
                        e.morphNormals && a.enable(6),
                        e.premultipliedAlpha && a.enable(7),
                        e.shadowMapEnabled && a.enable(8),
                        e.physicallyCorrectLights && a.enable(9),
                        e.doubleSided && a.enable(10),
                        e.flipSided && a.enable(11),
                        e.depthPacking && a.enable(12),
                        e.dithering && a.enable(13),
                        e.specularIntensityMap && a.enable(14),
                        e.specularColorMap && a.enable(15),
                        e.transmission && a.enable(16),
                        e.transmissionMap && a.enable(17),
                        e.thicknessMap && a.enable(18),
                        e.sheen && a.enable(19),
                        e.sheenColorMap && a.enable(20),
                        e.sheenRoughnessMap && a.enable(21),
                        e.decodeVideoTexture && a.enable(22),
                        e.transparent && a.enable(23),
                        t.push(a.mask)
                    }(n, e),
                    n.push(t.outputEncoding)),
                    n.push(e.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(t) {
                    const e = g[t.type];
                    let n;
                    if (e) {
                        const t = yu[e];
                        n = Qc.clone(t.uniforms)
                    } else
                        n = t.uniforms;
                    return n
                },
                acquireProgram: function(e, n) {
                    let i;
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        if (e.cacheKey === n) {
                            i = e,
                            ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new Sd(t,n,e,s),
                    c.push(i)),
                    i
                },
                releaseProgram: function(t) {
                    if (0 == --t.usedTimes) {
                        const e = c.indexOf(t);
                        c[e] = c[c.length - 1],
                        c.pop(),
                        t.destroy()
                    }
                },
                releaseShaderCache: function(t) {
                    l.remove(t)
                },
                programs: c,
                dispose: function() {
                    l.dispose()
                }
            }
        }
        function Rd() {
            let t = new WeakMap;
            return {
                get: function(e) {
                    let n = t.get(e);
                    return void 0 === n && (n = {},
                    t.set(e, n)),
                    n
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, n, i) {
                    t.get(e)[n] = i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function Ld(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }
        function Pd(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }
        function Dd() {
            const t = [];
            let e = 0;
            const n = []
              , i = []
              , r = [];
            function s(n, i, r, s, o, a) {
                let l = t[e];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: o,
                    group: a
                },
                t[e] = l) : (l.id = n.id,
                l.object = n,
                l.geometry = i,
                l.material = r,
                l.groupOrder = s,
                l.renderOrder = n.renderOrder,
                l.z = o,
                l.group = a),
                e++,
                l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    e = 0,
                    n.length = 0,
                    i.length = 0,
                    r.length = 0
                },
                push: function(t, e, o, a, l, c) {
                    const u = s(t, e, o, a, l, c);
                    o.transmission > 0 ? i.push(u) : !0 === o.transparent ? r.push(u) : n.push(u)
                },
                unshift: function(t, e, o, a, l, c) {
                    const u = s(t, e, o, a, l, c);
                    o.transmission > 0 ? i.unshift(u) : !0 === o.transparent ? r.unshift(u) : n.unshift(u)
                },
                finish: function() {
                    for (let n = e, i = t.length; n < i; n++) {
                        const e = t[n];
                        if (null === e.id)
                            break;
                        e.id = null,
                        e.object = null,
                        e.geometry = null,
                        e.material = null,
                        e.group = null
                    }
                },
                sort: function(t, e) {
                    n.length > 1 && n.sort(t || Ld),
                    i.length > 1 && i.sort(e || Pd),
                    r.length > 1 && r.sort(e || Pd)
                }
            }
        }
        function Id() {
            let t = new WeakMap;
            return {
                get: function(e, n) {
                    let i;
                    return !1 === t.has(e) ? (i = new Dd,
                    t.set(e, [i])) : n >= t.get(e).length ? (i = new Dd,
                    t.get(e).push(i)) : i = t.get(e)[n],
                    i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        function Od() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new $a,
                            color: new Va
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new $a,
                            direction: new $a,
                            color: new Va,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new $a,
                            color: new Va,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new $a,
                            skyColor: new Va,
                            groundColor: new Va
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Va,
                            position: new $a,
                            halfWidth: new $a,
                            halfHeight: new $a
                        }
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }
        let Nd = 0;
        function kd(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }
        function zd(t, e) {
            const n = new Od
              , i = function() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id])
                            return t[e.id];
                        let n;
                        switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Ia
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Ia,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return t[e.id] = n,
                        n
                    }
                }
            }()
              , r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadow: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: []
            };
            for (let t = 0; t < 9; t++)
                r.probe.push(new $a);
            const s = new $a
              , o = new Ll
              , a = new Ll;
            return {
                setup: function(s, o) {
                    let a = 0
                      , l = 0
                      , c = 0;
                    for (let t = 0; t < 9; t++)
                        r.probe[t].set(0, 0, 0);
                    let u = 0
                      , h = 0
                      , d = 0
                      , p = 0
                      , f = 0
                      , m = 0
                      , g = 0
                      , v = 0;
                    s.sort(kd);
                    const y = !0 !== o ? Math.PI : 1;
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t]
                          , o = e.color
                          , x = e.intensity
                          , _ = e.distance
                          , b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                        if (e.isAmbientLight)
                            a += o.r * x * y,
                            l += o.g * x * y,
                            c += o.b * x * y;
                        else if (e.isLightProbe)
                            for (let t = 0; t < 9; t++)
                                r.probe[t].addScaledVector(e.sh.coefficients[t], x);
                        else if (e.isDirectionalLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                r.directionalShadow[u] = n,
                                r.directionalShadowMap[u] = b,
                                r.directionalShadowMatrix[u] = e.shadow.matrix,
                                m++
                            }
                            r.directional[u] = t,
                            u++
                        } else if (e.isSpotLight) {
                            const t = n.get(e);
                            if (t.position.setFromMatrixPosition(e.matrixWorld),
                            t.color.copy(o).multiplyScalar(x * y),
                            t.distance = _,
                            t.coneCos = Math.cos(e.angle),
                            t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                r.spotShadow[d] = n,
                                r.spotShadowMap[d] = b,
                                r.spotShadowMatrix[d] = e.shadow.matrix,
                                v++
                            }
                            r.spot[d] = t,
                            d++
                        } else if (e.isRectAreaLight) {
                            const t = n.get(e);
                            t.color.copy(o).multiplyScalar(x),
                            t.halfWidth.set(.5 * e.width, 0, 0),
                            t.halfHeight.set(0, .5 * e.height, 0),
                            r.rectArea[p] = t,
                            p++
                        } else if (e.isPointLight) {
                            const t = n.get(e);
                            if (t.color.copy(e.color).multiplyScalar(e.intensity * y),
                            t.distance = e.distance,
                            t.decay = e.decay,
                            e.castShadow) {
                                const t = e.shadow
                                  , n = i.get(e);
                                n.shadowBias = t.bias,
                                n.shadowNormalBias = t.normalBias,
                                n.shadowRadius = t.radius,
                                n.shadowMapSize = t.mapSize,
                                n.shadowCameraNear = t.camera.near,
                                n.shadowCameraFar = t.camera.far,
                                r.pointShadow[h] = n,
                                r.pointShadowMap[h] = b,
                                r.pointShadowMatrix[h] = e.shadow.matrix,
                                g++
                            }
                            r.point[h] = t,
                            h++
                        } else if (e.isHemisphereLight) {
                            const t = n.get(e);
                            t.skyColor.copy(e.color).multiplyScalar(x * y),
                            t.groundColor.copy(e.groundColor).multiplyScalar(x * y),
                            r.hemi[f] = t,
                            f++
                        }
                    }
                    p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = vu.LTC_FLOAT_1,
                    r.rectAreaLTC2 = vu.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = vu.LTC_HALF_1,
                    r.rectAreaLTC2 = vu.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    r.ambient[0] = a,
                    r.ambient[1] = l,
                    r.ambient[2] = c;
                    const x = r.hash;
                    x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v || (r.directional.length = u,
                    r.spot.length = d,
                    r.rectArea.length = p,
                    r.point.length = h,
                    r.hemi.length = f,
                    r.directionalShadow.length = m,
                    r.directionalShadowMap.length = m,
                    r.pointShadow.length = g,
                    r.pointShadowMap.length = g,
                    r.spotShadow.length = v,
                    r.spotShadowMap.length = v,
                    r.directionalShadowMatrix.length = m,
                    r.pointShadowMatrix.length = g,
                    r.spotShadowMatrix.length = v,
                    x.directionalLength = u,
                    x.pointLength = h,
                    x.spotLength = d,
                    x.rectAreaLength = p,
                    x.hemiLength = f,
                    x.numDirectionalShadows = m,
                    x.numPointShadows = g,
                    x.numSpotShadows = v,
                    r.version = Nd++)
                },
                setupView: function(t, e) {
                    let n = 0
                      , i = 0
                      , l = 0
                      , c = 0
                      , u = 0;
                    const h = e.matrixWorldInverse;
                    for (let e = 0, d = t.length; e < d; e++) {
                        const d = t[e];
                        if (d.isDirectionalLight) {
                            const t = r.directional[n];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(h),
                            n++
                        } else if (d.isSpotLight) {
                            const t = r.spot[l];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            s.setFromMatrixPosition(d.target.matrixWorld),
                            t.direction.sub(s),
                            t.direction.transformDirection(h),
                            l++
                        } else if (d.isRectAreaLight) {
                            const t = r.rectArea[c];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            a.identity(),
                            o.copy(d.matrixWorld),
                            o.premultiply(h),
                            a.extractRotation(o),
                            t.halfWidth.set(.5 * d.width, 0, 0),
                            t.halfHeight.set(0, .5 * d.height, 0),
                            t.halfWidth.applyMatrix4(a),
                            t.halfHeight.applyMatrix4(a),
                            c++
                        } else if (d.isPointLight) {
                            const t = r.point[i];
                            t.position.setFromMatrixPosition(d.matrixWorld),
                            t.position.applyMatrix4(h),
                            i++
                        } else if (d.isHemisphereLight) {
                            const t = r.hemi[u];
                            t.direction.setFromMatrixPosition(d.matrixWorld),
                            t.direction.transformDirection(h),
                            t.direction.normalize(),
                            u++
                        }
                    }
                },
                state: r
            }
        }
        function Hd(t, e) {
            const n = new zd(t,e)
              , i = []
              , r = [];
            return {
                init: function() {
                    i.length = 0,
                    r.length = 0
                },
                state: {
                    lightsArray: i,
                    shadowsArray: r,
                    lights: n
                },
                setupLights: function(t) {
                    n.setup(i, t)
                },
                setupLightsView: function(t) {
                    n.setupView(i, t)
                },
                pushLight: function(t) {
                    i.push(t)
                },
                pushShadow: function(t) {
                    r.push(t)
                }
            }
        }
        function Bd(t, e) {
            let n = new WeakMap;
            return {
                get: function(i, r=0) {
                    let s;
                    return !1 === n.has(i) ? (s = new Hd(t,e),
                    n.set(i, [s])) : r >= n.get(i).length ? (s = new Hd(t,e),
                    n.get(i).push(s)) : s = n.get(i)[r],
                    s
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class Fd extends fc {
            constructor(t) {
                super(),
                this.type = "MeshDepthMaterial",
                this.depthPacking = 3200,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.depthPacking = t.depthPacking,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this
            }
        }
        Fd.prototype.isMeshDepthMaterial = !0;
        class Ud extends fc {
            constructor(t) {
                super(),
                this.type = "MeshDistanceMaterial",
                this.referencePosition = new $a,
                this.nearDistance = 1,
                this.farDistance = 1e3,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.fog = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.referencePosition.copy(t.referencePosition),
                this.nearDistance = t.nearDistance,
                this.farDistance = t.farDistance,
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this
            }
        }
        function Gd(t, e, n) {
            let i = new du;
            const r = new Ia
              , s = new Ia
              , o = new Ja
              , a = new Fd({
                depthPacking: 3201
            })
              , l = new Ud
              , c = {}
              , u = n.maxTextureSize
              , h = {
                0: 1,
                1: 0,
                2: 2
            }
              , d = new $c({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new Ia
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            })
              , p = d.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new Rc;
            f.setAttribute("position", new yc(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const m = new Xc(f,d)
              , g = this;
            function v(n, i) {
                const r = e.update(m);
                d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples,
                p.defines.VSM_SAMPLES = n.blurSamples,
                d.needsUpdate = !0,
                p.needsUpdate = !0),
                d.uniforms.shadow_pass.value = n.map.texture,
                d.uniforms.resolution.value = n.mapSize,
                d.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.mapPass),
                t.clear(),
                t.renderBufferDirect(i, null, r, d, m, null),
                p.uniforms.shadow_pass.value = n.mapPass.texture,
                p.uniforms.resolution.value = n.mapSize,
                p.uniforms.radius.value = n.radius,
                t.setRenderTarget(n.map),
                t.clear(),
                t.renderBufferDirect(i, null, r, p, m, null)
            }
            function y(e, n, i, r, s, o, u) {
                let d = null;
                const p = !0 === r.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : a,
                t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                    const t = d.uuid
                      , e = i.uuid;
                    let n = c[t];
                    void 0 === n && (n = {},
                    c[t] = n);
                    let r = n[e];
                    void 0 === r && (r = d.clone(),
                    n[e] = r),
                    d = r
                }
                return d.visible = i.visible,
                d.wireframe = i.wireframe,
                d.side = 3 === u ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : h[i.side],
                d.alphaMap = i.alphaMap,
                d.alphaTest = i.alphaTest,
                d.clipShadows = i.clipShadows,
                d.clippingPlanes = i.clippingPlanes,
                d.clipIntersection = i.clipIntersection,
                d.displacementMap = i.displacementMap,
                d.displacementScale = i.displacementScale,
                d.displacementBias = i.displacementBias,
                d.wireframeLinewidth = i.wireframeLinewidth,
                d.linewidth = i.linewidth,
                !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
                d.nearDistance = s,
                d.farDistance = o),
                d
            }
            function x(n, r, s, o, a) {
                if (!1 === n.visible)
                    return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                    const i = e.update(n)
                      , r = n.material;
                    if (Array.isArray(r)) {
                        const e = i.groups;
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l]
                              , u = r[c.materialIndex];
                            if (u && u.visible) {
                                const e = y(n, 0, u, o, s.near, s.far, a);
                                t.renderBufferDirect(s, null, i, e, n, c)
                            }
                        }
                    } else if (r.visible) {
                        const e = y(n, 0, r, o, s.near, s.far, a);
                        t.renderBufferDirect(s, null, i, e, n, null)
                    }
                }
                const l = n.children;
                for (let t = 0, e = l.length; t < e; t++)
                    x(l[t], r, s, o, a)
            }
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = 1,
            this.render = function(e, n, a) {
                if (!1 === g.enabled)
                    return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate)
                    return;
                if (0 === e.length)
                    return;
                const l = t.getRenderTarget()
                  , c = t.getActiveCubeFace()
                  , h = t.getActiveMipmapLevel()
                  , d = t.state;
                d.setBlending(0),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
                for (let l = 0, c = e.length; l < c; l++) {
                    const c = e[l]
                      , h = c.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                        continue;
                    r.copy(h.mapSize);
                    const p = h.getFrameExtents();
                    if (r.multiply(p),
                    s.copy(h.mapSize),
                    (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / p.x),
                    r.x = s.x * p.x,
                    h.mapSize.x = s.x),
                    r.y > u && (s.y = Math.floor(u / p.y),
                    r.y = s.y * p.y,
                    h.mapSize.y = s.y)),
                    null === h.map && !h.isPointLightShadow && 3 === this.type) {
                        const t = {
                            minFilter: qo,
                            magFilter: qo,
                            format: ta
                        };
                        h.map = new Za(r.x,r.y,t),
                        h.map.texture.name = c.name + ".shadowMap",
                        h.mapPass = new Za(r.x,r.y,t),
                        h.camera.updateProjectionMatrix()
                    }
                    if (null === h.map) {
                        const t = {
                            minFilter: Vo,
                            magFilter: Vo,
                            format: ta
                        };
                        h.map = new Za(r.x,r.y,t),
                        h.map.texture.name = c.name + ".shadowMap",
                        h.camera.updateProjectionMatrix()
                    }
                    t.setRenderTarget(h.map),
                    t.clear();
                    const f = h.getViewportCount();
                    for (let t = 0; t < f; t++) {
                        const e = h.getViewport(t);
                        o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                        d.viewport(o),
                        h.updateMatrices(c, t),
                        i = h.getFrustum(),
                        x(n, a, h.camera, c, this.type)
                    }
                    h.isPointLightShadow || 3 !== this.type || v(h, a),
                    h.needsUpdate = !1
                }
                g.needsUpdate = !1,
                t.setRenderTarget(l, c, h)
            }
        }
        function Vd(t, e, n) {
            const i = n.isWebGL2
              , r = new function() {
                let e = !1;
                const n = new Ja;
                let i = null;
                const r = new Ja(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || e || (t.colorMask(n, n, n, n),
                        i = n)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e, i, s, o, a) {
                        !0 === a && (e *= o,
                        i *= o,
                        s *= o),
                        n.set(e, i, s, o),
                        !1 === r.equals(n) && (t.clearColor(e, i, s, o),
                        r.copy(n))
                    },
                    reset: function() {
                        e = !1,
                        i = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
              , s = new function() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null;
                return {
                    setTest: function(t) {
                        t ? H(2929) : B(2929)
                    },
                    setMask: function(i) {
                        n === i || e || (t.depthMask(i),
                        n = i)
                    },
                    setFunc: function(e) {
                        if (i !== e) {
                            if (e)
                                switch (e) {
                                case 0:
                                    t.depthFunc(512);
                                    break;
                                case 1:
                                    t.depthFunc(519);
                                    break;
                                case 2:
                                    t.depthFunc(513);
                                    break;
                                case 3:
                                    t.depthFunc(515);
                                    break;
                                case 4:
                                    t.depthFunc(514);
                                    break;
                                case 5:
                                    t.depthFunc(518);
                                    break;
                                case 6:
                                    t.depthFunc(516);
                                    break;
                                case 7:
                                    t.depthFunc(517);
                                    break;
                                default:
                                    t.depthFunc(515)
                                }
                            else
                                t.depthFunc(515);
                            i = e
                        }
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        r !== e && (t.clearDepth(e),
                        r = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null
                    }
                }
            }
              , o = new function() {
                let e = !1
                  , n = null
                  , i = null
                  , r = null
                  , s = null
                  , o = null
                  , a = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(t) {
                        e || (t ? H(2960) : B(2960))
                    },
                    setMask: function(i) {
                        n === i || e || (t.stencilMask(i),
                        n = i)
                    },
                    setFunc: function(e, n, o) {
                        i === e && r === n && s === o || (t.stencilFunc(e, n, o),
                        i = e,
                        r = n,
                        s = o)
                    },
                    setOp: function(e, n, i) {
                        o === e && a === n && l === i || (t.stencilOp(e, n, i),
                        o = e,
                        a = n,
                        l = i)
                    },
                    setLocked: function(t) {
                        e = t
                    },
                    setClear: function(e) {
                        c !== e && (t.clearStencil(e),
                        c = e)
                    },
                    reset: function() {
                        e = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        o = null,
                        a = null,
                        l = null,
                        c = null
                    }
                }
            }
            ;
            let a = {}
              , l = {}
              , c = new WeakMap
              , u = []
              , h = null
              , d = !1
              , p = null
              , f = null
              , m = null
              , g = null
              , v = null
              , y = null
              , x = null
              , _ = !1
              , b = null
              , w = null
              , M = null
              , S = null
              , T = null;
            const E = t.getParameter(35661);
            let A = !1
              , C = 0;
            const R = t.getParameter(7938);
            -1 !== R.indexOf("WebGL") ? (C = parseFloat(/^WebGL (\d)/.exec(R)[1]),
            A = C >= 1) : -1 !== R.indexOf("OpenGL ES") && (C = parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),
            A = C >= 2);
            let L = null
              , P = {};
            const D = t.getParameter(3088)
              , I = t.getParameter(2978)
              , O = (new Ja).fromArray(D)
              , N = (new Ja).fromArray(I);
            function k(e, n, i) {
                const r = new Uint8Array(4)
                  , s = t.createTexture();
                t.bindTexture(e, s),
                t.texParameteri(e, 10241, 9728),
                t.texParameteri(e, 10240, 9728);
                for (let e = 0; e < i; e++)
                    t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return s
            }
            const z = {};
            function H(e) {
                !0 !== a[e] && (t.enable(e),
                a[e] = !0)
            }
            function B(e) {
                !1 !== a[e] && (t.disable(e),
                a[e] = !1)
            }
            z[3553] = k(3553, 3553, 1),
            z[34067] = k(34067, 34069, 6),
            r.setClear(0, 0, 0, 1),
            s.setClear(1),
            o.setClear(0),
            H(2929),
            s.setFunc(3),
            V(!1),
            W(1),
            H(2884),
            G(0);
            const F = {
                [ko]: 32774,
                101: 32778,
                102: 32779
            };
            if (i)
                F[103] = 32775,
                F[104] = 32776;
            else {
                const t = e.get("EXT_blend_minmax");
                null !== t && (F[103] = t.MIN_EXT,
                F[104] = t.MAX_EXT)
            }
            const U = {
                200: 0,
                201: 1,
                202: 768,
                204: 770,
                210: 776,
                208: 774,
                206: 772,
                203: 769,
                205: 771,
                209: 775,
                207: 773
            };
            function G(e, n, i, r, s, o, a, l) {
                if (0 !== e) {
                    if (!1 === d && (H(3042),
                    d = !0),
                    5 === e)
                        s = s || n,
                        o = o || i,
                        a = a || r,
                        n === f && s === v || (t.blendEquationSeparate(F[n], F[s]),
                        f = n,
                        v = s),
                        i === m && r === g && o === y && a === x || (t.blendFuncSeparate(U[i], U[r], U[o], U[a]),
                        m = i,
                        g = r,
                        y = o,
                        x = a),
                        p = e,
                        _ = null;
                    else if (e !== p || l !== _) {
                        if (f === ko && v === ko || (t.blendEquation(32774),
                        f = ko,
                        v = ko),
                        l)
                            switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        else
                            switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 769, 0, 1);
                                break;
                            case 4:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                        m = null,
                        g = null,
                        y = null,
                        x = null,
                        p = e,
                        _ = l
                    }
                } else
                    !0 === d && (B(3042),
                    d = !1)
            }
            function V(e) {
                b !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
                b = e)
            }
            function W(e) {
                0 !== e ? (H(2884),
                e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : B(2884),
                w = e
            }
            function j(e, n, i) {
                e ? (H(32823),
                S === n && T === i || (t.polygonOffset(n, i),
                S = n,
                T = i)) : B(32823)
            }
            function q(e) {
                void 0 === e && (e = 33984 + E - 1),
                L !== e && (t.activeTexture(e),
                L = e)
            }
            return {
                buffers: {
                    color: r,
                    depth: s,
                    stencil: o
                },
                enable: H,
                disable: B,
                bindFramebuffer: function(e, n) {
                    return l[e] !== n && (t.bindFramebuffer(e, n),
                    l[e] = n,
                    i && (36009 === e && (l[36160] = n),
                    36160 === e && (l[36009] = n)),
                    !0)
                },
                drawBuffers: function(i, r) {
                    let s = u
                      , o = !1;
                    if (i)
                        if (s = c.get(r),
                        void 0 === s && (s = [],
                        c.set(r, s)),
                        i.isWebGLMultipleRenderTargets) {
                            const t = i.texture;
                            if (s.length !== t.length || 36064 !== s[0]) {
                                for (let e = 0, n = t.length; e < n; e++)
                                    s[e] = 36064 + e;
                                s.length = t.length,
                                o = !0
                            }
                        } else
                            36064 !== s[0] && (s[0] = 36064,
                            o = !0);
                    else
                        1029 !== s[0] && (s[0] = 1029,
                        o = !0);
                    o && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                },
                useProgram: function(e) {
                    return h !== e && (t.useProgram(e),
                    h = e,
                    !0)
                },
                setBlending: G,
                setMaterial: function(t, e) {
                    2 === t.side ? B(2884) : H(2884);
                    let n = 1 === t.side;
                    e && (n = !n),
                    V(n),
                    1 === t.blending && !1 === t.transparent ? G(0) : G(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                    s.setFunc(t.depthFunc),
                    s.setTest(t.depthTest),
                    s.setMask(t.depthWrite),
                    r.setMask(t.colorWrite);
                    const i = t.stencilWrite;
                    o.setTest(i),
                    i && (o.setMask(t.stencilWriteMask),
                    o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                    !0 === t.alphaToCoverage ? H(32926) : B(32926)
                },
                setFlipSided: V,
                setCullFace: W,
                setLineWidth: function(e) {
                    e !== M && (A && t.lineWidth(e),
                    M = e)
                },
                setPolygonOffset: j,
                setScissorTest: function(t) {
                    t ? H(3089) : B(3089)
                },
                activeTexture: q,
                bindTexture: function(e, n) {
                    null === L && q();
                    let i = P[L];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    },
                    P[L] = i),
                    i.type === e && i.texture === n || (t.bindTexture(e, n || z[e]),
                    i.type = e,
                    i.texture = n)
                },
                unbindTexture: function() {
                    const e = P[L];
                    void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                    e.type = void 0,
                    e.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage2D: function() {
                    try {
                        t.texStorage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function() {
                    try {
                        t.texStorage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function() {
                    try {
                        t.texSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function() {
                    try {
                        t.texSubImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        t.compressedTexSubImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === O.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                    O.copy(e))
                },
                viewport: function(e) {
                    !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                    N.copy(e))
                },
                reset: function() {
                    t.disable(3042),
                    t.disable(2884),
                    t.disable(2929),
                    t.disable(32823),
                    t.disable(3089),
                    t.disable(2960),
                    t.disable(32926),
                    t.blendEquation(32774),
                    t.blendFunc(1, 0),
                    t.blendFuncSeparate(1, 0, 1, 0),
                    t.colorMask(!0, !0, !0, !0),
                    t.clearColor(0, 0, 0, 0),
                    t.depthMask(!0),
                    t.depthFunc(513),
                    t.clearDepth(1),
                    t.stencilMask(4294967295),
                    t.stencilFunc(519, 0, 4294967295),
                    t.stencilOp(7680, 7680, 7680),
                    t.clearStencil(0),
                    t.cullFace(1029),
                    t.frontFace(2305),
                    t.polygonOffset(0, 0),
                    t.activeTexture(33984),
                    t.bindFramebuffer(36160, null),
                    !0 === i && (t.bindFramebuffer(36009, null),
                    t.bindFramebuffer(36008, null)),
                    t.useProgram(null),
                    t.lineWidth(1),
                    t.scissor(0, 0, t.canvas.width, t.canvas.height),
                    t.viewport(0, 0, t.canvas.width, t.canvas.height),
                    a = {},
                    L = null,
                    P = {},
                    l = {},
                    c = new WeakMap,
                    u = [],
                    h = null,
                    d = !1,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    v = null,
                    y = null,
                    x = null,
                    _ = !1,
                    b = null,
                    w = null,
                    M = null,
                    S = null,
                    T = null,
                    O.set(0, 0, t.canvas.width, t.canvas.height),
                    N.set(0, 0, t.canvas.width, t.canvas.height),
                    r.reset(),
                    s.reset(),
                    o.reset()
                }
            }
        }
        function Wd(t, e, n, i, r, s, o) {
            const a = r.isWebGL2
              , l = r.maxTextures
              , c = r.maxCubemapSize
              , u = r.maxTextureSize
              , h = r.maxSamples
              , d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0
              , p = new WeakMap;
            let f, m = !1;
            try {
                m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (t) {}
            function g(t, e) {
                return m ? new OffscreenCanvas(t,e) : ka("canvas")
            }
            function v(t, e, n, i) {
                let r = 1;
                if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
                r < 1 || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                        const i = e ? Pa : Math.floor
                          , s = i(r * t.width)
                          , o = i(r * t.height);
                        void 0 === f && (f = g(s, o));
                        const a = n ? g(s, o) : f;
                        return a.width = s,
                        a.height = o,
                        a.getContext("2d").drawImage(t, 0, 0, s, o),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."),
                        a
                    }
                    return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                    t
                }
                return t
            }
            function y(t) {
                return Ra(t.width) && Ra(t.height)
            }
            function x(t, e) {
                return t.generateMipmaps && e && t.minFilter !== Vo && t.minFilter !== qo
            }
            function _(e) {
                t.generateMipmap(e)
            }
            function b(n, i, r, s, o=!1) {
                if (!1 === a)
                    return i;
                if (null !== n) {
                    if (void 0 !== t[n])
                        return t[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = i;
                return 6403 === i && (5126 === r && (l = 33326),
                5131 === r && (l = 33325),
                5121 === r && (l = 33321)),
                33319 === i && (5126 === r && (l = 33328),
                5131 === r && (l = 33327),
                5121 === r && (l = 33323)),
                6408 === i && (5126 === r && (l = 34836),
                5131 === r && (l = 34842),
                5121 === r && (l = s === fa && !1 === o ? 35907 : 32856),
                32819 === r && (l = 32854),
                32820 === r && (l = 32855)),
                33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || e.get("EXT_color_buffer_float"),
                l
            }
            function w(t, e, n) {
                return !0 === x(t, n) || t.isFramebufferTexture && t.minFilter !== Vo && t.minFilter !== qo ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
            }
            function M(t) {
                return t === Vo || t === Wo || t === jo ? 9728 : 9729
            }
            function S(e) {
                const n = e.target;
                n.removeEventListener("dispose", S),
                function(e) {
                    const n = i.get(e);
                    void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture),
                    i.remove(e))
                }(n),
                n.isVideoTexture && p.delete(n),
                o.memory.textures--
            }
            function T(e) {
                const n = e.target;
                n.removeEventListener("dispose", T),
                function(e) {
                    const n = e.texture
                      , r = i.get(e)
                      , s = i.get(n);
                    if (e) {
                        if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture),
                        o.memory.textures--),
                        e.depthTexture && e.depthTexture.dispose(),
                        e.isWebGLCubeRenderTarget)
                            for (let e = 0; e < 6; e++)
                                t.deleteFramebuffer(r.__webglFramebuffer[e]),
                                r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                        else
                            t.deleteFramebuffer(r.__webglFramebuffer),
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer),
                            r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                            r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                            r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                        if (e.isWebGLMultipleRenderTargets)
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = i.get(n[e]);
                                r.__webglTexture && (t.deleteTexture(r.__webglTexture),
                                o.memory.textures--),
                                i.remove(n[e])
                            }
                        i.remove(n),
                        i.remove(e)
                    }
                }(n)
            }
            let E = 0;
            function A(t, e) {
                const r = i.get(t);
                if (t.isVideoTexture && function(t) {
                    const e = o.render.frame;
                    p.get(t) !== e && (p.set(t, e),
                    t.update())
                }(t),
                t.version > 0 && r.__version !== t.version) {
                    const n = t.image;
                    if (void 0 === n)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== n.complete)
                            return void I(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.activeTexture(33984 + e),
                n.bindTexture(3553, r.__webglTexture)
            }
            function C(e, r) {
                const o = i.get(e);
                e.version > 0 && o.__version !== e.version ? function(e, i, r) {
                    if (6 !== i.image.length)
                        return;
                    D(e, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, i.flipY),
                    t.pixelStorei(37441, i.premultiplyAlpha),
                    t.pixelStorei(3317, i.unpackAlignment),
                    t.pixelStorei(37443, 0);
                    const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture)
                      , l = i.image[0] && i.image[0].isDataTexture
                      , u = [];
                    for (let t = 0; t < 6; t++)
                        u[t] = o || l ? l ? i.image[t].image : i.image[t] : v(i.image[t], !1, !0, c),
                        u[t] = H(i, u[t]);
                    const h = u[0]
                      , d = y(h) || a
                      , p = s.convert(i.format, i.encoding)
                      , f = s.convert(i.type)
                      , m = b(i.internalFormat, p, f, i.encoding)
                      , g = a && !0 !== i.isVideoTexture
                      , M = void 0 === e.__version;
                    let S, T = w(i, h, d);
                    if (P(34067, i, d),
                    o) {
                        g && M && n.texStorage2D(34067, T, m, h.width, h.height);
                        for (let t = 0; t < 6; t++) {
                            S = u[t].mipmaps;
                            for (let e = 0; e < S.length; e++) {
                                const r = S[e];
                                i.format !== ta ? null !== p ? g ? n.compressedTexSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, r.data) : n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(34069 + t, e, 0, 0, r.width, r.height, p, f, r.data) : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                            }
                        }
                    } else {
                        S = i.mipmaps,
                        g && M && (S.length > 0 && T++,
                        n.texStorage2D(34067, T, m, u[0].width, u[0].height));
                        for (let t = 0; t < 6; t++)
                            if (l) {
                                g ? n.texSubImage2D(34069 + t, 0, 0, 0, u[t].width, u[t].height, p, f, u[t].data) : n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data);
                                for (let e = 0; e < S.length; e++) {
                                    const i = S[e].image[t].image;
                                    g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, i.width, i.height, p, f, i.data) : n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data)
                                }
                            } else {
                                g ? n.texSubImage2D(34069 + t, 0, 0, 0, p, f, u[t]) : n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                                for (let e = 0; e < S.length; e++) {
                                    const i = S[e];
                                    g ? n.texSubImage2D(34069 + t, e + 1, 0, 0, p, f, i.image[t]) : n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                                }
                            }
                    }
                    x(i, d) && _(34067),
                    e.__version = i.version,
                    i.onUpdate && i.onUpdate(i)
                }(o, e, r) : (n.activeTexture(33984 + r),
                n.bindTexture(34067, o.__webglTexture))
            }
            const R = {
                [Fo]: 10497,
                [Uo]: 33071,
                [Go]: 33648
            }
              , L = {
                [Vo]: 9728,
                [Wo]: 9984,
                [jo]: 9986,
                [qo]: 9729,
                1007: 9985,
                [Xo]: 9987
            };
            function P(n, s, o) {
                if (o ? (t.texParameteri(n, 10242, R[s.wrapS]),
                t.texParameteri(n, 10243, R[s.wrapT]),
                32879 !== n && 35866 !== n || t.texParameteri(n, 32882, R[s.wrapR]),
                t.texParameteri(n, 10240, L[s.magFilter]),
                t.texParameteri(n, 10241, L[s.minFilter])) : (t.texParameteri(n, 10242, 33071),
                t.texParameteri(n, 10243, 33071),
                32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071),
                s.wrapS === Uo && s.wrapT === Uo || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                t.texParameteri(n, 10240, M(s.magFilter)),
                t.texParameteri(n, 10241, M(s.minFilter)),
                s.minFilter !== Vo && s.minFilter !== qo && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                !0 === e.has("EXT_texture_filter_anisotropic")) {
                    const o = e.get("EXT_texture_filter_anisotropic");
                    if (s.type === Ko && !1 === e.has("OES_texture_float_linear"))
                        return;
                    if (!1 === a && s.type === Qo && !1 === e.has("OES_texture_half_float_linear"))
                        return;
                    (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                    i.get(s).__currentAnisotropy = s.anisotropy)
                }
            }
            function D(e, n) {
                void 0 === e.__webglInit && (e.__webglInit = !0,
                n.addEventListener("dispose", S),
                e.__webglTexture = t.createTexture(),
                o.memory.textures++)
            }
            function I(e, i, r) {
                let o = 3553;
                i.isDataTexture2DArray && (o = 35866),
                i.isDataTexture3D && (o = 32879),
                D(e, i),
                n.activeTexture(33984 + r),
                n.bindTexture(o, e.__webglTexture),
                t.pixelStorei(37440, i.flipY),
                t.pixelStorei(37441, i.premultiplyAlpha),
                t.pixelStorei(3317, i.unpackAlignment),
                t.pixelStorei(37443, 0);
                const l = function(t) {
                    return !a && (t.wrapS !== Uo || t.wrapT !== Uo || t.minFilter !== Vo && t.minFilter !== qo)
                }(i) && !1 === y(i.image);
                let c = v(i.image, l, !1, u);
                c = H(i, c);
                const h = y(c) || a
                  , d = s.convert(i.format, i.encoding);
                let p, f = s.convert(i.type), m = b(i.internalFormat, d, f, i.encoding, i.isVideoTexture);
                P(o, i, h);
                const g = i.mipmaps
                  , M = a && !0 !== i.isVideoTexture
                  , S = void 0 === e.__version
                  , T = w(i, c, h);
                if (i.isDepthTexture)
                    m = 6402,
                    a ? m = i.type === Ko ? 36012 : i.type === Zo ? 33190 : i.type === $o ? 35056 : 33189 : i.type === Ko && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                    i.format === ea && 6402 === m && i.type !== Jo && i.type !== Zo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                    i.type = Jo,
                    f = s.convert(i.type)),
                    i.format === na && 6402 === m && (m = 34041,
                    i.type !== $o && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                    i.type = $o,
                    f = s.convert(i.type))),
                    M && S ? n.texStorage2D(3553, 1, m, c.width, c.height) : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
                else if (i.isDataTexture)
                    if (g.length > 0 && h) {
                        M && S && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
                        for (let t = 0, e = g.length; t < e; t++)
                            p = g[t],
                            M ? n.texSubImage2D(3553, 0, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                        i.generateMipmaps = !1
                    } else
                        M ? (S && n.texStorage2D(3553, T, m, c.width, c.height),
                        n.texSubImage2D(3553, 0, 0, 0, c.width, c.height, d, f, c.data)) : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data);
                else if (i.isCompressedTexture) {
                    M && S && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
                    for (let t = 0, e = g.length; t < e; t++)
                        p = g[t],
                        i.format !== ta ? null !== d ? M ? n.compressedTexSubImage2D(3553, t, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage2D(3553, t, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data)
                } else if (i.isDataTexture2DArray)
                    M ? (S && n.texStorage3D(35866, T, m, c.width, c.height, c.depth),
                    n.texSubImage3D(35866, 0, 0, 0, 0, c.width, c.height, c.depth, d, f, c.data)) : n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data);
                else if (i.isDataTexture3D)
                    M ? (S && n.texStorage3D(32879, T, m, c.width, c.height, c.depth),
                    n.texSubImage3D(32879, 0, 0, 0, 0, c.width, c.height, c.depth, d, f, c.data)) : n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data);
                else if (i.isFramebufferTexture)
                    M && S ? n.texStorage2D(3553, T, m, c.width, c.height) : n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
                else if (g.length > 0 && h) {
                    M && S && n.texStorage2D(3553, T, m, g[0].width, g[0].height);
                    for (let t = 0, e = g.length; t < e; t++)
                        p = g[t],
                        M ? n.texSubImage2D(3553, t, 0, 0, d, f, p) : n.texImage2D(3553, t, m, d, f, p);
                    i.generateMipmaps = !1
                } else
                    M ? (S && n.texStorage2D(3553, T, m, c.width, c.height),
                    n.texSubImage2D(3553, 0, 0, 0, d, f, c)) : n.texImage2D(3553, 0, m, d, f, c);
                x(i, h) && _(o),
                e.__version = i.version,
                i.onUpdate && i.onUpdate(i)
            }
            function O(e, r, o, a, l) {
                const c = s.convert(o.format, o.encoding)
                  , u = s.convert(o.type)
                  , h = b(o.internalFormat, c, u, o.encoding);
                i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null)),
                n.bindFramebuffer(36160, e),
                r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, a, l, i.get(o).__webglTexture, 0, z(r)) : t.framebufferTexture2D(36160, a, l, i.get(o).__webglTexture, 0),
                n.bindFramebuffer(36160, null)
            }
            function N(e, n, i) {
                if (t.bindRenderbuffer(36161, e),
                n.depthBuffer && !n.stencilBuffer) {
                    let r = 33189;
                    if (i || n.useRenderToTexture) {
                        const e = n.depthTexture;
                        e && e.isDepthTexture && (e.type === Ko ? r = 36012 : e.type === Zo && (r = 33190));
                        const i = z(n);
                        n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                    } else
                        t.renderbufferStorage(36161, r, n.width, n.height);
                    t.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = z(n);
                    i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height),
                    t.framebufferRenderbuffer(36160, 33306, 36161, e)
                } else {
                    const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture
                      , r = s.convert(e.format, e.encoding)
                      , o = s.convert(e.type)
                      , a = b(e.internalFormat, r, o, e.encoding)
                      , l = z(n);
                    i && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, l, a, n.width, n.height) : n.useRenderToTexture ? d.renderbufferStorageMultisampleEXT(36161, l, a, n.width, n.height) : t.renderbufferStorage(36161, a, n.width, n.height)
                }
                t.bindRenderbuffer(36161, null)
            }
            function k(e) {
                const r = i.get(e)
                  , s = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (s)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(e, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(36160, e),
                        !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                        r.depthTexture.image.height = r.height,
                        r.depthTexture.needsUpdate = !0),
                        A(r.depthTexture, 0);
                        const s = i.get(r.depthTexture).__webglTexture
                          , o = z(r);
                        if (r.depthTexture.format === ea)
                            r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                        else {
                            if (r.depthTexture.format !== na)
                                throw new Error("Unknown depthTexture format");
                            r.useRenderToTexture ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                        }
                    }(r.__webglFramebuffer, e)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                        r.__webglDepthbuffer[i] = t.createRenderbuffer(),
                        N(r.__webglDepthbuffer[i], e, !1)
                } else
                    n.bindFramebuffer(36160, r.__webglFramebuffer),
                    r.__webglDepthbuffer = t.createRenderbuffer(),
                    N(r.__webglDepthbuffer, e, !1);
                n.bindFramebuffer(36160, null)
            }
            function z(t) {
                return a && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(h, t.samples) : 0
            }
            function H(t, n) {
                const i = t.encoding
                  , r = t.format
                  , s = t.type;
                return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === xa || i !== pa && (i === fa ? !1 === a ? !0 === e.has("EXT_sRGB") && r === ta ? (t.format = xa,
                t.minFilter = qo,
                t.generateMipmaps = !1) : n = ja.sRGBToLinear(n) : r === ta && s === Yo || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)),
                n
            }
            let B = !1
              , F = !1;
            this.allocateTextureUnit = function() {
                const t = E;
                return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l),
                E += 1,
                t
            }
            ,
            this.resetTextureUnits = function() {
                E = 0
            }
            ,
            this.setTexture2D = A,
            this.setTexture2DArray = function(t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e),
                n.bindTexture(35866, r.__webglTexture))
            }
            ,
            this.setTexture3D = function(t, e) {
                const r = i.get(t);
                t.version > 0 && r.__version !== t.version ? I(r, t, e) : (n.activeTexture(33984 + e),
                n.bindTexture(32879, r.__webglTexture))
            }
            ,
            this.setTextureCube = C,
            this.rebindTextures = function(t, e, n) {
                const r = i.get(t);
                void 0 !== e && O(r.__webglFramebuffer, t, t.texture, 36064, 3553),
                void 0 !== n && k(t)
            }
            ,
            this.setupRenderTarget = function(e) {
                const l = e.texture
                  , c = i.get(e)
                  , u = i.get(l);
                e.addEventListener("dispose", T),
                !0 !== e.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = t.createTexture()),
                u.__version = l.version,
                o.memory.textures++);
                const h = !0 === e.isWebGLCubeRenderTarget
                  , d = !0 === e.isWebGLMultipleRenderTargets
                  , p = l.isDataTexture3D || l.isDataTexture2DArray
                  , f = y(e) || a;
                if (h) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < 6; e++)
                        c.__webglFramebuffer[e] = t.createFramebuffer()
                } else if (c.__webglFramebuffer = t.createFramebuffer(),
                d)
                    if (r.drawBuffers) {
                        const n = e.texture;
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(),
                            o.memory.textures++)
                        }
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                else if (e.useRenderbuffer)
                    if (a) {
                        c.__webglMultisampledFramebuffer = t.createFramebuffer(),
                        c.__webglColorRenderbuffer = t.createRenderbuffer(),
                        t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                        const i = s.convert(l.format, l.encoding)
                          , r = s.convert(l.type)
                          , o = b(l.internalFormat, i, r, l.encoding)
                          , a = z(e);
                        t.renderbufferStorageMultisample(36161, a, o, e.width, e.height),
                        n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                        t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer),
                        t.bindRenderbuffer(36161, null),
                        e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(),
                        N(c.__webglDepthRenderbuffer, e, !0)),
                        n.bindFramebuffer(36160, null)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                if (h) {
                    n.bindTexture(34067, u.__webglTexture),
                    P(34067, l, f);
                    for (let t = 0; t < 6; t++)
                        O(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                    x(l, f) && _(34067),
                    n.unbindTexture()
                } else if (d) {
                    const t = e.texture;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r]
                          , o = i.get(s);
                        n.bindTexture(3553, o.__webglTexture),
                        P(3553, s, f),
                        O(c.__webglFramebuffer, e, s, 36064 + r, 3553),
                        x(s, f) && _(3553)
                    }
                    n.unbindTexture()
                } else {
                    let t = 3553;
                    p && (a ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),
                    n.bindTexture(t, u.__webglTexture),
                    P(t, l, f),
                    O(c.__webglFramebuffer, e, l, 36064, t),
                    x(l, f) && _(t),
                    n.unbindTexture()
                }
                e.depthBuffer && k(e)
            }
            ,
            this.updateRenderTargetMipmap = function(t) {
                const e = y(t) || a
                  , r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let s = 0, o = r.length; s < o; s++) {
                    const o = r[s];
                    if (x(o, e)) {
                        const e = t.isWebGLCubeRenderTarget ? 34067 : 3553
                          , r = i.get(o).__webglTexture;
                        n.bindTexture(e, r),
                        _(e),
                        n.unbindTexture()
                    }
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(e) {
                if (e.useRenderbuffer)
                    if (a) {
                        const r = e.width
                          , s = e.height;
                        let o = 16384;
                        const a = [36064]
                          , l = e.stencilBuffer ? 33306 : 36096;
                        e.depthBuffer && a.push(l),
                        e.ignoreDepthForMultisampleCopy || (e.depthBuffer && (o |= 256),
                        e.stencilBuffer && (o |= 1024));
                        const c = i.get(e);
                        n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer),
                        n.bindFramebuffer(36009, c.__webglFramebuffer),
                        e.ignoreDepthForMultisampleCopy && (t.invalidateFramebuffer(36008, [l]),
                        t.invalidateFramebuffer(36009, [l])),
                        t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728),
                        t.invalidateFramebuffer(36008, a),
                        n.bindFramebuffer(36008, null),
                        n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                    } else
                        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }
            ,
            this.setupDepthRenderbuffer = k,
            this.setupFrameBufferTexture = O,
            this.safeSetTexture2D = function(t, e) {
                t && t.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
                B = !0),
                t = t.texture),
                A(t, e)
            }
            ,
            this.safeSetTextureCube = function(t, e) {
                t && t.isWebGLCubeRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                F = !0),
                t = t.texture),
                C(t, e)
            }
        }
        function jd(t, e, n) {
            const i = n.isWebGL2;
            return {
                convert: function(t, n=null) {
                    let r;
                    if (t === Yo)
                        return 5121;
                    if (1017 === t)
                        return 32819;
                    if (1018 === t)
                        return 32820;
                    if (1010 === t)
                        return 5120;
                    if (1011 === t)
                        return 5122;
                    if (t === Jo)
                        return 5123;
                    if (1013 === t)
                        return 5124;
                    if (t === Zo)
                        return 5125;
                    if (t === Ko)
                        return 5126;
                    if (t === Qo)
                        return i ? 5131 : (r = e.get("OES_texture_half_float"),
                        null !== r ? r.HALF_FLOAT_OES : null);
                    if (1021 === t)
                        return 6406;
                    if (t === ta)
                        return 6408;
                    if (1024 === t)
                        return 6409;
                    if (1025 === t)
                        return 6410;
                    if (t === ea)
                        return 6402;
                    if (t === na)
                        return 34041;
                    if (1028 === t)
                        return 6403;
                    if (1022 === t)
                        return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
                        6408;
                    if (t === xa)
                        return r = e.get("EXT_sRGB"),
                        null !== r ? r.SRGB_ALPHA_EXT : null;
                    if (1029 === t)
                        return 36244;
                    if (1030 === t)
                        return 33319;
                    if (1031 === t)
                        return 33320;
                    if (1033 === t)
                        return 36249;
                    if (t === ia || t === ra || t === sa || t === oa)
                        if (n === fa) {
                            if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                            null === r)
                                return null;
                            if (t === ia)
                                return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (t === ra)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (t === sa)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (t === oa)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (r = e.get("WEBGL_compressed_texture_s3tc"),
                            null === r)
                                return null;
                            if (t === ia)
                                return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === ra)
                                return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === sa)
                                return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === oa)
                                return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                        if (r = e.get("WEBGL_compressed_texture_pvrtc"),
                        null === r)
                            return null;
                        if (35840 === t)
                            return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t)
                            return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t)
                            return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t)
                            return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t)
                        return r = e.get("WEBGL_compressed_texture_etc1"),
                        null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (37492 === t || 37496 === t) {
                        if (r = e.get("WEBGL_compressed_texture_etc"),
                        null === r)
                            return null;
                        if (37492 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                        if (37496 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) {
                        if (r = e.get("WEBGL_compressed_texture_astc"),
                        null === r)
                            return null;
                        if (37808 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (37812 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === t)
                            return n === fa ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (36492 === t) {
                        if (r = e.get("EXT_texture_compression_bptc"),
                        null === r)
                            return null;
                        if (36492 === t)
                            return n === fa ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT
                    }
                    return t === $o ? i ? 34042 : (r = e.get("WEBGL_depth_texture"),
                    null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                }
            }
        }
        Ud.prototype.isMeshDistanceMaterial = !0;
        class qd extends eu {
            constructor(t=[]) {
                super(),
                this.cameras = t
            }
        }
        qd.prototype.isArrayCamera = !0;
        class Xd extends ec {
            constructor() {
                super(),
                this.type = "Group"
            }
        }
        Xd.prototype.isGroup = !0;
        const Yd = {
            type: "move"
        };
        class Jd {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new Xd,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new Xd,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new $a,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new $a),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new Xd,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new $a,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new $a),
                this._grip
            }
            dispatchEvent(t) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(t),
                null !== this._grip && this._grip.dispatchEvent(t),
                null !== this._hand && this._hand.dispatchEvent(t),
                this
            }
            disconnect(t) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: t
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(t, e, n) {
                let i = null
                  , r = null
                  , s = null;
                const o = this._targetRay
                  , a = this._grip
                  , l = this._hand;
                if (t && "visible-blurred" !== e.session.visibilityState)
                    if (null !== o && (i = e.getPose(t.targetRaySpace, n),
                    null !== i && (o.matrix.fromArray(i.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    i.linearVelocity ? (o.hasLinearVelocity = !0,
                    o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1,
                    i.angularVelocity ? (o.hasAngularVelocity = !0,
                    o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1,
                    this.dispatchEvent(Yd))),
                    l && t.hand) {
                        s = !0;
                        for (const i of t.hand.values()) {
                            const t = e.getJointPose(i, n);
                            if (void 0 === l.joints[i.jointName]) {
                                const t = new Xd;
                                t.matrixAutoUpdate = !1,
                                t.visible = !1,
                                l.joints[i.jointName] = t,
                                l.add(t)
                            }
                            const r = l.joints[i.jointName];
                            null !== t && (r.matrix.fromArray(t.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.jointRadius = t.radius),
                            r.visible = null !== t
                        }
                        const i = l.joints["index-finger-tip"]
                          , r = l.joints["thumb-tip"]
                          , o = i.position.distanceTo(r.position)
                          , a = .02
                          , c = .005;
                        l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: t.handedness,
                            target: this
                        })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: t.handedness,
                            target: this
                        }))
                    } else
                        null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n),
                        null !== r && (a.matrix.fromArray(r.transform.matrix),
                        a.matrix.decompose(a.position, a.rotation, a.scale),
                        r.linearVelocity ? (a.hasLinearVelocity = !0,
                        a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
                        r.angularVelocity ? (a.hasAngularVelocity = !0,
                        a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                return null !== o && (o.visible = null !== i),
                null !== a && (a.visible = null !== r),
                null !== l && (l.visible = null !== s),
                this
            }
        }
        class Zd extends Xa {
            constructor(t, e, n, i, r, s, o, a, l, c) {
                if ((c = void 0 !== c ? c : ea) !== ea && c !== na)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === ea && (n = Jo),
                void 0 === n && c === na && (n = $o),
                super(null, i, r, s, o, a, c, n, l),
                this.image = {
                    width: t,
                    height: e
                },
                this.magFilter = void 0 !== o ? o : Vo,
                this.minFilter = void 0 !== a ? a : Vo,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        Zd.prototype.isDepthTexture = !0;
        class Kd extends _a {
            constructor(t, e) {
                super();
                const n = this;
                let i = null
                  , r = 1
                  , s = null
                  , o = "local-floor";
                const a = t.extensions.has("WEBGL_multisampled_render_to_texture");
                let l = null
                  , c = null
                  , u = null
                  , h = null
                  , d = !1
                  , p = null;
                const f = e.getContextAttributes();
                let m = null
                  , g = null;
                const v = []
                  , y = new Map
                  , x = new eu;
                x.layers.enable(1),
                x.viewport = new Ja;
                const _ = new eu;
                _.layers.enable(2),
                _.viewport = new Ja;
                const b = [x, _]
                  , w = new qd;
                w.layers.enable(1),
                w.layers.enable(2);
                let M = null
                  , S = null;
                function T(t) {
                    const e = y.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }
                function E() {
                    y.forEach((function(t, e) {
                        t.disconnect(e)
                    }
                    )),
                    y.clear(),
                    M = null,
                    S = null,
                    t.setRenderTarget(m),
                    h = null,
                    u = null,
                    c = null,
                    i = null,
                    g = null,
                    D.stop(),
                    n.isPresenting = !1,
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function A(t) {
                    const e = i.inputSources;
                    for (let t = 0; t < v.length; t++)
                        y.set(e[t], v[t]);
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e]
                          , i = y.get(n);
                        i && (i.dispatchEvent({
                            type: "disconnected",
                            data: n
                        }),
                        y.delete(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e]
                          , i = y.get(n);
                        i && i.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(t) {
                    let e = v[t];
                    return void 0 === e && (e = new Jd,
                    v[t] = e),
                    e.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(t) {
                    let e = v[t];
                    return void 0 === e && (e = new Jd,
                    v[t] = e),
                    e.getGripSpace()
                }
                ,
                this.getHand = function(t) {
                    let e = v[t];
                    return void 0 === e && (e = new Jd,
                    v[t] = e),
                    e.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(t) {
                    r = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(t) {
                    o = t,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return s
                }
                ,
                this.getBaseLayer = function() {
                    return null !== u ? u : h
                }
                ,
                this.getBinding = function() {
                    return c
                }
                ,
                this.getFrame = function() {
                    return p
                }
                ,
                this.getSession = function() {
                    return i
                }
                ,
                this.setSession = async function(l) {
                    if (i = l,
                    null !== i) {
                        if (m = t.getRenderTarget(),
                        i.addEventListener("select", T),
                        i.addEventListener("selectstart", T),
                        i.addEventListener("selectend", T),
                        i.addEventListener("squeeze", T),
                        i.addEventListener("squeezestart", T),
                        i.addEventListener("squeezeend", T),
                        i.addEventListener("end", E),
                        i.addEventListener("inputsourceschange", A),
                        !0 !== f.xrCompatible && await e.makeXRCompatible(),
                        void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== i.renderState.layers || f.antialias,
                                alpha: f.alpha,
                                depth: f.depth,
                                stencil: f.stencil,
                                framebufferScaleFactor: r
                            };
                            h = new XRWebGLLayer(i,e,n),
                            i.updateRenderState({
                                baseLayer: h
                            }),
                            g = new Za(h.framebufferWidth,h.framebufferHeight,{
                                format: ta,
                                type: Yo,
                                encoding: t.outputEncoding
                            })
                        } else {
                            d = f.antialias;
                            let n = null
                              , s = null
                              , o = null;
                            f.depth && (o = f.stencil ? 35056 : 33190,
                            n = f.stencil ? na : ea,
                            s = f.stencil ? $o : Jo);
                            const l = {
                                colorFormat: t.outputEncoding === fa ? 35907 : 32856,
                                depthFormat: o,
                                scaleFactor: r
                            };
                            c = new XRWebGLBinding(i,e),
                            u = c.createProjectionLayer(l),
                            i.updateRenderState({
                                layers: [u]
                            }),
                            g = d ? new Ka(u.textureWidth,u.textureHeight,{
                                format: ta,
                                type: Yo,
                                depthTexture: new Zd(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: f.stencil,
                                ignoreDepth: u.ignoreDepthValues,
                                useRenderToTexture: a,
                                encoding: t.outputEncoding
                            }) : new Za(u.textureWidth,u.textureHeight,{
                                format: ta,
                                type: Yo,
                                depthTexture: new Zd(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: f.stencil,
                                ignoreDepth: u.ignoreDepthValues,
                                encoding: t.outputEncoding
                            })
                        }
                        g.isXRRenderTarget = !0,
                        this.setFoveation(1),
                        s = await i.requestReferenceSpace(o),
                        D.setContext(i),
                        D.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ;
                const C = new $a
                  , R = new $a;
                function L(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.updateCamera = function(t) {
                    if (null === i)
                        return;
                    w.near = _.near = x.near = t.near,
                    w.far = _.far = x.far = t.far,
                    M === w.near && S === w.far || (i.updateRenderState({
                        depthNear: w.near,
                        depthFar: w.far
                    }),
                    M = w.near,
                    S = w.far);
                    const e = t.parent
                      , n = w.cameras;
                    L(w, e);
                    for (let t = 0; t < n.length; t++)
                        L(n[t], e);
                    w.matrixWorld.decompose(w.position, w.quaternion, w.scale),
                    t.position.copy(w.position),
                    t.quaternion.copy(w.quaternion),
                    t.scale.copy(w.scale),
                    t.matrix.copy(w.matrix),
                    t.matrixWorld.copy(w.matrixWorld);
                    const r = t.children;
                    for (let t = 0, e = r.length; t < e; t++)
                        r[t].updateMatrixWorld(!0);
                    2 === n.length ? function(t, e, n) {
                        C.setFromMatrixPosition(e.matrixWorld),
                        R.setFromMatrixPosition(n.matrixWorld);
                        const i = C.distanceTo(R)
                          , r = e.projectionMatrix.elements
                          , s = n.projectionMatrix.elements
                          , o = r[14] / (r[10] - 1)
                          , a = r[14] / (r[10] + 1)
                          , l = (r[9] + 1) / r[5]
                          , c = (r[9] - 1) / r[5]
                          , u = (r[8] - 1) / r[0]
                          , h = (s[8] + 1) / s[0]
                          , d = o * u
                          , p = o * h
                          , f = i / (-u + h)
                          , m = f * -u;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                        t.translateX(m),
                        t.translateZ(f),
                        t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                        t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = o + f
                          , v = a + f
                          , y = d - m
                          , x = p + (i - m)
                          , _ = l * a / v * g
                          , b = c * a / v * g;
                        t.projectionMatrix.makePerspective(y, x, _, b, g, v)
                    }(w, x, _) : w.projectionMatrix.copy(x.projectionMatrix)
                }
                ,
                this.getCamera = function() {
                    return w
                }
                ,
                this.getFoveation = function() {
                    return null !== u ? u.fixedFoveation : null !== h ? h.fixedFoveation : void 0
                }
                ,
                this.setFoveation = function(t) {
                    null !== u && (u.fixedFoveation = t),
                    null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = t)
                }
                ;
                let P = null;
                const D = new pu;
                D.setAnimationLoop((function(e, n) {
                    if (l = n.getViewerPose(s),
                    p = n,
                    null !== l) {
                        const e = l.views;
                        null !== h && (t.setRenderTargetFramebuffer(g, h.framebuffer),
                        t.setRenderTarget(g));
                        let n = !1;
                        e.length !== w.cameras.length && (w.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            let s = null;
                            if (null !== h)
                                s = h.getViewport(r);
                            else {
                                const e = c.getViewSubImage(u, r);
                                s = e.viewport,
                                0 === i && (t.setRenderTargetTextures(g, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture),
                                t.setRenderTarget(g))
                            }
                            const o = b[i];
                            o.matrix.fromArray(r.transform.matrix),
                            o.projectionMatrix.fromArray(r.projectionMatrix),
                            o.viewport.set(s.x, s.y, s.width, s.height),
                            0 === i && w.matrix.copy(o.matrix),
                            !0 === n && w.cameras.push(o)
                        }
                    }
                    const r = i.inputSources;
                    for (let t = 0; t < v.length; t++) {
                        const e = v[t]
                          , i = r[t];
                        e.update(i, n, s)
                    }
                    P && P(e, n),
                    p = null
                }
                )),
                this.setAnimationLoop = function(t) {
                    P = t
                }
                ,
                this.dispose = function() {}
            }
        }
        function Qd(t) {
            function e(e, n) {
                e.opacity.value = n.opacity,
                n.color && e.diffuse.value.copy(n.color),
                n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
                n.map && (e.map.value = n.map),
                n.alphaMap && (e.alphaMap.value = n.alphaMap),
                n.specularMap && (e.specularMap.value = n.specularMap),
                n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                const i = t.get(n).envMap;
                let r, s;
                i && (e.envMap.value = i,
                e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1,
                e.reflectivity.value = n.reflectivity,
                e.ior.value = n.ior,
                e.refractionRatio.value = n.refractionRatio),
                n.lightMap && (e.lightMap.value = n.lightMap,
                e.lightMapIntensity.value = n.lightMapIntensity),
                n.aoMap && (e.aoMap.value = n.aoMap,
                e.aoMapIntensity.value = n.aoMapIntensity),
                n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap),
                void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix)),
                n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap),
                void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                e.uv2Transform.value.copy(s.matrix))
            }
            function n(e, n) {
                e.roughness.value = n.roughness,
                e.metalness.value = n.metalness,
                n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
                n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
                n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
                n.bumpMap && (e.bumpMap.value = n.bumpMap,
                e.bumpScale.value = n.bumpScale,
                1 === n.side && (e.bumpScale.value *= -1)),
                n.normalMap && (e.normalMap.value = n.normalMap,
                e.normalScale.value.copy(n.normalScale),
                1 === n.side && e.normalScale.value.negate()),
                n.displacementMap && (e.displacementMap.value = n.displacementMap,
                e.displacementScale.value = n.displacementScale,
                e.displacementBias.value = n.displacementBias),
                t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
            }
            return {
                refreshFogUniforms: function(t, e) {
                    t.fogColor.value.copy(e.color),
                    e.isFog ? (t.fogNear.value = e.near,
                    t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                },
                refreshMaterialUniforms: function(t, i, r, s, o) {
                    i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i),
                    function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(t, i)) : i.isMeshToonMaterial ? (e(t, i),
                    function(t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshPhongMaterial ? (e(t, i),
                    function(t, e) {
                        t.specular.value.copy(e.specular),
                        t.shininess.value = Math.max(e.shininess, 1e-4),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshStandardMaterial ? (e(t, i),
                    i.isMeshPhysicalMaterial ? function(t, e, i) {
                        n(t, e),
                        t.ior.value = e.ior,
                        e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),
                        t.sheenRoughness.value = e.sheenRoughness,
                        e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap),
                        e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap)),
                        e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat,
                        t.clearcoatRoughness.value = e.clearcoatRoughness,
                        e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap),
                        e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap),
                        e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                        t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                        1 === e.side && t.clearcoatNormalScale.value.negate())),
                        e.transmission > 0 && (t.transmission.value = e.transmission,
                        t.transmissionSamplerMap.value = i.texture,
                        t.transmissionSamplerSize.value.set(i.width, i.height),
                        e.transmissionMap && (t.transmissionMap.value = e.transmissionMap),
                        t.thickness.value = e.thickness,
                        e.thicknessMap && (t.thicknessMap.value = e.thicknessMap),
                        t.attenuationDistance.value = e.attenuationDistance,
                        t.attenuationColor.value.copy(e.attenuationColor)),
                        t.specularIntensity.value = e.specularIntensity,
                        t.specularColor.value.copy(e.specularColor),
                        e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap),
                        e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
                    }(t, i, o) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i),
                    function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDepthMaterial ? (e(t, i),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i),
                    function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias),
                        t.referencePosition.value.copy(e.referencePosition),
                        t.nearDistance.value = e.nearDistance,
                        t.farDistance.value = e.farDistance
                    }(t, i)) : i.isMeshNormalMaterial ? (e(t, i),
                    function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale,
                        1 === e.side && (t.bumpScale.value *= -1)),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity
                    }(t, i),
                    i.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize,
                        t.totalSize.value = e.dashSize + e.gapSize,
                        t.scale.value = e.scale
                    }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                        let r;
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.size.value = e.size * n,
                        t.scale.value = .5 * i,
                        e.map && (t.map.value = e.map),
                        e.alphaMap && (t.alphaMap.value = e.alphaMap),
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                        e.map ? r = e.map : e.alphaMap && (r = e.alphaMap),
                        void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                        t.uvTransform.value.copy(r.matrix))
                    }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                        let n;
                        t.diffuse.value.copy(e.color),
                        t.opacity.value = e.opacity,
                        t.rotation.value = e.rotation,
                        e.map && (t.map.value = e.map),
                        e.alphaMap && (t.alphaMap.value = e.alphaMap),
                        e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                        e.map ? n = e.map : e.alphaMap && (n = e.alphaMap),
                        void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                        t.uvTransform.value.copy(n.matrix))
                    }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color),
                    t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }
        function $d(t={}) {
            const e = void 0 !== t.canvas ? t.canvas : function() {
                const t = ka("canvas");
                return t.style.display = "block",
                t
            }()
              , n = void 0 !== t.context ? t.context : null
              , i = void 0 !== t.alpha && t.alpha
              , r = void 0 === t.depth || t.depth
              , s = void 0 === t.stencil || t.stencil
              , o = void 0 !== t.antialias && t.antialias
              , a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
              , l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
              , c = void 0 !== t.powerPreference ? t.powerPreference : "default"
              , u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
            let h = null
              , d = null;
            const p = []
              , f = [];
            this.domElement = e,
            this.debug = {
                checkShaderErrors: !0
            },
            this.autoClear = !0,
            this.autoClearColor = !0,
            this.autoClearDepth = !0,
            this.autoClearStencil = !0,
            this.sortObjects = !0,
            this.clippingPlanes = [],
            this.localClippingEnabled = !1,
            this.outputEncoding = pa,
            this.physicallyCorrectLights = !1,
            this.toneMapping = 0,
            this.toneMappingExposure = 1;
            const m = this;
            let g = !1
              , v = 0
              , y = 0
              , x = null
              , _ = -1
              , b = null;
            const w = new Ja
              , M = new Ja;
            let S = null
              , T = e.width
              , E = e.height
              , A = 1
              , C = null
              , R = null;
            const L = new Ja(0,0,T,E)
              , P = new Ja(0,0,T,E);
            let D = !1;
            const I = new du;
            let O = !1
              , N = !1
              , k = null;
            const z = new Ll
              , H = new $a
              , B = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
            function F() {
                return null === x ? A : 1
            }
            let U, G, V, W, j, q, X, Y, J, Z, K, Q, $, tt, et, nt, it, rt, st, ot, at, lt, ct, ut = n;
            function ht(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i]
                      , s = e.getContext(r, n);
                    if (null !== s)
                        return s
                }
                return null
            }
            try {
                const t = {
                    alpha: !0,
                    depth: r,
                    stencil: s,
                    antialias: o,
                    premultipliedAlpha: a,
                    preserveDrawingBuffer: l,
                    powerPreference: c,
                    failIfMajorPerformanceCaveat: u
                };
                if ("setAttribute"in e && e.setAttribute("data-engine", "three.js r137"),
                e.addEventListener("webglcontextlost", ft, !1),
                e.addEventListener("webglcontextrestored", mt, !1),
                null === ut) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === m.isWebGL1Renderer && e.shift(),
                    ut = ht(e, t),
                    null === ut)
                        throw ht(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                void 0 === ut.getShaderPrecisionFormat && (ut.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }
                )
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message),
                t
            }
            function dt() {
                U = new qu(ut),
                G = new wu(ut,U,t),
                U.init(G),
                lt = new jd(ut,U,G),
                V = new Vd(ut,U,G),
                W = new Ju(ut),
                j = new Rd,
                q = new Wd(ut,U,V,j,G,lt,W),
                X = new Su(m),
                Y = new ju(m),
                J = new fu(ut,G),
                ct = new _u(ut,U,J,G),
                Z = new Xu(ut,J,W,ct),
                K = new eh(ut,Z,J,W),
                st = new th(ut,G,q),
                nt = new Mu(j),
                Q = new Cd(m,X,Y,U,G,ct,nt),
                $ = new Qd(j),
                tt = new Id,
                et = new Bd(U,G),
                rt = new xu(m,X,V,K,i,a),
                it = new Gd(m,K,G),
                ot = new bu(ut,U,W,G),
                at = new Yu(ut,U,W,G),
                W.programs = Q.programs,
                m.capabilities = G,
                m.extensions = U,
                m.properties = j,
                m.renderLists = tt,
                m.shadowMap = it,
                m.state = V,
                m.info = W
            }
            dt();
            const pt = new Kd(m,ut);
            function ft(t) {
                t.preventDefault(),
                console.log("THREE.WebGLRenderer: Context Lost."),
                g = !0
            }
            function mt() {
                console.log("THREE.WebGLRenderer: Context Restored."),
                g = !1;
                const t = W.autoReset
                  , e = it.enabled
                  , n = it.autoUpdate
                  , i = it.needsUpdate
                  , r = it.type;
                dt(),
                W.autoReset = t,
                it.enabled = e,
                it.autoUpdate = n,
                it.needsUpdate = i,
                it.type = r
            }
            function gt(t) {
                const e = t.target;
                e.removeEventListener("dispose", gt),
                function(t) {
                    (function(t) {
                        const e = j.get(t).programs;
                        void 0 !== e && (e.forEach((function(t) {
                            Q.releaseProgram(t)
                        }
                        )),
                        t.isShaderMaterial && Q.releaseShaderCache(t))
                    }
                    )(t),
                    j.remove(t)
                }(e)
            }
            this.xr = pt,
            this.getContext = function() {
                return ut
            }
            ,
            this.getContextAttributes = function() {
                return ut.getContextAttributes()
            }
            ,
            this.forceContextLoss = function() {
                const t = U.get("WEBGL_lose_context");
                t && t.loseContext()
            }
            ,
            this.forceContextRestore = function() {
                const t = U.get("WEBGL_lose_context");
                t && t.restoreContext()
            }
            ,
            this.getPixelRatio = function() {
                return A
            }
            ,
            this.setPixelRatio = function(t) {
                void 0 !== t && (A = t,
                this.setSize(T, E, !1))
            }
            ,
            this.getSize = function(t) {
                return t.set(T, E)
            }
            ,
            this.setSize = function(t, n, i) {
                pt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t,
                E = n,
                e.width = Math.floor(t * A),
                e.height = Math.floor(n * A),
                !1 !== i && (e.style.width = t + "px",
                e.style.height = n + "px"),
                this.setViewport(0, 0, t, n))
            }
            ,
            this.getDrawingBufferSize = function(t) {
                return t.set(T * A, E * A).floor()
            }
            ,
            this.setDrawingBufferSize = function(t, n, i) {
                T = t,
                E = n,
                A = i,
                e.width = Math.floor(t * i),
                e.height = Math.floor(n * i),
                this.setViewport(0, 0, t, n)
            }
            ,
            this.getCurrentViewport = function(t) {
                return t.copy(w)
            }
            ,
            this.getViewport = function(t) {
                return t.copy(L)
            }
            ,
            this.setViewport = function(t, e, n, i) {
                t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, n, i),
                V.viewport(w.copy(L).multiplyScalar(A).floor())
            }
            ,
            this.getScissor = function(t) {
                return t.copy(P)
            }
            ,
            this.setScissor = function(t, e, n, i) {
                t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i),
                V.scissor(M.copy(P).multiplyScalar(A).floor())
            }
            ,
            this.getScissorTest = function() {
                return D
            }
            ,
            this.setScissorTest = function(t) {
                V.setScissorTest(D = t)
            }
            ,
            this.setOpaqueSort = function(t) {
                C = t
            }
            ,
            this.setTransparentSort = function(t) {
                R = t
            }
            ,
            this.getClearColor = function(t) {
                return t.copy(rt.getClearColor())
            }
            ,
            this.setClearColor = function() {
                rt.setClearColor.apply(rt, arguments)
            }
            ,
            this.getClearAlpha = function() {
                return rt.getClearAlpha()
            }
            ,
            this.setClearAlpha = function() {
                rt.setClearAlpha.apply(rt, arguments)
            }
            ,
            this.clear = function(t, e, n) {
                let i = 0;
                (void 0 === t || t) && (i |= 16384),
                (void 0 === e || e) && (i |= 256),
                (void 0 === n || n) && (i |= 1024),
                ut.clear(i)
            }
            ,
            this.clearColor = function() {
                this.clear(!0, !1, !1)
            }
            ,
            this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }
            ,
            this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }
            ,
            this.dispose = function() {
                e.removeEventListener("webglcontextlost", ft, !1),
                e.removeEventListener("webglcontextrestored", mt, !1),
                tt.dispose(),
                et.dispose(),
                j.dispose(),
                X.dispose(),
                Y.dispose(),
                K.dispose(),
                ct.dispose(),
                Q.dispose(),
                pt.dispose(),
                pt.removeEventListener("sessionstart", yt),
                pt.removeEventListener("sessionend", xt),
                k && (k.dispose(),
                k = null),
                _t.stop()
            }
            ,
            this.renderBufferDirect = function(t, e, n, i, r, s) {
                null === e && (e = B);
                const o = r.isMesh && r.matrixWorld.determinant() < 0
                  , a = function(t, e, n, i, r) {
                    !0 !== e.isScene && (e = B),
                    q.resetTextureUnits();
                    const s = e.fog
                      , o = i.isMeshStandardMaterial ? e.environment : null
                      , a = null === x ? m.outputEncoding : !0 === x.isXRRenderTarget ? x.texture.encoding : pa
                      , l = (i.isMeshStandardMaterial ? Y : X).get(i.envMap || o)
                      , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                      , u = !!i.normalMap && !!n.attributes.tangent
                      , h = !!n.morphAttributes.position
                      , p = !!n.morphAttributes.normal
                      , f = n.morphAttributes.position ? n.morphAttributes.position.length : 0
                      , g = i.toneMapped ? m.toneMapping : 0
                      , v = j.get(i)
                      , y = d.state.lights;
                    if (!0 === O && (!0 === N || t !== b)) {
                        const e = t === b && i.id === _;
                        nt.setState(i, t, e)
                    }
                    let w = !1;
                    i.version === v.__version ? v.needsLights && v.lightsStateVersion !== y.state.version || v.outputEncoding !== a || r.isInstancedMesh && !1 === v.instancing ? w = !0 : r.isInstancedMesh || !0 !== v.instancing ? r.isSkinnedMesh && !1 === v.skinning ? w = !0 : r.isSkinnedMesh || !0 !== v.skinning ? v.envMap !== l || i.fog && v.fog !== s ? w = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === nt.numPlanes && v.numIntersection === nt.numIntersection ? (v.vertexAlphas !== c || v.vertexTangents !== u || v.morphTargets !== h || v.morphNormals !== p || v.toneMapping !== g || !0 === G.isWebGL2 && v.morphTargetsCount !== f) && (w = !0) : w = !0 : w = !0 : w = !0 : (w = !0,
                    v.__version = i.version);
                    let M = v.currentProgram;
                    !0 === w && (M = Tt(i, e, r));
                    let S = !1
                      , T = !1
                      , C = !1;
                    const R = M.getUniforms()
                      , L = v.uniforms;
                    if (V.useProgram(M.program) && (S = !0,
                    T = !0,
                    C = !0),
                    i.id !== _ && (_ = i.id,
                    T = !0),
                    S || b !== t) {
                        if (R.setValue(ut, "projectionMatrix", t.projectionMatrix),
                        G.logarithmicDepthBuffer && R.setValue(ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                        b !== t && (b = t,
                        T = !0,
                        C = !0),
                        i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                            const e = R.map.cameraPosition;
                            void 0 !== e && e.setValue(ut, H.setFromMatrixPosition(t.matrixWorld))
                        }
                        (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && R.setValue(ut, "isOrthographic", !0 === t.isOrthographicCamera),
                        (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && R.setValue(ut, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (r.isSkinnedMesh) {
                        R.setOptional(ut, r, "bindMatrix"),
                        R.setOptional(ut, r, "bindMatrixInverse");
                        const t = r.skeleton;
                        t && (G.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(),
                        R.setValue(ut, "boneTexture", t.boneTexture, q),
                        R.setValue(ut, "boneTextureSize", t.boneTextureSize)) : R.setOptional(ut, t, "boneMatrices"))
                    }
                    var P, D;
                    return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || st.update(r, n, i, M),
                    (T || v.receiveShadow !== r.receiveShadow) && (v.receiveShadow = r.receiveShadow,
                    R.setValue(ut, "receiveShadow", r.receiveShadow)),
                    T && (R.setValue(ut, "toneMappingExposure", m.toneMappingExposure),
                    v.needsLights && (D = C,
                    (P = L).ambientLightColor.needsUpdate = D,
                    P.lightProbe.needsUpdate = D,
                    P.directionalLights.needsUpdate = D,
                    P.directionalLightShadows.needsUpdate = D,
                    P.pointLights.needsUpdate = D,
                    P.pointLightShadows.needsUpdate = D,
                    P.spotLights.needsUpdate = D,
                    P.spotLightShadows.needsUpdate = D,
                    P.rectAreaLights.needsUpdate = D,
                    P.hemisphereLights.needsUpdate = D),
                    s && i.fog && $.refreshFogUniforms(L, s),
                    $.refreshMaterialUniforms(L, i, A, E, k),
                    od.upload(ut, v.uniformsList, L, q)),
                    i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (od.upload(ut, v.uniformsList, L, q),
                    i.uniformsNeedUpdate = !1),
                    i.isSpriteMaterial && R.setValue(ut, "center", r.center),
                    R.setValue(ut, "modelViewMatrix", r.modelViewMatrix),
                    R.setValue(ut, "normalMatrix", r.normalMatrix),
                    R.setValue(ut, "modelMatrix", r.matrixWorld),
                    M
                }(t, e, n, i, r);
                V.setMaterial(i, o);
                let l = n.index;
                const c = n.attributes.position;
                if (null === l) {
                    if (void 0 === c || 0 === c.count)
                        return
                } else if (0 === l.count)
                    return;
                let u, h = 1;
                !0 === i.wireframe && (l = Z.getWireframeAttribute(n),
                h = 2),
                ct.setup(r, i, a, n, l);
                let p = ot;
                null !== l && (u = J.get(l),
                p = at,
                p.setIndex(u));
                const f = null !== l ? l.count : c.count
                  , g = n.drawRange.start * h
                  , v = n.drawRange.count * h
                  , y = null !== s ? s.start * h : 0
                  , w = null !== s ? s.count * h : 1 / 0
                  , M = Math.max(g, y)
                  , S = Math.min(f, g + v, y + w) - 1
                  , T = Math.max(0, S - M + 1);
                if (0 !== T) {
                    if (r.isMesh)
                        !0 === i.wireframe ? (V.setLineWidth(i.wireframeLinewidth * F()),
                        p.setMode(1)) : p.setMode(4);
                    else if (r.isLine) {
                        let t = i.linewidth;
                        void 0 === t && (t = 1),
                        V.setLineWidth(t * F()),
                        r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                    } else
                        r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                    if (r.isInstancedMesh)
                        p.renderInstances(M, T, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const t = Math.min(n.instanceCount, n._maxInstanceCount);
                        p.renderInstances(M, T, t)
                    } else
                        p.render(M, T)
                }
            }
            ,
            this.compile = function(t, e) {
                d = et.get(t),
                d.init(),
                f.push(d),
                t.traverseVisible((function(t) {
                    t.isLight && t.layers.test(e.layers) && (d.pushLight(t),
                    t.castShadow && d.pushShadow(t))
                }
                )),
                d.setupLights(m.physicallyCorrectLights),
                t.traverse((function(e) {
                    const n = e.material;
                    if (n)
                        if (Array.isArray(n))
                            for (let i = 0; i < n.length; i++)
                                Tt(n[i], t, e);
                        else
                            Tt(n, t, e)
                }
                )),
                f.pop(),
                d = null
            }
            ;
            let vt = null;
            function yt() {
                _t.stop()
            }
            function xt() {
                _t.start()
            }
            const _t = new pu;
            function bt(t, e, n, i) {
                if (!1 === t.visible)
                    return;
                if (t.layers.test(e.layers))
                    if (t.isGroup)
                        n = t.renderOrder;
                    else if (t.isLOD)
                        !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight)
                        d.pushLight(t),
                        t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || I.intersectsSprite(t)) {
                            i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                            const e = K.update(t)
                              , r = t.material;
                            r.visible && h.push(t, e, r, n, H.z, null)
                        }
                    } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== W.render.frame && (t.skeleton.update(),
                    t.skeleton.frame = W.render.frame),
                    !t.frustumCulled || I.intersectsObject(t))) {
                        i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                        const e = K.update(t)
                          , r = t.material;
                        if (Array.isArray(r)) {
                            const i = e.groups;
                            for (let s = 0, o = i.length; s < o; s++) {
                                const o = i[s]
                                  , a = r[o.materialIndex];
                                a && a.visible && h.push(t, e, a, n, H.z, o)
                            }
                        } else
                            r.visible && h.push(t, e, r, n, H.z, null)
                    }
                const r = t.children;
                for (let t = 0, s = r.length; t < s; t++)
                    bt(r[t], e, n, i)
            }
            function wt(t, e, n, i) {
                const r = t.opaque
                  , s = t.transmissive
                  , a = t.transparent;
                d.setupLightsView(n),
                s.length > 0 && function(t, e, n) {
                    if (null === k) {
                        const t = !0 === o && !0 === G.isWebGL2;
                        k = new (t ? Ka : Za)(1024,1024,{
                            generateMipmaps: !0,
                            type: null !== lt.convert(Qo) ? Qo : Yo,
                            minFilter: Xo,
                            magFilter: Vo,
                            wrapS: Uo,
                            wrapT: Uo,
                            useRenderToTexture: U.has("WEBGL_multisampled_render_to_texture")
                        })
                    }
                    const i = m.getRenderTarget();
                    m.setRenderTarget(k),
                    m.clear();
                    const r = m.toneMapping;
                    m.toneMapping = 0,
                    Mt(t, e, n),
                    m.toneMapping = r,
                    q.updateMultisampleRenderTarget(k),
                    q.updateRenderTargetMipmap(k),
                    m.setRenderTarget(i)
                }(r, e, n),
                i && V.viewport(w.copy(i)),
                r.length > 0 && Mt(r, e, n),
                s.length > 0 && Mt(s, e, n),
                a.length > 0 && Mt(a, e, n)
            }
            function Mt(t, e, n) {
                const i = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r]
                      , o = s.object
                      , a = s.geometry
                      , l = null === i ? s.material : i
                      , c = s.group;
                    o.layers.test(n.layers) && St(o, e, n, a, l, c)
                }
            }
            function St(t, e, n, i, r, s) {
                t.onBeforeRender(m, e, n, i, r, s),
                t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                r.onBeforeRender(m, e, n, i, t, s),
                !0 === r.transparent && 2 === r.side ? (r.side = 1,
                r.needsUpdate = !0,
                m.renderBufferDirect(n, e, i, r, t, s),
                r.side = 0,
                r.needsUpdate = !0,
                m.renderBufferDirect(n, e, i, r, t, s),
                r.side = 2) : m.renderBufferDirect(n, e, i, r, t, s),
                t.onAfterRender(m, e, n, i, r, s)
            }
            function Tt(t, e, n) {
                !0 !== e.isScene && (e = B);
                const i = j.get(t)
                  , r = d.state.lights
                  , s = d.state.shadowsArray
                  , o = r.state.version
                  , a = Q.getParameters(t, r.state, s, e, n)
                  , l = Q.getProgramCacheKey(a);
                let c = i.programs;
                i.environment = t.isMeshStandardMaterial ? e.environment : null,
                i.fog = e.fog,
                i.envMap = (t.isMeshStandardMaterial ? Y : X).get(t.envMap || i.environment),
                void 0 === c && (t.addEventListener("dispose", gt),
                c = new Map,
                i.programs = c);
                let u = c.get(l);
                if (void 0 !== u) {
                    if (i.currentProgram === u && i.lightsStateVersion === o)
                        return Et(t, a),
                        u
                } else
                    a.uniforms = Q.getUniforms(t),
                    t.onBuild(n, a, m),
                    t.onBeforeCompile(a, m),
                    u = Q.acquireProgram(a, l),
                    c.set(l, u),
                    i.uniforms = a.uniforms;
                const h = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = nt.uniform),
                Et(t, a),
                i.needsLights = function(t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t),
                i.lightsStateVersion = o,
                i.needsLights && (h.ambientLightColor.value = r.state.ambient,
                h.lightProbe.value = r.state.probe,
                h.directionalLights.value = r.state.directional,
                h.directionalLightShadows.value = r.state.directionalShadow,
                h.spotLights.value = r.state.spot,
                h.spotLightShadows.value = r.state.spotShadow,
                h.rectAreaLights.value = r.state.rectArea,
                h.ltc_1.value = r.state.rectAreaLTC1,
                h.ltc_2.value = r.state.rectAreaLTC2,
                h.pointLights.value = r.state.point,
                h.pointLightShadows.value = r.state.pointShadow,
                h.hemisphereLights.value = r.state.hemi,
                h.directionalShadowMap.value = r.state.directionalShadowMap,
                h.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                h.spotShadowMap.value = r.state.spotShadowMap,
                h.spotShadowMatrix.value = r.state.spotShadowMatrix,
                h.pointShadowMap.value = r.state.pointShadowMap,
                h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const p = u.getUniforms()
                  , f = od.seqWithValue(p.seq, h);
                return i.currentProgram = u,
                i.uniformsList = f,
                u
            }
            function Et(t, e) {
                const n = j.get(t);
                n.outputEncoding = e.outputEncoding,
                n.instancing = e.instancing,
                n.skinning = e.skinning,
                n.morphTargets = e.morphTargets,
                n.morphNormals = e.morphNormals,
                n.morphTargetsCount = e.morphTargetsCount,
                n.numClippingPlanes = e.numClippingPlanes,
                n.numIntersection = e.numClipIntersection,
                n.vertexAlphas = e.vertexAlphas,
                n.vertexTangents = e.vertexTangents,
                n.toneMapping = e.toneMapping
            }
            _t.setAnimationLoop((function(t) {
                vt && vt(t)
            }
            )),
            "undefined" != typeof window && _t.setContext(window),
            this.setAnimationLoop = function(t) {
                vt = t,
                pt.setAnimationLoop(t),
                null === t ? _t.stop() : _t.start()
            }
            ,
            pt.addEventListener("sessionstart", yt),
            pt.addEventListener("sessionend", xt),
            this.render = function(t, e) {
                if (void 0 !== e && !0 !== e.isCamera)
                    return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === g)
                    return;
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === pt.enabled && !0 === pt.isPresenting && (!0 === pt.cameraAutoUpdate && pt.updateCamera(e),
                e = pt.getCamera()),
                !0 === t.isScene && t.onBeforeRender(m, t, e, x),
                d = et.get(t, f.length),
                d.init(),
                f.push(d),
                z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                I.setFromProjectionMatrix(z),
                N = this.localClippingEnabled,
                O = nt.init(this.clippingPlanes, N, e),
                h = tt.get(t, p.length),
                h.init(),
                p.push(h),
                bt(t, e, 0, m.sortObjects),
                h.finish(),
                !0 === m.sortObjects && h.sort(C, R),
                !0 === O && nt.beginShadows();
                const n = d.state.shadowsArray;
                if (it.render(n, t, e),
                !0 === O && nt.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                rt.render(h, t),
                d.setupLights(m.physicallyCorrectLights),
                e.isArrayCamera) {
                    const n = e.cameras;
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        wt(h, t, i, i.viewport)
                    }
                } else
                    wt(h, t, e);
                null !== x && (q.updateMultisampleRenderTarget(x),
                q.updateRenderTargetMipmap(x)),
                !0 === t.isScene && t.onAfterRender(m, t, e),
                V.buffers.depth.setTest(!0),
                V.buffers.depth.setMask(!0),
                V.buffers.color.setMask(!0),
                V.setPolygonOffset(!1),
                ct.resetDefaultState(),
                _ = -1,
                b = null,
                f.pop(),
                d = f.length > 0 ? f[f.length - 1] : null,
                p.pop(),
                h = p.length > 0 ? p[p.length - 1] : null
            }
            ,
            this.getActiveCubeFace = function() {
                return v
            }
            ,
            this.getActiveMipmapLevel = function() {
                return y
            }
            ,
            this.getRenderTarget = function() {
                return x
            }
            ,
            this.setRenderTargetTextures = function(t, e, n) {
                j.get(t.texture).__webglTexture = e,
                j.get(t.depthTexture).__webglTexture = n;
                const i = j.get(t);
                i.__hasExternalTextures = !0,
                i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n,
                i.__autoAllocateDepthBuffer || t.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"),
                t.useRenderToTexture = !1,
                t.useRenderbuffer = !0))
            }
            ,
            this.setRenderTargetFramebuffer = function(t, e) {
                const n = j.get(t);
                n.__webglFramebuffer = e,
                n.__useDefaultFramebuffer = void 0 === e
            }
            ,
            this.setRenderTarget = function(t, e=0, n=0) {
                x = t,
                v = e,
                y = n;
                let i = !0;
                if (t) {
                    const e = j.get(t);
                    void 0 !== e.__useDefaultFramebuffer ? (V.bindFramebuffer(36160, null),
                    i = !1) : void 0 === e.__webglFramebuffer ? q.setupRenderTarget(t) : e.__hasExternalTextures && q.rebindTextures(t, j.get(t.texture).__webglTexture, j.get(t.depthTexture).__webglTexture)
                }
                let r = null
                  , s = !1
                  , o = !1;
                if (t) {
                    const n = t.texture;
                    (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
                    const i = j.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (r = i[e],
                    s = !0) : r = t.useRenderbuffer ? j.get(t).__webglMultisampledFramebuffer : i,
                    w.copy(t.viewport),
                    M.copy(t.scissor),
                    S = t.scissorTest
                } else
                    w.copy(L).multiplyScalar(A).floor(),
                    M.copy(P).multiplyScalar(A).floor(),
                    S = D;
                if (V.bindFramebuffer(36160, r) && G.drawBuffers && i && V.drawBuffers(t, r),
                V.viewport(w),
                V.scissor(M),
                V.setScissorTest(S),
                s) {
                    const i = j.get(t.texture);
                    ut.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                } else if (o) {
                    const i = j.get(t.texture)
                      , r = e || 0;
                    ut.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                }
                _ = -1
            }
            ,
            this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
                if (!t || !t.isWebGLRenderTarget)
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let a = j.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]),
                a) {
                    V.bindFramebuffer(36160, a);
                    try {
                        const o = t.texture
                          , a = o.format
                          , l = o.type;
                        if (a !== ta && lt.convert(a) !== ut.getParameter(35739))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const c = l === Qo && (U.has("EXT_color_buffer_half_float") || G.isWebGL2 && U.has("EXT_color_buffer_float"));
                        if (!(l === Yo || lt.convert(l) === ut.getParameter(35738) || l === Ko && (G.isWebGL2 || U.has("OES_texture_float") || U.has("WEBGL_color_buffer_float")) || c))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === ut.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ut.readPixels(e, n, i, r, lt.convert(a), lt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        const t = null !== x ? j.get(x).__webglFramebuffer : null;
                        V.bindFramebuffer(36160, t)
                    }
                }
            }
            ,
            this.copyFramebufferToTexture = function(t, e, n=0) {
                if (!0 !== e.isFramebufferTexture)
                    return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
                const i = Math.pow(2, -n)
                  , r = Math.floor(e.image.width * i)
                  , s = Math.floor(e.image.height * i);
                q.setTexture2D(e, 0),
                ut.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, r, s),
                V.unbindTexture()
            }
            ,
            this.copyTextureToTexture = function(t, e, n, i=0) {
                const r = e.image.width
                  , s = e.image.height
                  , o = lt.convert(n.format)
                  , a = lt.convert(n.type);
                q.setTexture2D(n, 0),
                ut.pixelStorei(37440, n.flipY),
                ut.pixelStorei(37441, n.premultiplyAlpha),
                ut.pixelStorei(3317, n.unpackAlignment),
                e.isDataTexture ? ut.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? ut.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ut.texSubImage2D(3553, i, t.x, t.y, o, a, e.image),
                0 === i && n.generateMipmaps && ut.generateMipmap(3553),
                V.unbindTexture()
            }
            ,
            this.copyTextureToTexture3D = function(t, e, n, i, r=0) {
                if (m.isWebGL1Renderer)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const s = t.max.x - t.min.x + 1
                  , o = t.max.y - t.min.y + 1
                  , a = t.max.z - t.min.z + 1
                  , l = lt.convert(i.format)
                  , c = lt.convert(i.type);
                let u;
                if (i.isDataTexture3D)
                    q.setTexture3D(i, 0),
                    u = 32879;
                else {
                    if (!i.isDataTexture2DArray)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    q.setTexture2DArray(i, 0),
                    u = 35866
                }
                ut.pixelStorei(37440, i.flipY),
                ut.pixelStorei(37441, i.premultiplyAlpha),
                ut.pixelStorei(3317, i.unpackAlignment);
                const h = ut.getParameter(3314)
                  , d = ut.getParameter(32878)
                  , p = ut.getParameter(3316)
                  , f = ut.getParameter(3315)
                  , g = ut.getParameter(32877)
                  , v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                ut.pixelStorei(3314, v.width),
                ut.pixelStorei(32878, v.height),
                ut.pixelStorei(3316, t.min.x),
                ut.pixelStorei(3315, t.min.y),
                ut.pixelStorei(32877, t.min.z),
                n.isDataTexture || n.isDataTexture3D ? ut.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                ut.compressedTexSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, v.data)) : ut.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, v),
                ut.pixelStorei(3314, h),
                ut.pixelStorei(32878, d),
                ut.pixelStorei(3316, p),
                ut.pixelStorei(3315, f),
                ut.pixelStorei(32877, g),
                0 === r && i.generateMipmaps && ut.generateMipmap(u),
                V.unbindTexture()
            }
            ,
            this.initTexture = function(t) {
                q.setTexture2D(t, 0),
                V.unbindTexture()
            }
            ,
            this.resetState = function() {
                v = 0,
                y = 0,
                x = null,
                V.reset(),
                ct.reset()
            }
            ,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        $d.prototype.isWebGLRenderer = !0,
        class extends $d {
        }
        .prototype.isWebGL1Renderer = !0;
        class tp {
            constructor(t, e=25e-5) {
                this.name = "",
                this.color = new Va(t),
                this.density = e
            }
            clone() {
                return new tp(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        tp.prototype.isFogExp2 = !0;
        class ep {
            constructor(t, e=1, n=1e3) {
                this.name = "",
                this.color = new Va(t),
                this.near = e,
                this.far = n
            }
            clone() {
                return new ep(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        ep.prototype.isFog = !0;
        class np extends ec {
            constructor() {
                super(),
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.overrideMaterial = null,
                this.autoUpdate = !0,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(t, e) {
                return super.copy(t, e),
                null !== t.background && (this.background = t.background.clone()),
                null !== t.environment && (this.environment = t.environment.clone()),
                null !== t.fog && (this.fog = t.fog.clone()),
                null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                this.autoUpdate = t.autoUpdate,
                this.matrixAutoUpdate = t.matrixAutoUpdate,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return null !== this.fog && (e.object.fog = this.fog.toJSON()),
                e
            }
        }
        np.prototype.isScene = !0;
        class ip {
            constructor(t, e) {
                this.array = t,
                this.stride = e,
                this.count = void 0 !== t ? t.length / e : 0,
                this.usage = ga,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = Ta()
            }
            onUploadCallback() {}
            set needsUpdate(t) {
                !0 === t && this.version++
            }
            setUsage(t) {
                return this.usage = t,
                this
            }
            copy(t) {
                return this.array = new t.array.constructor(t.array),
                this.count = t.count,
                this.stride = t.stride,
                this.usage = t.usage,
                this
            }
            copyAt(t, e, n) {
                t *= this.stride,
                n *= e.stride;
                for (let i = 0, r = this.stride; i < r; i++)
                    this.array[t + i] = e.array[n + i];
                return this
            }
            set(t, e=0) {
                return this.array.set(t, e),
                this
            }
            clone(t) {
                void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ta()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid])
                  , n = new this.constructor(e,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(t) {
                return this.onUploadCallback = t,
                this
            }
            toJSON(t) {
                return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ta()),
                void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        ip.prototype.isInterleavedBuffer = !0;
        const rp = new $a;
        class sp {
            constructor(t, e, n, i=!1) {
                this.name = "",
                this.data = t,
                this.itemSize = e,
                this.offset = n,
                this.normalized = !0 === i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(t) {
                this.data.needsUpdate = t
            }
            applyMatrix4(t) {
                for (let e = 0, n = this.data.count; e < n; e++)
                    rp.x = this.getX(e),
                    rp.y = this.getY(e),
                    rp.z = this.getZ(e),
                    rp.applyMatrix4(t),
                    this.setXYZ(e, rp.x, rp.y, rp.z);
                return this
            }
            applyNormalMatrix(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    rp.x = this.getX(e),
                    rp.y = this.getY(e),
                    rp.z = this.getZ(e),
                    rp.applyNormalMatrix(t),
                    this.setXYZ(e, rp.x, rp.y, rp.z);
                return this
            }
            transformDirection(t) {
                for (let e = 0, n = this.count; e < n; e++)
                    rp.x = this.getX(e),
                    rp.y = this.getY(e),
                    rp.z = this.getZ(e),
                    rp.transformDirection(t),
                    this.setXYZ(e, rp.x, rp.y, rp.z);
                return this
            }
            setX(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e,
                this
            }
            setY(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e,
                this
            }
            setZ(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e,
                this
            }
            setW(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e,
                this
            }
            getX(t) {
                return this.data.array[t * this.data.stride + this.offset]
            }
            getY(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }
            getZ(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }
            getW(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }
            setXY(t, e, n) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this
            }
            setXYZ(t, e, n, i) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = i,
                this
            }
            setXYZW(t, e, n, i, r) {
                return t = t * this.data.stride + this.offset,
                this.data.array[t + 0] = e,
                this.data.array[t + 1] = n,
                this.data.array[t + 2] = i,
                this.data.array[t + 3] = r,
                this
            }
            clone(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return new yc(new this.array.constructor(t),this.itemSize,this.normalized)
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
                new sp(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(t) {
                if (void 0 === t) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                    const t = [];
                    for (let e = 0; e < this.count; e++) {
                        const n = e * this.data.stride + this.offset;
                        for (let e = 0; e < this.itemSize; e++)
                            t.push(this.data.array[n + e])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: t,
                        normalized: this.normalized
                    }
                }
                return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
                void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        sp.prototype.isInterleavedBufferAttribute = !0;
        class op extends fc {
            constructor(t) {
                super(),
                this.type = "SpriteMaterial",
                this.color = new Va(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.rotation = t.rotation,
                this.sizeAttenuation = t.sizeAttenuation,
                this
            }
        }
        let ap;
        op.prototype.isSpriteMaterial = !0;
        const lp = new $a
          , cp = new $a
          , up = new $a
          , hp = new Ia
          , dp = new Ia
          , pp = new Ll
          , fp = new $a
          , mp = new $a
          , gp = new $a
          , vp = new Ia
          , yp = new Ia
          , xp = new Ia;
        function _p(t, e, n, i, r, s) {
            hp.subVectors(t, n).addScalar(.5).multiply(i),
            void 0 !== r ? (dp.x = s * hp.x - r * hp.y,
            dp.y = r * hp.x + s * hp.y) : dp.copy(hp),
            t.copy(e),
            t.x += dp.x,
            t.y += dp.y,
            t.applyMatrix4(pp)
        }
        (class extends ec {
            constructor(t) {
                if (super(),
                this.type = "Sprite",
                void 0 === ap) {
                    ap = new Rc;
                    const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                      , e = new ip(t,5);
                    ap.setIndex([0, 1, 2, 0, 2, 3]),
                    ap.setAttribute("position", new sp(e,3,0,!1)),
                    ap.setAttribute("uv", new sp(e,2,3,!1))
                }
                this.geometry = ap,
                this.material = void 0 !== t ? t : new op,
                this.center = new Ia(.5,.5)
            }
            raycast(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                cp.setFromMatrixScale(this.matrixWorld),
                pp.copy(t.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
                up.setFromMatrixPosition(this.modelViewMatrix),
                t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && cp.multiplyScalar(-up.z);
                const n = this.material.rotation;
                let i, r;
                0 !== n && (r = Math.cos(n),
                i = Math.sin(n));
                const s = this.center;
                _p(fp.set(-.5, -.5, 0), up, s, cp, i, r),
                _p(mp.set(.5, -.5, 0), up, s, cp, i, r),
                _p(gp.set(.5, .5, 0), up, s, cp, i, r),
                vp.set(0, 0),
                yp.set(1, 0),
                xp.set(1, 1);
                let o = t.ray.intersectTriangle(fp, mp, gp, !1, lp);
                if (null === o && (_p(mp.set(-.5, .5, 0), up, s, cp, i, r),
                yp.set(0, 1),
                o = t.ray.intersectTriangle(fp, gp, mp, !1, lp),
                null === o))
                    return;
                const a = t.ray.origin.distanceTo(lp);
                a < t.near || a > t.far || e.push({
                    distance: a,
                    point: lp.clone(),
                    uv: dc.getUV(lp, fp, mp, gp, vp, yp, xp, new Ia),
                    face: null,
                    object: this
                })
            }
            copy(t) {
                return super.copy(t),
                void 0 !== t.center && this.center.copy(t.center),
                this.material = t.material,
                this
            }
        }
        ).prototype.isSprite = !0;
        const bp = new $a
          , wp = new Ja
          , Mp = new Ja
          , Sp = new $a
          , Tp = new Ll;
        class Ep extends Xc {
            constructor(t, e) {
                super(t, e),
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new Ll,
                this.bindMatrixInverse = new Ll
            }
            copy(t) {
                return super.copy(t),
                this.bindMode = t.bindMode,
                this.bindMatrix.copy(t.bindMatrix),
                this.bindMatrixInverse.copy(t.bindMatrixInverse),
                this.skeleton = t.skeleton,
                this
            }
            bind(t, e) {
                this.skeleton = t,
                void 0 === e && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                e = this.matrixWorld),
                this.bindMatrix.copy(e),
                this.bindMatrixInverse.copy(e).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const t = new Ja
                  , e = this.geometry.attributes.skinWeight;
                for (let n = 0, i = e.count; n < i; n++) {
                    t.x = e.getX(n),
                    t.y = e.getY(n),
                    t.z = e.getZ(n),
                    t.w = e.getW(n);
                    const i = 1 / t.manhattanLength();
                    i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                    e.setXYZW(n, t.x, t.y, t.z, t.w)
                }
            }
            updateMatrixWorld(t) {
                super.updateMatrixWorld(t),
                "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            boneTransform(t, e) {
                const n = this.skeleton
                  , i = this.geometry;
                wp.fromBufferAttribute(i.attributes.skinIndex, t),
                Mp.fromBufferAttribute(i.attributes.skinWeight, t),
                bp.copy(e).applyMatrix4(this.bindMatrix),
                e.set(0, 0, 0);
                for (let t = 0; t < 4; t++) {
                    const i = Mp.getComponent(t);
                    if (0 !== i) {
                        const r = wp.getComponent(t);
                        Tp.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                        e.addScaledVector(Sp.copy(bp).applyMatrix4(Tp), i)
                    }
                }
                return e.applyMatrix4(this.bindMatrixInverse)
            }
        }
        Ep.prototype.isSkinnedMesh = !0;
        class Ap extends ec {
            constructor() {
                super(),
                this.type = "Bone"
            }
        }
        Ap.prototype.isBone = !0;
        class Cp extends Xa {
            constructor(t=null, e=1, n=1, i, r, s, o, a, l=1003, c=1003, u, h) {
                super(null, s, o, a, l, c, i, r, u, h),
                this.image = {
                    data: t,
                    width: e,
                    height: n
                },
                this.magFilter = l,
                this.minFilter = c,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        Cp.prototype.isDataTexture = !0;
        const Rp = new Ll
          , Lp = new Ll;
        class Pp {
            constructor(t=[], e=[]) {
                this.uuid = Ta(),
                this.bones = t.slice(0),
                this.boneInverses = e,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.boneTextureSize = 0,
                this.frame = -1,
                this.init()
            }
            init() {
                const t = this.bones
                  , e = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * t.length),
                0 === e.length)
                    this.calculateInverses();
                else if (t.length !== e.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++)
                        this.boneInverses.push(new Ll)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = new Ll;
                    this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                    this.boneInverses.push(e)
                }
            }
            pose() {
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                }
                for (let t = 0, e = this.bones.length; t < e; t++) {
                    const e = this.bones[t];
                    e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                    e.matrix.decompose(e.position, e.quaternion, e.scale))
                }
            }
            update() {
                const t = this.bones
                  , e = this.boneInverses
                  , n = this.boneMatrices
                  , i = this.boneTexture;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i] ? t[i].matrixWorld : Lp;
                    Rp.multiplyMatrices(r, e[i]),
                    Rp.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new Pp(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let t = Math.sqrt(4 * this.bones.length);
                t = La(t),
                t = Math.max(t, 4);
                const e = new Float32Array(t * t * 4);
                e.set(this.boneMatrices);
                const n = new Cp(e,t,t,ta,Ko);
                return n.needsUpdate = !0,
                this.boneMatrices = e,
                this.boneTexture = n,
                this.boneTextureSize = t,
                this
            }
            getBoneByName(t) {
                for (let e = 0, n = this.bones.length; e < n; e++) {
                    const n = this.bones[e];
                    if (n.name === t)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(t, e) {
                this.uuid = t.uuid;
                for (let n = 0, i = t.bones.length; n < i; n++) {
                    const i = t.bones[n];
                    let r = e[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                    r = new Ap),
                    this.bones.push(r),
                    this.boneInverses.push((new Ll).fromArray(t.boneInverses[n]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                t.uuid = this.uuid;
                const e = this.bones
                  , n = this.boneInverses;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i];
                    t.bones.push(r.uuid);
                    const s = n[i];
                    t.boneInverses.push(s.toArray())
                }
                return t
            }
        }
        class Dp extends yc {
            constructor(t, e, n, i=1) {
                "number" == typeof n && (i = n,
                n = !1,
                console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
                super(t, e, n),
                this.meshPerAttribute = i
            }
            copy(t) {
                return super.copy(t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.meshPerAttribute = this.meshPerAttribute,
                t.isInstancedBufferAttribute = !0,
                t
            }
        }
        Dp.prototype.isInstancedBufferAttribute = !0;
        const Ip = new Ll
          , Op = new Ll
          , Np = []
          , kp = new Xc;
        (class extends Xc {
            constructor(t, e, n) {
                super(t, e),
                this.instanceMatrix = new Dp(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.count = n,
                this.frustumCulled = !1
            }
            copy(t) {
                return super.copy(t),
                this.instanceMatrix.copy(t.instanceMatrix),
                null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()),
                this.count = t.count,
                this
            }
            getColorAt(t, e) {
                e.fromArray(this.instanceColor.array, 3 * t)
            }
            getMatrixAt(t, e) {
                e.fromArray(this.instanceMatrix.array, 16 * t)
            }
            raycast(t, e) {
                const n = this.matrixWorld
                  , i = this.count;
                if (kp.geometry = this.geometry,
                kp.material = this.material,
                void 0 !== kp.material)
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Ip),
                        Op.multiplyMatrices(n, Ip),
                        kp.matrixWorld = Op,
                        kp.raycast(t, Np);
                        for (let t = 0, n = Np.length; t < n; t++) {
                            const n = Np[t];
                            n.instanceId = r,
                            n.object = this,
                            e.push(n)
                        }
                        Np.length = 0
                    }
            }
            setColorAt(t, e) {
                null === this.instanceColor && (this.instanceColor = new Dp(new Float32Array(3 * this.instanceMatrix.count),3)),
                e.toArray(this.instanceColor.array, 3 * t)
            }
            setMatrixAt(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        ).prototype.isInstancedMesh = !0;
        class zp extends fc {
            constructor(t) {
                super(),
                this.type = "LineBasicMaterial",
                this.color = new Va(16777215),
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.linewidth = t.linewidth,
                this.linecap = t.linecap,
                this.linejoin = t.linejoin,
                this
            }
        }
        zp.prototype.isLineBasicMaterial = !0;
        const Hp = new $a
          , Bp = new $a
          , Fp = new Ll
          , Up = new Rl
          , Gp = new bl;
        class Vp extends ec {
            constructor(t=new Rc, e=new zp) {
                super(),
                this.type = "Line",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , n = [0];
                        for (let t = 1, i = e.count; t < i; t++)
                            Hp.fromBufferAttribute(e, t - 1),
                            Bp.fromBufferAttribute(e, t),
                            n[t] = n[t - 1],
                            n[t] += Hp.distanceTo(Bp);
                        t.setAttribute("lineDistance", new bc(n,1))
                    } else
                        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Line.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                Gp.copy(n.boundingSphere),
                Gp.applyMatrix4(i),
                Gp.radius += r,
                !1 === t.ray.intersectsSphere(Gp))
                    return;
                Fp.copy(i).invert(),
                Up.copy(t.ray).applyMatrix4(Fp);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = o * o
                  , l = new $a
                  , c = new $a
                  , u = new $a
                  , h = new $a
                  , d = this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    const i = n.index
                      , r = n.attributes.position;
                    if (null !== i)
                        for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += d) {
                            const s = i.getX(n)
                              , o = i.getX(n + 1);
                            if (l.fromBufferAttribute(r, s),
                            c.fromBufferAttribute(r, o),
                            Up.distanceSqToSegment(l, c, h, u) > a)
                                continue;
                            h.applyMatrix4(this.matrixWorld);
                            const d = t.ray.origin.distanceTo(h);
                            d < t.near || d > t.far || e.push({
                                distance: d,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    else
                        for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
                            if (l.fromBufferAttribute(r, n),
                            c.fromBufferAttribute(r, n + 1),
                            Up.distanceSqToSegment(l, c, h, u) > a)
                                continue;
                            h.applyMatrix4(this.matrixWorld);
                            const i = t.ray.origin.distanceTo(h);
                            i < t.near || i > t.far || e.push({
                                distance: i,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                } else
                    n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        Vp.prototype.isLine = !0;
        const Wp = new $a
          , jp = new $a;
        class qp extends Vp {
            constructor(t, e) {
                super(t, e),
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        const e = t.attributes.position
                          , n = [];
                        for (let t = 0, i = e.count; t < i; t += 2)
                            Wp.fromBufferAttribute(e, t),
                            jp.fromBufferAttribute(e, t + 1),
                            n[t] = 0 === t ? 0 : n[t - 1],
                            n[t + 1] = n[t] + Wp.distanceTo(jp);
                        t.setAttribute("lineDistance", new bc(n,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else
                    t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                return this
            }
        }
        qp.prototype.isLineSegments = !0;
        class Xp extends Vp {
            constructor(t, e) {
                super(t, e),
                this.type = "LineLoop"
            }
        }
        Xp.prototype.isLineLoop = !0;
        class Yp extends fc {
            constructor(t) {
                super(),
                this.type = "PointsMaterial",
                this.color = new Va(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.alphaMap = t.alphaMap,
                this.size = t.size,
                this.sizeAttenuation = t.sizeAttenuation,
                this
            }
        }
        Yp.prototype.isPointsMaterial = !0;
        const Jp = new Ll
          , Zp = new Rl
          , Kp = new bl
          , Qp = new $a;
        class $p extends ec {
            constructor(t=new Rc, e=new Yp) {
                super(),
                this.type = "Points",
                this.geometry = t,
                this.material = e,
                this.updateMorphTargets()
            }
            copy(t) {
                return super.copy(t),
                this.material = t.material,
                this.geometry = t.geometry,
                this
            }
            raycast(t, e) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = t.params.Points.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                Kp.copy(n.boundingSphere),
                Kp.applyMatrix4(i),
                Kp.radius += r,
                !1 === t.ray.intersectsSphere(Kp))
                    return;
                Jp.copy(i).invert(),
                Zp.copy(t.ray).applyMatrix4(Jp);
                const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , a = o * o;
                if (n.isBufferGeometry) {
                    const r = n.index
                      , o = n.attributes.position;
                    if (null !== r)
                        for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
                            const s = r.getX(n);
                            Qp.fromBufferAttribute(o, s),
                            tf(Qp, s, a, i, t, e, this)
                        }
                    else
                        for (let n = Math.max(0, s.start), r = Math.min(o.count, s.start + s.count); n < r; n++)
                            Qp.fromBufferAttribute(o, n),
                            tf(Qp, n, a, i, t, e, this)
                } else
                    console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
            updateMorphTargets() {
                const t = this.geometry;
                if (t.isBufferGeometry) {
                    const e = t.morphAttributes
                      , n = Object.keys(e);
                    if (n.length > 0) {
                        const t = e[n[0]];
                        if (void 0 !== t) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[n] = e
                            }
                        }
                    }
                } else {
                    const e = t.morphTargets;
                    void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
        }
        function tf(t, e, n, i, r, s, o) {
            const a = Zp.distanceSqToPoint(t);
            if (a < n) {
                const n = new $a;
                Zp.closestPointToPoint(t, n),
                n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far)
                    return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: e,
                    face: null,
                    object: o
                })
            }
        }
        $p.prototype.isPoints = !0,
        class extends Xa {
            constructor(t, e, n, i, r, s, o, a, l) {
                super(t, e, n, i, r, s, o, a, l),
                this.minFilter = void 0 !== s ? s : qo,
                this.magFilter = void 0 !== r ? r : qo,
                this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
                    c.needsUpdate = !0,
                    t.requestVideoFrameCallback(e)
                }
                ))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const t = this.image;
                !1 == "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        .prototype.isVideoTexture = !0,
        class extends Xa {
            constructor(t, e, n) {
                super({
                    width: t,
                    height: e
                }),
                this.format = n,
                this.magFilter = Vo,
                this.minFilter = Vo,
                this.generateMipmaps = !1,
                this.needsUpdate = !0
            }
        }
        .prototype.isFramebufferTexture = !0;
        (class extends Xa {
            constructor(t, e, n, i, r, s, o, a, l, c, u, h) {
                super(null, s, o, a, l, c, i, r, u, h),
                this.image = {
                    width: e,
                    height: n
                },
                this.mipmaps = t,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        ).prototype.isCompressedTexture = !0,
        class extends Xa {
            constructor(t, e, n, i, r, s, o, a, l) {
                super(t, e, n, i, r, s, o, a, l),
                this.needsUpdate = !0
            }
        }
        .prototype.isCanvasTexture = !0,
        new $a,
        new $a,
        new $a,
        new dc;
        class ef {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getPoint(n, e)
            }
            getPoints(t=5) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                return e
            }
            getSpacedPoints(t=5) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPointAt(n / t));
                return e
            }
            getLength() {
                const t = this.getLengths();
                return t[t.length - 1]
            }
            getLengths(t=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const e = [];
                let n, i = this.getPoint(0), r = 0;
                e.push(0);
                for (let s = 1; s <= t; s++)
                    n = this.getPoint(s / t),
                    r += n.distanceTo(i),
                    e.push(r),
                    i = n;
                return this.cacheArcLengths = e,
                e
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(t, e) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let s;
                s = e || t * n[r - 1];
                let o, a = 0, l = r - 1;
                for (; a <= l; )
                    if (i = Math.floor(a + (l - a) / 2),
                    o = n[i] - s,
                    o < 0)
                        a = i + 1;
                    else {
                        if (!(o > 0)) {
                            l = i;
                            break
                        }
                        l = i - 1
                    }
                if (i = l,
                n[i] === s)
                    return i / (r - 1);
                const c = n[i];
                return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
            }
            getTangent(t, e) {
                const n = 1e-4;
                let i = t - n
                  , r = t + n;
                i < 0 && (i = 0),
                r > 1 && (r = 1);
                const s = this.getPoint(i)
                  , o = this.getPoint(r)
                  , a = e || (s.isVector2 ? new Ia : new $a);
                return a.copy(o).sub(s).normalize(),
                a
            }
            getTangentAt(t, e) {
                const n = this.getUtoTmapping(t);
                return this.getTangent(n, e)
            }
            computeFrenetFrames(t, e) {
                const n = new $a
                  , i = []
                  , r = []
                  , s = []
                  , o = new $a
                  , a = new Ll;
                for (let e = 0; e <= t; e++) {
                    const n = e / t;
                    i[e] = this.getTangentAt(n, new $a)
                }
                r[0] = new $a,
                s[0] = new $a;
                let l = Number.MAX_VALUE;
                const c = Math.abs(i[0].x)
                  , u = Math.abs(i[0].y)
                  , h = Math.abs(i[0].z);
                c <= l && (l = c,
                n.set(1, 0, 0)),
                u <= l && (l = u,
                n.set(0, 1, 0)),
                h <= l && n.set(0, 0, 1),
                o.crossVectors(i[0], n).normalize(),
                r[0].crossVectors(i[0], o),
                s[0].crossVectors(i[0], r[0]);
                for (let e = 1; e <= t; e++) {
                    if (r[e] = r[e - 1].clone(),
                    s[e] = s[e - 1].clone(),
                    o.crossVectors(i[e - 1], i[e]),
                    o.length() > Number.EPSILON) {
                        o.normalize();
                        const t = Math.acos(Ea(i[e - 1].dot(i[e]), -1, 1));
                        r[e].applyMatrix4(a.makeRotationAxis(o, t))
                    }
                    s[e].crossVectors(i[e], r[e])
                }
                if (!0 === e) {
                    let e = Math.acos(Ea(r[0].dot(r[t]), -1, 1));
                    e /= t,
                    i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                    for (let n = 1; n <= t; n++)
                        r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
                        s[n].crossVectors(i[n], r[n])
                }
                return {
                    tangents: i,
                    normals: r,
                    binormals: s
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            }
            toJSON() {
                const t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions,
                t.type = this.type,
                t
            }
            fromJSON(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions,
                this
            }
        }
        class nf extends ef {
            constructor(t=0, e=0, n=1, i=1, r=0, s=2 * Math.PI, o=!1, a=0) {
                super(),
                this.type = "EllipseCurve",
                this.aX = t,
                this.aY = e,
                this.xRadius = n,
                this.yRadius = i,
                this.aStartAngle = r,
                this.aEndAngle = s,
                this.aClockwise = o,
                this.aRotation = a
            }
            getPoint(t, e) {
                const n = e || new Ia
                  , i = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const s = Math.abs(r) < Number.EPSILON;
                for (; r < 0; )
                    r += i;
                for (; r > i; )
                    r -= i;
                r < Number.EPSILON && (r = s ? 0 : i),
                !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                const o = this.aStartAngle + t * r;
                let a = this.aX + this.xRadius * Math.cos(o)
                  , l = this.aY + this.yRadius * Math.sin(o);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation)
                      , e = Math.sin(this.aRotation)
                      , n = a - this.aX
                      , i = l - this.aY;
                    a = n * t - i * e + this.aX,
                    l = n * e + i * t + this.aY
                }
                return n.set(a, l)
            }
            copy(t) {
                return super.copy(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.aX = this.aX,
                t.aY = this.aY,
                t.xRadius = this.xRadius,
                t.yRadius = this.yRadius,
                t.aStartAngle = this.aStartAngle,
                t.aEndAngle = this.aEndAngle,
                t.aClockwise = this.aClockwise,
                t.aRotation = this.aRotation,
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.aX = t.aX,
                this.aY = t.aY,
                this.xRadius = t.xRadius,
                this.yRadius = t.yRadius,
                this.aStartAngle = t.aStartAngle,
                this.aEndAngle = t.aEndAngle,
                this.aClockwise = t.aClockwise,
                this.aRotation = t.aRotation,
                this
            }
        }
        nf.prototype.isEllipseCurve = !0;
        class rf extends nf {
            constructor(t, e, n, i, r, s) {
                super(t, e, n, n, i, r, s),
                this.type = "ArcCurve"
            }
        }
        function sf() {
            let t = 0
              , e = 0
              , n = 0
              , i = 0;
            function r(r, s, o, a) {
                t = r,
                e = o,
                n = -3 * r + 3 * s - 2 * o - a,
                i = 2 * r - 2 * s + o + a
            }
            return {
                initCatmullRom: function(t, e, n, i, s) {
                    r(e, n, s * (n - t), s * (i - e))
                },
                initNonuniformCatmullRom: function(t, e, n, i, s, o, a) {
                    let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o
                      , c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                    l *= o,
                    c *= o,
                    r(e, n, l, c)
                },
                calc: function(r) {
                    const s = r * r;
                    return t + e * r + n * s + i * (s * r)
                }
            }
        }
        rf.prototype.isArcCurve = !0;
        const of = new $a
          , af = new sf
          , lf = new sf
          , cf = new sf;
        class uf extends ef {
            constructor(t=[], e=!1, n="centripetal", i=.5) {
                super(),
                this.type = "CatmullRomCurve3",
                this.points = t,
                this.closed = e,
                this.curveType = n,
                this.tension = i
            }
            getPoint(t, e=new $a) {
                const n = e
                  , i = this.points
                  , r = i.length
                  , s = (r - (this.closed ? 0 : 1)) * t;
                let o, a, l = Math.floor(s), c = s - l;
                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
                c = 1),
                this.closed || l > 0 ? o = i[(l - 1) % r] : (of.subVectors(i[0], i[1]).add(i[0]),
                o = of);
                const u = i[l % r]
                  , h = i[(l + 1) % r];
                if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (of.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
                a = of),
                "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(o.distanceToSquared(u), t)
                      , n = Math.pow(u.distanceToSquared(h), t)
                      , i = Math.pow(h.distanceToSquared(a), t);
                    n < 1e-4 && (n = 1),
                    e < 1e-4 && (e = n),
                    i < 1e-4 && (i = n),
                    af.initNonuniformCatmullRom(o.x, u.x, h.x, a.x, e, n, i),
                    lf.initNonuniformCatmullRom(o.y, u.y, h.y, a.y, e, n, i),
                    cf.initNonuniformCatmullRom(o.z, u.z, h.z, a.z, e, n, i)
                } else
                    "catmullrom" === this.curveType && (af.initCatmullRom(o.x, u.x, h.x, a.x, this.tension),
                    lf.initCatmullRom(o.y, u.y, h.y, a.y, this.tension),
                    cf.initCatmullRom(o.z, u.z, h.z, a.z, this.tension));
                return n.set(af.calc(c), lf.calc(c), cf.calc(c)),
                n
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed,
                t.curveType = this.curveType,
                t.tension = this.tension,
                t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new $a).fromArray(n))
                }
                return this.closed = t.closed,
                this.curveType = t.curveType,
                this.tension = t.tension,
                this
            }
        }
        function hf(t, e, n, i, r) {
            const s = .5 * (i - e)
              , o = .5 * (r - n)
              , a = t * t;
            return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
        }
        function df(t, e, n, i) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * e
            }(t, e) + function(t, e) {
                return 2 * (1 - t) * t * e
            }(t, n) + function(t, e) {
                return t * t * e
            }(t, i)
        }
        function pf(t, e, n, i, r) {
            return function(t, e) {
                const n = 1 - t;
                return n * n * n * e
            }(t, e) + function(t, e) {
                const n = 1 - t;
                return 3 * n * n * t * e
            }(t, n) + function(t, e) {
                return 3 * (1 - t) * t * t * e
            }(t, i) + function(t, e) {
                return t * t * t * e
            }(t, r)
        }
        uf.prototype.isCatmullRomCurve3 = !0;
        class ff extends ef {
            constructor(t=new Ia, e=new Ia, n=new Ia, i=new Ia) {
                super(),
                this.type = "CubicBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n,
                this.v3 = i
            }
            getPoint(t, e=new Ia) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2
                  , o = this.v3;
                return n.set(pf(t, i.x, r.x, s.x, o.x), pf(t, i.y, r.y, s.y, o.y)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        ff.prototype.isCubicBezierCurve = !0;
        class mf extends ef {
            constructor(t=new $a, e=new $a, n=new $a, i=new $a) {
                super(),
                this.type = "CubicBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n,
                this.v3 = i
            }
            getPoint(t, e=new $a) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2
                  , o = this.v3;
                return n.set(pf(t, i.x, r.x, s.x, o.x), pf(t, i.y, r.y, s.y, o.y), pf(t, i.z, r.z, s.z, o.z)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this.v3.copy(t.v3),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t.v3 = this.v3.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this.v3.fromArray(t.v3),
                this
            }
        }
        mf.prototype.isCubicBezierCurve3 = !0;
        class gf extends ef {
            constructor(t=new Ia, e=new Ia) {
                super(),
                this.type = "LineCurve",
                this.v1 = t,
                this.v2 = e
            }
            getPoint(t, e=new Ia) {
                const n = e;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                n.multiplyScalar(t).add(this.v1)),
                n
            }
            getPointAt(t, e) {
                return this.getPoint(t, e)
            }
            getTangent(t, e) {
                const n = e || new Ia;
                return n.copy(this.v2).sub(this.v1).normalize(),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        gf.prototype.isLineCurve = !0;
        class vf extends ef {
            constructor(t=new Ia, e=new Ia, n=new Ia) {
                super(),
                this.type = "QuadraticBezierCurve",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n
            }
            getPoint(t, e=new Ia) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2;
                return n.set(df(t, i.x, r.x, s.x), df(t, i.y, r.y, s.y)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        vf.prototype.isQuadraticBezierCurve = !0;
        class yf extends ef {
            constructor(t=new $a, e=new $a, n=new $a) {
                super(),
                this.type = "QuadraticBezierCurve3",
                this.v0 = t,
                this.v1 = e,
                this.v2 = n
            }
            getPoint(t, e=new $a) {
                const n = e
                  , i = this.v0
                  , r = this.v1
                  , s = this.v2;
                return n.set(df(t, i.x, r.x, s.x), df(t, i.y, r.y, s.y), df(t, i.z, r.z, s.z)),
                n
            }
            copy(t) {
                return super.copy(t),
                this.v0.copy(t.v0),
                this.v1.copy(t.v1),
                this.v2.copy(t.v2),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.v0 = this.v0.toArray(),
                t.v1 = this.v1.toArray(),
                t.v2 = this.v2.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.v0.fromArray(t.v0),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
            }
        }
        yf.prototype.isQuadraticBezierCurve3 = !0;
        class xf extends ef {
            constructor(t=[]) {
                super(),
                this.type = "SplineCurve",
                this.points = t
            }
            getPoint(t, e=new Ia) {
                const n = e
                  , i = this.points
                  , r = (i.length - 1) * t
                  , s = Math.floor(r)
                  , o = r - s
                  , a = i[0 === s ? s : s - 1]
                  , l = i[s]
                  , c = i[s > i.length - 2 ? i.length - 1 : s + 1]
                  , u = i[s > i.length - 3 ? i.length - 1 : s + 2];
                return n.set(hf(o, a.x, l.x, c.x, u.x), hf(o, a.y, l.y, c.y, u.y)),
                n
            }
            copy(t) {
                super.copy(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new Ia).fromArray(n))
                }
                return this
            }
        }
        xf.prototype.isSplineCurve = !0;
        var _f = Object.freeze({
            __proto__: null,
            ArcCurve: rf,
            CatmullRomCurve3: uf,
            CubicBezierCurve: ff,
            CubicBezierCurve3: mf,
            EllipseCurve: nf,
            LineCurve: gf,
            LineCurve3: class extends ef {
                constructor(t=new $a, e=new $a) {
                    super(),
                    this.type = "LineCurve3",
                    this.isLineCurve3 = !0,
                    this.v1 = t,
                    this.v2 = e
                }
                getPoint(t, e=new $a) {
                    const n = e;
                    return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(t).add(this.v1)),
                    n
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                copy(t) {
                    return super.copy(t),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v1 = this.v1.toArray(),
                    t.v2 = this.v2.toArray(),
                    t
                }
                fromJSON(t) {
                    return super.fromJSON(t),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
                }
            }
            ,
            QuadraticBezierCurve: vf,
            QuadraticBezierCurve3: yf,
            SplineCurve: xf
        });
        class bf extends ef {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(t) {
                this.curves.push(t)
            }
            closePath() {
                const t = this.curves[0].getPoint(0)
                  , e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new gf(e,t))
            }
            getPoint(t, e) {
                const n = t * this.getLength()
                  , i = this.getCurveLengths();
                let r = 0;
                for (; r < i.length; ) {
                    if (i[r] >= n) {
                        const t = i[r] - n
                          , s = this.curves[r]
                          , o = s.getLength()
                          , a = 0 === o ? 0 : 1 - t / o;
                        return s.getPointAt(a, e)
                    }
                    r++
                }
                return null
            }
            getLength() {
                const t = this.getCurveLengths();
                return t[t.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const t = [];
                let e = 0;
                for (let n = 0, i = this.curves.length; n < i; n++)
                    e += this.curves[n].getLength(),
                    t.push(e);
                return this.cacheLengths = t,
                t
            }
            getSpacedPoints(t=40) {
                const e = [];
                for (let n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]),
                e
            }
            getPoints(t=12) {
                const e = [];
                let n;
                for (let i = 0, r = this.curves; i < r.length; i++) {
                    const s = r[i]
                      , o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t
                      , a = s.getPoints(o);
                    for (let t = 0; t < a.length; t++) {
                        const i = a[t];
                        n && n.equals(i) || (e.push(i),
                        n = i)
                    }
                }
                return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
                e
            }
            copy(t) {
                super.copy(t),
                this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push(n.clone())
                }
                return this.autoClose = t.autoClose,
                this
            }
            toJSON() {
                const t = super.toJSON();
                t.autoClose = this.autoClose,
                t.curves = [];
                for (let e = 0, n = this.curves.length; e < n; e++) {
                    const n = this.curves[e];
                    t.curves.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.autoClose = t.autoClose,
                this.curves = [];
                for (let e = 0, n = t.curves.length; e < n; e++) {
                    const n = t.curves[e];
                    this.curves.push((new _f[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class wf extends bf {
            constructor(t) {
                super(),
                this.type = "Path",
                this.currentPoint = new Ia,
                t && this.setFromPoints(t)
            }
            setFromPoints(t) {
                this.moveTo(t[0].x, t[0].y);
                for (let e = 1, n = t.length; e < n; e++)
                    this.lineTo(t[e].x, t[e].y);
                return this
            }
            moveTo(t, e) {
                return this.currentPoint.set(t, e),
                this
            }
            lineTo(t, e) {
                const n = new gf(this.currentPoint.clone(),new Ia(t,e));
                return this.curves.push(n),
                this.currentPoint.set(t, e),
                this
            }
            quadraticCurveTo(t, e, n, i) {
                const r = new vf(this.currentPoint.clone(),new Ia(t,e),new Ia(n,i));
                return this.curves.push(r),
                this.currentPoint.set(n, i),
                this
            }
            bezierCurveTo(t, e, n, i, r, s) {
                const o = new ff(this.currentPoint.clone(),new Ia(t,e),new Ia(n,i),new Ia(r,s));
                return this.curves.push(o),
                this.currentPoint.set(r, s),
                this
            }
            splineThru(t) {
                const e = [this.currentPoint.clone()].concat(t)
                  , n = new xf(e);
                return this.curves.push(n),
                this.currentPoint.copy(t[t.length - 1]),
                this
            }
            arc(t, e, n, i, r, s) {
                const o = this.currentPoint.x
                  , a = this.currentPoint.y;
                return this.absarc(t + o, e + a, n, i, r, s),
                this
            }
            absarc(t, e, n, i, r, s) {
                return this.absellipse(t, e, n, n, i, r, s),
                this
            }
            ellipse(t, e, n, i, r, s, o, a) {
                const l = this.currentPoint.x
                  , c = this.currentPoint.y;
                return this.absellipse(t + l, e + c, n, i, r, s, o, a),
                this
            }
            absellipse(t, e, n, i, r, s, o, a) {
                const l = new nf(t,e,n,i,r,s,o,a);
                if (this.curves.length > 0) {
                    const t = l.getPoint(0);
                    t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                }
                this.curves.push(l);
                const c = l.getPoint(1);
                return this.currentPoint.copy(c),
                this
            }
            copy(t) {
                return super.copy(t),
                this.currentPoint.copy(t.currentPoint),
                this
            }
            toJSON() {
                const t = super.toJSON();
                return t.currentPoint = this.currentPoint.toArray(),
                t
            }
            fromJSON(t) {
                return super.fromJSON(t),
                this.currentPoint.fromArray(t.currentPoint),
                this
            }
        }
        class Mf extends wf {
            constructor(t) {
                super(t),
                this.uuid = Ta(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(t) {
                const e = [];
                for (let n = 0, i = this.holes.length; n < i; n++)
                    e[n] = this.holes[n].getPoints(t);
                return e
            }
            extractPoints(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            }
            copy(t) {
                super.copy(t),
                this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const t = super.toJSON();
                t.uuid = this.uuid,
                t.holes = [];
                for (let e = 0, n = this.holes.length; e < n; e++) {
                    const n = this.holes[e];
                    t.holes.push(n.toJSON())
                }
                return t
            }
            fromJSON(t) {
                super.fromJSON(t),
                this.uuid = t.uuid,
                this.holes = [];
                for (let e = 0, n = t.holes.length; e < n; e++) {
                    const n = t.holes[e];
                    this.holes.push((new wf).fromJSON(n))
                }
                return this
            }
        }
        function Sf(t, e, n, i, r) {
            let s, o;
            if (r === function(t, e, n, i) {
                let r = 0;
                for (let s = e, o = n - i; s < n; s += i)
                    r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]),
                    o = s;
                return r
            }(t, e, n, i) > 0)
                for (s = e; s < n; s += i)
                    o = jf(s, t[s], t[s + 1], o);
            else
                for (s = n - i; s >= e; s -= i)
                    o = jf(s, t[s], t[s + 1], o);
            return o && Bf(o, o.next) && (qf(o),
            o = o.next),
            o
        }
        function Tf(t, e) {
            if (!t)
                return t;
            e || (e = t);
            let n, i = t;
            do {
                if (n = !1,
                i.steiner || !Bf(i, i.next) && 0 !== Hf(i.prev, i, i.next))
                    i = i.next;
                else {
                    if (qf(i),
                    i = e = i.prev,
                    i === i.next)
                        break;
                    n = !0
                }
            } while (n || i !== e);
            return e
        }
        function Ef(t, e, n, i, r, s, o) {
            if (!t)
                return;
            !o && s && function(t, e, n, i) {
                let r = t;
                do {
                    null === r.z && (r.z = Of(r.x, r.y, e, n, i)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== t);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(t) {
                    let e, n, i, r, s, o, a, l, c = 1;
                    do {
                        for (n = t,
                        t = null,
                        s = null,
                        o = 0; n; ) {
                            for (o++,
                            i = n,
                            a = 0,
                            e = 0; e < c && (a++,
                            i = i.nextZ,
                            i); e++)
                                ;
                            for (l = c; a > 0 || l > 0 && i; )
                                0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n,
                                n = n.nextZ,
                                a--) : (r = i,
                                i = i.nextZ,
                                l--),
                                s ? s.nextZ = r : t = r,
                                r.prevZ = s,
                                s = r;
                            n = i
                        }
                        s.nextZ = null,
                        c *= 2
                    } while (o > 1)
                }(r)
            }(t, i, r, s);
            let a, l, c = t;
            for (; t.prev !== t.next; )
                if (a = t.prev,
                l = t.next,
                s ? Cf(t, i, r, s) : Af(t))
                    e.push(a.i / n),
                    e.push(t.i / n),
                    e.push(l.i / n),
                    qf(t),
                    t = l.next,
                    c = l.next;
                else if ((t = l) === c) {
                    o ? 1 === o ? Ef(t = Rf(Tf(t), e, n), e, n, i, r, s, 2) : 2 === o && Lf(t, e, n, i, r, s) : Ef(Tf(t), e, n, i, r, s, 1);
                    break
                }
        }
        function Af(t) {
            const e = t.prev
              , n = t
              , i = t.next;
            if (Hf(e, n, i) >= 0)
                return !1;
            let r = t.next.next;
            for (; r !== t.prev; ) {
                if (kf(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Hf(r.prev, r, r.next) >= 0)
                    return !1;
                r = r.next
            }
            return !0
        }
        function Cf(t, e, n, i) {
            const r = t.prev
              , s = t
              , o = t.next;
            if (Hf(r, s, o) >= 0)
                return !1;
            const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x
              , l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y
              , c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x
              , u = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y
              , h = Of(a, l, e, n, i)
              , d = Of(c, u, e, n, i);
            let p = t.prevZ
              , f = t.nextZ;
            for (; p && p.z >= h && f && f.z <= d; ) {
                if (p !== t.prev && p !== t.next && kf(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Hf(p.prev, p, p.next) >= 0)
                    return !1;
                if (p = p.prevZ,
                f !== t.prev && f !== t.next && kf(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Hf(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            for (; p && p.z >= h; ) {
                if (p !== t.prev && p !== t.next && kf(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Hf(p.prev, p, p.next) >= 0)
                    return !1;
                p = p.prevZ
            }
            for (; f && f.z <= d; ) {
                if (f !== t.prev && f !== t.next && kf(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Hf(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.nextZ
            }
            return !0
        }
        function Rf(t, e, n) {
            let i = t;
            do {
                const r = i.prev
                  , s = i.next.next;
                !Bf(r, s) && Ff(r, i, i.next, s) && Vf(r, s) && Vf(s, r) && (e.push(r.i / n),
                e.push(i.i / n),
                e.push(s.i / n),
                qf(i),
                qf(i.next),
                i = t = s),
                i = i.next
            } while (i !== t);
            return Tf(i)
        }
        function Lf(t, e, n, i, r, s) {
            let o = t;
            do {
                let t = o.next.next;
                for (; t !== o.prev; ) {
                    if (o.i !== t.i && zf(o, t)) {
                        let a = Wf(o, t);
                        return o = Tf(o, o.next),
                        a = Tf(a, a.next),
                        Ef(o, e, n, i, r, s),
                        void Ef(a, e, n, i, r, s)
                    }
                    t = t.next
                }
                o = o.next
            } while (o !== t)
        }
        function Pf(t, e) {
            return t.x - e.x
        }
        function Df(t, e) {
            if (e = function(t, e) {
                let n = e;
                const i = t.x
                  , r = t.y;
                let s, o = -1 / 0;
                do {
                    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                        const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                        if (t <= i && t > o) {
                            if (o = t,
                            t === i) {
                                if (r === n.y)
                                    return n;
                                if (r === n.next.y)
                                    return n.next
                            }
                            s = n.x < n.next.x ? n : n.next
                        }
                    }
                    n = n.next
                } while (n !== e);
                if (!s)
                    return null;
                if (i === o)
                    return s;
                const a = s
                  , l = s.x
                  , c = s.y;
                let u, h = 1 / 0;
                n = s;
                do {
                    i >= n.x && n.x >= l && i !== n.x && kf(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x),
                    Vf(n, t) && (u < h || u === h && (n.x > s.x || n.x === s.x && If(s, n))) && (s = n,
                    h = u)),
                    n = n.next
                } while (n !== a);
                return s
            }(t, e)) {
                const n = Wf(e, t);
                Tf(e, e.next),
                Tf(n, n.next)
            }
        }
        function If(t, e) {
            return Hf(t.prev, t, e.prev) < 0 && Hf(e.next, t, t.next) < 0
        }
        function Of(t, e, n, i, r) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function Nf(t) {
            let e = t
              , n = t;
            do {
                (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
                e = e.next
            } while (e !== t);
            return n
        }
        function kf(t, e, n, i, r, s, o, a) {
            return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0
        }
        function zf(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                let n = t;
                do {
                    if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Ff(n, n.next, t, e))
                        return !0;
                    n = n.next
                } while (n !== t);
                return !1
            }(t, e) && (Vf(t, e) && Vf(e, t) && function(t, e) {
                let n = t
                  , i = !1;
                const r = (t.x + e.x) / 2
                  , s = (t.y + e.y) / 2;
                do {
                    n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                    n = n.next
                } while (n !== t);
                return i
            }(t, e) && (Hf(t.prev, t, e.prev) || Hf(t, e.prev, e)) || Bf(t, e) && Hf(t.prev, t, t.next) > 0 && Hf(e.prev, e, e.next) > 0)
        }
        function Hf(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }
        function Bf(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function Ff(t, e, n, i) {
            const r = Gf(Hf(t, e, n))
              , s = Gf(Hf(t, e, i))
              , o = Gf(Hf(n, i, t))
              , a = Gf(Hf(n, i, e));
            return r !== s && o !== a || !(0 !== r || !Uf(t, n, e)) || !(0 !== s || !Uf(t, i, e)) || !(0 !== o || !Uf(n, t, i)) || !(0 !== a || !Uf(n, e, i))
        }
        function Uf(t, e, n) {
            return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
        }
        function Gf(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        }
        function Vf(t, e) {
            return Hf(t.prev, t, t.next) < 0 ? Hf(t, e, t.next) >= 0 && Hf(t, t.prev, e) >= 0 : Hf(t, e, t.prev) < 0 || Hf(t, t.next, e) < 0
        }
        function Wf(t, e) {
            const n = new Xf(t.i,t.x,t.y)
              , i = new Xf(e.i,e.x,e.y)
              , r = t.next
              , s = e.prev;
            return t.next = e,
            e.prev = t,
            n.next = r,
            r.prev = n,
            i.next = n,
            n.prev = i,
            s.next = i,
            i.prev = s,
            i
        }
        function jf(t, e, n, i) {
            const r = new Xf(t,e,n);
            return i ? (r.next = i.next,
            r.prev = i,
            i.next.prev = r,
            i.next = r) : (r.prev = r,
            r.next = r),
            r
        }
        function qf(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function Xf(t, e, n) {
            this.i = t,
            this.x = e,
            this.y = n,
            this.prev = null,
            this.next = null,
            this.z = null,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class Yf {
            static area(t) {
                const e = t.length;
                let n = 0;
                for (let i = e - 1, r = 0; r < e; i = r++)
                    n += t[i].x * t[r].y - t[r].x * t[i].y;
                return .5 * n
            }
            static isClockWise(t) {
                return Yf.area(t) < 0
            }
            static triangulateShape(t, e) {
                const n = []
                  , i = []
                  , r = [];
                Jf(t),
                Zf(n, t);
                let s = t.length;
                e.forEach(Jf);
                for (let t = 0; t < e.length; t++)
                    i.push(s),
                    s += e[t].length,
                    Zf(n, e[t]);
                const o = function(t, e, n=2) {
                    const i = e && e.length
                      , r = i ? e[0] * n : t.length;
                    let s = Sf(t, 0, r, n, !0);
                    const o = [];
                    if (!s || s.next === s.prev)
                        return o;
                    let a, l, c, u, h, d, p;
                    if (i && (s = function(t, e, n, i) {
                        const r = [];
                        let s, o, a, l, c;
                        for (s = 0,
                        o = e.length; s < o; s++)
                            a = e[s] * i,
                            l = s < o - 1 ? e[s + 1] * i : t.length,
                            c = Sf(t, a, l, i, !1),
                            c === c.next && (c.steiner = !0),
                            r.push(Nf(c));
                        for (r.sort(Pf),
                        s = 0; s < r.length; s++)
                            Df(r[s], n),
                            n = Tf(n, n.next);
                        return n
                    }(t, e, s, n)),
                    t.length > 80 * n) {
                        a = c = t[0],
                        l = u = t[1];
                        for (let e = n; e < r; e += n)
                            h = t[e],
                            d = t[e + 1],
                            h < a && (a = h),
                            d < l && (l = d),
                            h > c && (c = h),
                            d > u && (u = d);
                        p = Math.max(c - a, u - l),
                        p = 0 !== p ? 1 / p : 0
                    }
                    return Ef(s, o, n, a, l, p),
                    o
                }(n, i);
                for (let t = 0; t < o.length; t += 3)
                    r.push(o.slice(t, t + 3));
                return r
            }
        }
        function Jf(t) {
            const e = t.length;
            e > 2 && t[e - 1].equals(t[0]) && t.pop()
        }
        function Zf(t, e) {
            for (let n = 0; n < e.length; n++)
                t.push(e[n].x),
                t.push(e[n].y)
        }
        class Kf extends Rc {
            constructor(t=new Mf([new Ia(.5,.5), new Ia(-.5,.5), new Ia(-.5,-.5), new Ia(.5,-.5)]), e={}) {
                super(),
                this.type = "ExtrudeGeometry",
                this.parameters = {
                    shapes: t,
                    options: e
                },
                t = Array.isArray(t) ? t : [t];
                const n = this
                  , i = []
                  , r = [];
                for (let e = 0, n = t.length; e < n; e++)
                    s(t[e]);
                function s(t) {
                    const s = []
                      , o = void 0 !== e.curveSegments ? e.curveSegments : 12
                      , a = void 0 !== e.steps ? e.steps : 1;
                    let l = void 0 !== e.depth ? e.depth : 1
                      , c = void 0 === e.bevelEnabled || e.bevelEnabled
                      , u = void 0 !== e.bevelThickness ? e.bevelThickness : .2
                      , h = void 0 !== e.bevelSize ? e.bevelSize : u - .1
                      , d = void 0 !== e.bevelOffset ? e.bevelOffset : 0
                      , p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                    const f = e.extrudePath
                      , m = void 0 !== e.UVGenerator ? e.UVGenerator : Qf;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                    l = e.amount);
                    let g, v, y, x, _, b = !1;
                    f && (g = f.getSpacedPoints(a),
                    b = !0,
                    c = !1,
                    v = f.computeFrenetFrames(a, !1),
                    y = new $a,
                    x = new $a,
                    _ = new $a),
                    c || (p = 0,
                    u = 0,
                    h = 0,
                    d = 0);
                    const w = t.extractPoints(o);
                    let M = w.shape;
                    const S = w.holes;
                    if (!Yf.isClockWise(M)) {
                        M = M.reverse();
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            Yf.isClockWise(e) && (S[t] = e.reverse())
                        }
                    }
                    const T = Yf.triangulateShape(M, S)
                      , E = M;
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        M = M.concat(e)
                    }
                    function A(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        e.clone().multiplyScalar(n).add(t)
                    }
                    const C = M.length
                      , R = T.length;
                    function L(t, e, n) {
                        let i, r, s;
                        const o = t.x - e.x
                          , a = t.y - e.y
                          , l = n.x - t.x
                          , c = n.y - t.y
                          , u = o * o + a * a
                          , h = o * c - a * l;
                        if (Math.abs(h) > Number.EPSILON) {
                            const h = Math.sqrt(u)
                              , d = Math.sqrt(l * l + c * c)
                              , p = e.x - a / h
                              , f = e.y + o / h
                              , m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (o * c - a * l);
                            i = p + o * m - t.x,
                            r = f + a * m - t.y;
                            const g = i * i + r * r;
                            if (g <= 2)
                                return new Ia(i,r);
                            s = Math.sqrt(g / 2)
                        } else {
                            let t = !1;
                            o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0),
                            t ? (i = -a,
                            r = o,
                            s = Math.sqrt(u)) : (i = o,
                            r = a,
                            s = Math.sqrt(u / 2))
                        }
                        return new Ia(i / s,r / s)
                    }
                    const P = [];
                    for (let t = 0, e = E.length, n = e - 1, i = t + 1; t < e; t++,
                    n++,
                    i++)
                        n === e && (n = 0),
                        i === e && (i = 0),
                        P[t] = L(E[t], E[n], E[i]);
                    const D = [];
                    let I, O = P.concat();
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        I = [];
                        for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++,
                        i++,
                        r++)
                            i === n && (i = 0),
                            r === n && (r = 0),
                            I[t] = L(e[t], e[i], e[r]);
                        D.push(I),
                        O = O.concat(I)
                    }
                    for (let t = 0; t < p; t++) {
                        const e = t / p
                          , n = u * Math.cos(e * Math.PI / 2)
                          , i = h * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = E.length; t < e; t++) {
                            const e = A(E[t], P[t], i);
                            z(e.x, e.y, -n)
                        }
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            I = D[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = A(e[t], I[t], i);
                                z(r.x, r.y, -n)
                            }
                        }
                    }
                    const N = h + d;
                    for (let t = 0; t < C; t++) {
                        const e = c ? A(M[t], O[t], N) : M[t];
                        b ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                        y.copy(v.binormals[0]).multiplyScalar(e.y),
                        _.copy(g[0]).add(x).add(y),
                        z(_.x, _.y, _.z)) : z(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= a; t++)
                        for (let e = 0; e < C; e++) {
                            const n = c ? A(M[e], O[e], N) : M[e];
                            b ? (x.copy(v.normals[t]).multiplyScalar(n.x),
                            y.copy(v.binormals[t]).multiplyScalar(n.y),
                            _.copy(g[t]).add(x).add(y),
                            z(_.x, _.y, _.z)) : z(n.x, n.y, l / a * t)
                        }
                    for (let t = p - 1; t >= 0; t--) {
                        const e = t / p
                          , n = u * Math.cos(e * Math.PI / 2)
                          , i = h * Math.sin(e * Math.PI / 2) + d;
                        for (let t = 0, e = E.length; t < e; t++) {
                            const e = A(E[t], P[t], i);
                            z(e.x, e.y, l + n)
                        }
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            I = D[t];
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = A(e[t], I[t], i);
                                b ? z(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : z(r.x, r.y, l + n)
                            }
                        }
                    }
                    function k(t, e) {
                        let n = t.length;
                        for (; --n >= 0; ) {
                            const i = n;
                            let r = n - 1;
                            r < 0 && (r = t.length - 1);
                            for (let t = 0, n = a + 2 * p; t < n; t++) {
                                const n = C * t
                                  , s = C * (t + 1);
                                B(e + i + n, e + r + n, e + r + s, e + i + s)
                            }
                        }
                    }
                    function z(t, e, n) {
                        s.push(t),
                        s.push(e),
                        s.push(n)
                    }
                    function H(t, e, r) {
                        F(t),
                        F(e),
                        F(r);
                        const s = i.length / 3
                          , o = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
                        U(o[0]),
                        U(o[1]),
                        U(o[2])
                    }
                    function B(t, e, r, s) {
                        F(t),
                        F(e),
                        F(s),
                        F(e),
                        F(r),
                        F(s);
                        const o = i.length / 3
                          , a = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                        U(a[0]),
                        U(a[1]),
                        U(a[3]),
                        U(a[1]),
                        U(a[2]),
                        U(a[3])
                    }
                    function F(t) {
                        i.push(s[3 * t + 0]),
                        i.push(s[3 * t + 1]),
                        i.push(s[3 * t + 2])
                    }
                    function U(t) {
                        r.push(t.x),
                        r.push(t.y)
                    }
                    !function() {
                        const t = i.length / 3;
                        if (c) {
                            let t = 0
                              , e = C * t;
                            for (let t = 0; t < R; t++) {
                                const n = T[t];
                                H(n[2] + e, n[1] + e, n[0] + e)
                            }
                            t = a + 2 * p,
                            e = C * t;
                            for (let t = 0; t < R; t++) {
                                const n = T[t];
                                H(n[0] + e, n[1] + e, n[2] + e)
                            }
                        } else {
                            for (let t = 0; t < R; t++) {
                                const e = T[t];
                                H(e[2], e[1], e[0])
                            }
                            for (let t = 0; t < R; t++) {
                                const e = T[t];
                                H(e[0] + C * a, e[1] + C * a, e[2] + C * a)
                            }
                        }
                        n.addGroup(t, i.length / 3 - t, 0)
                    }(),
                    function() {
                        const t = i.length / 3;
                        let e = 0;
                        k(E, e),
                        e += E.length;
                        for (let t = 0, n = S.length; t < n; t++) {
                            const n = S[t];
                            k(n, e),
                            e += n.length
                        }
                        n.addGroup(t, i.length / 3 - t, 1)
                    }()
                }
                this.setAttribute("position", new bc(i,3)),
                this.setAttribute("uv", new bc(r,2)),
                this.computeVertexNormals()
            }
            toJSON() {
                const t = super.toJSON();
                return function(t, e, n) {
                    if (n.shapes = [],
                    Array.isArray(t))
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e];
                            n.shapes.push(i.uuid)
                        }
                    else
                        n.shapes.push(t.uuid);
                    return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()),
                    n
                }(this.parameters.shapes, this.parameters.options, t)
            }
            static fromJSON(t, e) {
                const n = [];
                for (let i = 0, r = t.shapes.length; i < r; i++) {
                    const r = e[t.shapes[i]];
                    n.push(r)
                }
                const i = t.options.extrudePath;
                return void 0 !== i && (t.options.extrudePath = (new _f[i.type]).fromJSON(i)),
                new Kf(n,t.options)
            }
        }
        const Qf = {
            generateTopUV: function(t, e, n, i, r) {
                const s = e[3 * n]
                  , o = e[3 * n + 1]
                  , a = e[3 * i]
                  , l = e[3 * i + 1]
                  , c = e[3 * r]
                  , u = e[3 * r + 1];
                return [new Ia(s,o), new Ia(a,l), new Ia(c,u)]
            },
            generateSideWallUV: function(t, e, n, i, r, s) {
                const o = e[3 * n]
                  , a = e[3 * n + 1]
                  , l = e[3 * n + 2]
                  , c = e[3 * i]
                  , u = e[3 * i + 1]
                  , h = e[3 * i + 2]
                  , d = e[3 * r]
                  , p = e[3 * r + 1]
                  , f = e[3 * r + 2]
                  , m = e[3 * s]
                  , g = e[3 * s + 1]
                  , v = e[3 * s + 2];
                return Math.abs(a - u) < Math.abs(o - c) ? [new Ia(o,1 - l), new Ia(c,1 - h), new Ia(d,1 - f), new Ia(m,1 - v)] : [new Ia(a,1 - l), new Ia(u,1 - h), new Ia(p,1 - f), new Ia(g,1 - v)]
            }
        };
        class $f extends Rc {
            constructor(t=new Mf([new Ia(0,.5), new Ia(-.5,-.5), new Ia(.5,-.5)]), e=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: t,
                    curveSegments: e
                };
                const n = []
                  , i = []
                  , r = []
                  , s = [];
                let o = 0
                  , a = 0;
                if (!1 === Array.isArray(t))
                    l(t);
                else
                    for (let e = 0; e < t.length; e++)
                        l(t[e]),
                        this.addGroup(o, a, e),
                        o += a,
                        a = 0;
                function l(t) {
                    const o = i.length / 3
                      , l = t.extractPoints(e);
                    let c = l.shape;
                    const u = l.holes;
                    !1 === Yf.isClockWise(c) && (c = c.reverse());
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        !0 === Yf.isClockWise(e) && (u[t] = e.reverse())
                    }
                    const h = Yf.triangulateShape(c, u);
                    for (let t = 0, e = u.length; t < e; t++) {
                        const e = u[t];
                        c = c.concat(e)
                    }
                    for (let t = 0, e = c.length; t < e; t++) {
                        const e = c[t];
                        i.push(e.x, e.y, 0),
                        r.push(0, 0, 1),
                        s.push(e.x, e.y)
                    }
                    for (let t = 0, e = h.length; t < e; t++) {
                        const e = h[t]
                          , i = e[0] + o
                          , r = e[1] + o
                          , s = e[2] + o;
                        n.push(i, r, s),
                        a += 3
                    }
                }
                this.setIndex(n),
                this.setAttribute("position", new bc(i,3)),
                this.setAttribute("normal", new bc(r,3)),
                this.setAttribute("uv", new bc(s,2))
            }
            toJSON() {
                const t = super.toJSON();
                return function(t, e) {
                    if (e.shapes = [],
                    Array.isArray(t))
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            e.shapes.push(i.uuid)
                        }
                    else
                        e.shapes.push(t.uuid);
                    return e
                }(this.parameters.shapes, t)
            }
            static fromJSON(t, e) {
                const n = [];
                for (let i = 0, r = t.shapes.length; i < r; i++) {
                    const r = e[t.shapes[i]];
                    n.push(r)
                }
                return new $f(n,t.curveSegments)
            }
        }
        (class extends fc {
            constructor(t) {
                super(),
                this.type = "ShadowMaterial",
                this.color = new Va(0),
                this.transparent = !0,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this
            }
        }
        ).prototype.isShadowMaterial = !0;
        class tm extends fc {
            constructor(t) {
                super(),
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new Va(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Va(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Ia(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(t.color),
                this.roughness = t.roughness,
                this.metalness = t.metalness,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.roughnessMap = t.roughnessMap,
                this.metalnessMap = t.metalnessMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.envMapIntensity = t.envMapIntensity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.flatShading = t.flatShading,
                this
            }
        }
        tm.prototype.isMeshStandardMaterial = !0;
        class em extends tm {
            constructor(t) {
                super(),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new Ia(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return Ea(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(t) {
                        this.ior = (1 + .4 * t) / (1 - .4 * t)
                    }
                }),
                this.sheenColor = new Va(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 0,
                this.attenuationColor = new Va(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new Va(1,1,1),
                this.specularColorMap = null,
                this._sheen = 0,
                this._clearcoat = 0,
                this._transmission = 0,
                this.setValues(t)
            }
            get sheen() {
                return this._sheen
            }
            set sheen(t) {
                this._sheen > 0 != t > 0 && this.version++,
                this._sheen = t
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(t) {
                this._clearcoat > 0 != t > 0 && this.version++,
                this._clearcoat = t
            }
            get transmission() {
                return this._transmission
            }
            set transmission(t) {
                this._transmission > 0 != t > 0 && this.version++,
                this._transmission = t
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.clearcoat = t.clearcoat,
                this.clearcoatMap = t.clearcoatMap,
                this.clearcoatRoughness = t.clearcoatRoughness,
                this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
                this.clearcoatNormalMap = t.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                this.ior = t.ior,
                this.sheen = t.sheen,
                this.sheenColor.copy(t.sheenColor),
                this.sheenColorMap = t.sheenColorMap,
                this.sheenRoughness = t.sheenRoughness,
                this.sheenRoughnessMap = t.sheenRoughnessMap,
                this.transmission = t.transmission,
                this.transmissionMap = t.transmissionMap,
                this.thickness = t.thickness,
                this.thicknessMap = t.thicknessMap,
                this.attenuationDistance = t.attenuationDistance,
                this.attenuationColor.copy(t.attenuationColor),
                this.specularIntensity = t.specularIntensity,
                this.specularIntensityMap = t.specularIntensityMap,
                this.specularColor.copy(t.specularColor),
                this.specularColorMap = t.specularColorMap,
                this
            }
        }
        em.prototype.isMeshPhysicalMaterial = !0;
        (class extends fc {
            constructor(t) {
                super(),
                this.type = "MeshPhongMaterial",
                this.color = new Va(16777215),
                this.specular = new Va(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Va(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Ia(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.specular.copy(t.specular),
                this.shininess = t.shininess,
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this.flatShading = t.flatShading,
                this
            }
        }
        ).prototype.isMeshPhongMaterial = !0;
        (class extends fc {
            constructor(t) {
                super(),
                this.defines = {
                    TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new Va(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Va(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Ia(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.gradientMap = t.gradientMap,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.alphaMap = t.alphaMap,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this
            }
        }
        ).prototype.isMeshToonMaterial = !0;
        (class extends fc {
            constructor(t) {
                super(),
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Ia(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.flatShading = t.flatShading,
                this
            }
        }
        ).prototype.isMeshNormalMaterial = !0;
        (class extends fc {
            constructor(t) {
                super(),
                this.type = "MeshLambertMaterial",
                this.color = new Va(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Va(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = 0,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.map = t.map,
                this.lightMap = t.lightMap,
                this.lightMapIntensity = t.lightMapIntensity,
                this.aoMap = t.aoMap,
                this.aoMapIntensity = t.aoMapIntensity,
                this.emissive.copy(t.emissive),
                this.emissiveMap = t.emissiveMap,
                this.emissiveIntensity = t.emissiveIntensity,
                this.specularMap = t.specularMap,
                this.alphaMap = t.alphaMap,
                this.envMap = t.envMap,
                this.combine = t.combine,
                this.reflectivity = t.reflectivity,
                this.refractionRatio = t.refractionRatio,
                this.wireframe = t.wireframe,
                this.wireframeLinewidth = t.wireframeLinewidth,
                this.wireframeLinecap = t.wireframeLinecap,
                this.wireframeLinejoin = t.wireframeLinejoin,
                this
            }
        }
        ).prototype.isMeshLambertMaterial = !0;
        (class extends fc {
            constructor(t) {
                super(),
                this.defines = {
                    MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new Va(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Ia(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.flatShading = !1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.defines = {
                    MATCAP: ""
                },
                this.color.copy(t.color),
                this.matcap = t.matcap,
                this.map = t.map,
                this.bumpMap = t.bumpMap,
                this.bumpScale = t.bumpScale,
                this.normalMap = t.normalMap,
                this.normalMapType = t.normalMapType,
                this.normalScale.copy(t.normalScale),
                this.displacementMap = t.displacementMap,
                this.displacementScale = t.displacementScale,
                this.displacementBias = t.displacementBias,
                this.alphaMap = t.alphaMap,
                this.flatShading = t.flatShading,
                this
            }
        }
        ).prototype.isMeshMatcapMaterial = !0;
        (class extends zp {
            constructor(t) {
                super(),
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.scale = t.scale,
                this.dashSize = t.dashSize,
                this.gapSize = t.gapSize,
                this
            }
        }
        ).prototype.isLineDashedMaterial = !0;
        const nm = {
            arraySlice: function(t, e, n) {
                return nm.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
            },
            convertArray: function(t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                const e = t.length
                  , n = new Array(e);
                for (let t = 0; t !== e; ++t)
                    n[t] = t;
                return n.sort((function(e, n) {
                    return t[e] - t[n]
                }
                )),
                n
            },
            sortedArray: function(t, e, n) {
                const i = t.length
                  , r = new t.constructor(i);
                for (let s = 0, o = 0; o !== i; ++s) {
                    const i = n[s] * e;
                    for (let n = 0; n !== e; ++n)
                        r[o++] = t[i + n]
                }
                return r
            },
            flattenJSON: function(t, e, n, i) {
                let r = 1
                  , s = t[0];
                for (; void 0 !== s && void 0 === s[i]; )
                    s = t[r++];
                if (void 0 === s)
                    return;
                let o = s[i];
                if (void 0 !== o)
                    if (Array.isArray(o))
                        do {
                            o = s[i],
                            void 0 !== o && (e.push(s.time),
                            n.push.apply(n, o)),
                            s = t[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== o.toArray)
                        do {
                            o = s[i],
                            void 0 !== o && (e.push(s.time),
                            o.toArray(n, n.length)),
                            s = t[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            o = s[i],
                            void 0 !== o && (e.push(s.time),
                            n.push(o)),
                            s = t[r++]
                        } while (void 0 !== s)
            },
            subclip: function(t, e, n, i, r=30) {
                const s = t.clone();
                s.name = e;
                const o = [];
                for (let t = 0; t < s.tracks.length; ++t) {
                    const e = s.tracks[t]
                      , a = e.getValueSize()
                      , l = []
                      , c = [];
                    for (let t = 0; t < e.times.length; ++t) {
                        const s = e.times[t] * r;
                        if (!(s < n || s >= i)) {
                            l.push(e.times[t]);
                            for (let n = 0; n < a; ++n)
                                c.push(e.values[t * a + n])
                        }
                    }
                    0 !== l.length && (e.times = nm.convertArray(l, e.times.constructor),
                    e.values = nm.convertArray(c, e.values.constructor),
                    o.push(e))
                }
                s.tracks = o;
                let a = 1 / 0;
                for (let t = 0; t < s.tracks.length; ++t)
                    a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
                for (let t = 0; t < s.tracks.length; ++t)
                    s.tracks[t].shift(-1 * a);
                return s.resetDuration(),
                s
            },
            makeClipAdditive: function(t, e=0, n=t, i=30) {
                i <= 0 && (i = 30);
                const r = n.tracks.length
                  , s = e / i;
                for (let e = 0; e < r; ++e) {
                    const i = n.tracks[e]
                      , r = i.ValueTypeName;
                    if ("bool" === r || "string" === r)
                        continue;
                    const o = t.tracks.find((function(t) {
                        return t.name === i.name && t.ValueTypeName === r
                    }
                    ));
                    if (void 0 === o)
                        continue;
                    let a = 0;
                    const l = i.getValueSize();
                    i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                    let c = 0;
                    const u = o.getValueSize();
                    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                    const h = i.times.length - 1;
                    let d;
                    if (s <= i.times[0]) {
                        const t = a
                          , e = l - a;
                        d = nm.arraySlice(i.values, t, e)
                    } else if (s >= i.times[h]) {
                        const t = h * l + a
                          , e = t + l - a;
                        d = nm.arraySlice(i.values, t, e)
                    } else {
                        const t = i.createInterpolant()
                          , e = a
                          , n = l - a;
                        t.evaluate(s),
                        d = nm.arraySlice(t.resultBuffer, e, n)
                    }
                    "quaternion" === r && (new Qa).fromArray(d).normalize().conjugate().toArray(d);
                    const p = o.times.length;
                    for (let t = 0; t < p; ++t) {
                        const e = t * u + c;
                        if ("quaternion" === r)
                            Qa.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                        else {
                            const t = u - 2 * c;
                            for (let n = 0; n < t; ++n)
                                o.values[e + n] -= d[n]
                        }
                    }
                }
                return t.blendMode = 2501,
                t
            }
        };
        class im {
            constructor(t, e, n, i) {
                this.parameterPositions = t,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
                this.sampleValues = e,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(t) {
                const e = this.parameterPositions;
                let n = this._cachedIndex
                  , i = e[n]
                  , r = e[n - 1];
                t: {
                    e: {
                        let s;
                        n: {
                            i: if (!(t < i)) {
                                for (let s = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (t < r)
                                            break i;
                                        return n = e.length,
                                        this._cachedIndex = n,
                                        this.afterEnd_(n - 1, t, r)
                                    }
                                    if (n === s)
                                        break;
                                    if (r = i,
                                    i = e[++n],
                                    t < i)
                                        break e
                                }
                                s = e.length;
                                break n
                            }
                            if (t >= r)
                                break t;
                            {
                                const o = e[1];
                                t < o && (n = 2,
                                r = o);
                                for (let s = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.beforeStart_(0, t, i);
                                    if (n === s)
                                        break;
                                    if (i = r,
                                    r = e[--n - 1],
                                    t >= r)
                                        break e
                                }
                                s = n,
                                n = 0
                            }
                        }
                        for (; n < s; ) {
                            const i = n + s >>> 1;
                            t < e[i] ? s = i : n = i + 1
                        }
                        if (i = e[n],
                        r = e[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.beforeStart_(0, t, i);
                        if (void 0 === i)
                            return n = e.length,
                            this._cachedIndex = n,
                            this.afterEnd_(n - 1, r, t)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = t * i;
                for (let t = 0; t !== i; ++t)
                    e[t] = n[r + t];
                return e
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        im.prototype.beforeStart_ = im.prototype.copySampleValue_,
        im.prototype.afterEnd_ = im.prototype.copySampleValue_;
        class rm extends im {
            constructor(t, e, n, i) {
                super(t, e, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: ua,
                    endingEnd: ua
                }
            }
            intervalChanged_(t, e, n) {
                const i = this.parameterPositions;
                let r = t - 2
                  , s = t + 1
                  , o = i[r]
                  , a = i[s];
                if (void 0 === o)
                    switch (this.getSettings_().endingStart) {
                    case ha:
                        r = t,
                        o = 2 * e - n;
                        break;
                    case da:
                        r = i.length - 2,
                        o = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t,
                        o = n
                    }
                if (void 0 === a)
                    switch (this.getSettings_().endingEnd) {
                    case ha:
                        s = t,
                        a = 2 * n - e;
                        break;
                    case da:
                        s = 1,
                        a = n + i[1] - i[0];
                        break;
                    default:
                        s = t - 1,
                        a = e
                    }
                const l = .5 * (n - e)
                  , c = this.valueSize;
                this._weightPrev = l / (e - o),
                this._weightNext = l / (a - n),
                this._offsetPrev = r * c,
                this._offsetNext = s * c
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , o = this.valueSize
                  , a = t * o
                  , l = a - o
                  , c = this._offsetPrev
                  , u = this._offsetNext
                  , h = this._weightPrev
                  , d = this._weightNext
                  , p = (n - e) / (i - e)
                  , f = p * p
                  , m = f * p
                  , g = -h * m + 2 * h * f - h * p
                  , v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
                  , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
                  , x = d * m - d * f;
                for (let t = 0; t !== o; ++t)
                    r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + x * s[u + t];
                return r
            }
        }
        class sm extends im {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , o = this.valueSize
                  , a = t * o
                  , l = a - o
                  , c = (n - e) / (i - e)
                  , u = 1 - c;
                for (let t = 0; t !== o; ++t)
                    r[t] = s[l + t] * u + s[a + t] * c;
                return r
            }
        }
        class om extends im {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t) {
                return this.copySampleValue_(t - 1)
            }
        }
        class am {
            constructor(t, e, n, i) {
                if (void 0 === t)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t,
                this.times = nm.convertArray(e, this.TimeBufferType),
                this.values = nm.convertArray(n, this.ValueBufferType),
                this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(t) {
                const e = t.constructor;
                let n;
                if (e.toJSON !== this.toJSON)
                    n = e.toJSON(t);
                else {
                    n = {
                        name: t.name,
                        times: nm.convertArray(t.times, Array),
                        values: nm.convertArray(t.values, Array)
                    };
                    const e = t.getInterpolation();
                    e !== t.DefaultInterpolation && (n.interpolation = e)
                }
                return n.type = t.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(t) {
                return new om(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodLinear(t) {
                return new sm(this.times,this.values,this.getValueSize(),t)
            }
            InterpolantFactoryMethodSmooth(t) {
                return new rm(this.times,this.values,this.getValueSize(),t)
            }
            setInterpolation(t) {
                let e;
                switch (t) {
                case aa:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case la:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case ca:
                    e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)
                            throw new Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e),
                    this
                }
                return this.createInterpolant = e,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return aa;
                case this.InterpolantFactoryMethodLinear:
                    return la;
                case this.InterpolantFactoryMethodSmooth:
                    return ca
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(t) {
                if (0 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] += t
                }
                return this
            }
            scale(t) {
                if (1 !== t) {
                    const e = this.times;
                    for (let n = 0, i = e.length; n !== i; ++n)
                        e[n] *= t
                }
                return this
            }
            trim(t, e) {
                const n = this.times
                  , i = n.length;
                let r = 0
                  , s = i - 1;
                for (; r !== i && n[r] < t; )
                    ++r;
                for (; -1 !== s && n[s] > e; )
                    --s;
                if (++s,
                0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1),
                    r = s - 1);
                    const t = this.getValueSize();
                    this.times = nm.arraySlice(n, r, s),
                    this.values = nm.arraySlice(this.values, r * t, s * t)
                }
                return this
            }
            validate() {
                let t = !0;
                const e = this.getValueSize();
                e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                t = !1);
                const n = this.times
                  , i = this.values
                  , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                t = !1);
                let s = null;
                for (let e = 0; e !== r; e++) {
                    const i = n[e];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i),
                        t = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s),
                        t = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && nm.isTypedArray(i))
                    for (let e = 0, n = i.length; e !== n; ++e) {
                        const n = i[e];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                            t = !1;
                            break
                        }
                    }
                return t
            }
            optimize() {
                const t = nm.arraySlice(this.times)
                  , e = nm.arraySlice(this.values)
                  , n = this.getValueSize()
                  , i = this.getInterpolation() === ca
                  , r = t.length - 1;
                let s = 1;
                for (let o = 1; o < r; ++o) {
                    let r = !1;
                    const a = t[o];
                    if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                        if (i)
                            r = !0;
                        else {
                            const t = o * n
                              , i = t - n
                              , s = t + n;
                            for (let o = 0; o !== n; ++o) {
                                const n = e[t + o];
                                if (n !== e[i + o] || n !== e[s + o]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (o !== s) {
                            t[s] = t[o];
                            const i = o * n
                              , r = s * n;
                            for (let t = 0; t !== n; ++t)
                                e[r + t] = e[i + t]
                        }
                        ++s
                    }
                }
                if (r > 0) {
                    t[s] = t[r];
                    for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
                        e[i + o] = e[t + o];
                    ++s
                }
                return s !== t.length ? (this.times = nm.arraySlice(t, 0, s),
                this.values = nm.arraySlice(e, 0, s * n)) : (this.times = t,
                this.values = e),
                this
            }
            clone() {
                const t = nm.arraySlice(this.times, 0)
                  , e = nm.arraySlice(this.values, 0)
                  , n = new (0,
                this.constructor)(this.name,t,e);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        am.prototype.TimeBufferType = Float32Array,
        am.prototype.ValueBufferType = Float32Array,
        am.prototype.DefaultInterpolation = la;
        class lm extends am {
        }
        lm.prototype.ValueTypeName = "bool",
        lm.prototype.ValueBufferType = Array,
        lm.prototype.DefaultInterpolation = aa,
        lm.prototype.InterpolantFactoryMethodLinear = void 0,
        lm.prototype.InterpolantFactoryMethodSmooth = void 0;
        class cm extends am {
        }
        cm.prototype.ValueTypeName = "color";
        class um extends am {
        }
        um.prototype.ValueTypeName = "number";
        class hm extends im {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            interpolate_(t, e, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , o = this.valueSize
                  , a = (n - e) / (i - e);
                let l = t * o;
                for (let t = l + o; l !== t; l += 4)
                    Qa.slerpFlat(r, 0, s, l - o, s, l, a);
                return r
            }
        }
        class dm extends am {
            InterpolantFactoryMethodLinear(t) {
                return new hm(this.times,this.values,this.getValueSize(),t)
            }
        }
        dm.prototype.ValueTypeName = "quaternion",
        dm.prototype.DefaultInterpolation = la,
        dm.prototype.InterpolantFactoryMethodSmooth = void 0;
        class pm extends am {
        }
        pm.prototype.ValueTypeName = "string",
        pm.prototype.ValueBufferType = Array,
        pm.prototype.DefaultInterpolation = aa,
        pm.prototype.InterpolantFactoryMethodLinear = void 0,
        pm.prototype.InterpolantFactoryMethodSmooth = void 0;
        class fm extends am {
        }
        fm.prototype.ValueTypeName = "vector";
        class mm {
            constructor(t, e=-1, n, i=2500) {
                this.name = t,
                this.tracks = n,
                this.duration = e,
                this.blendMode = i,
                this.uuid = Ta(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(t) {
                const e = []
                  , n = t.tracks
                  , i = 1 / (t.fps || 1);
                for (let t = 0, r = n.length; t !== r; ++t)
                    e.push(gm(n[t]).scale(i));
                const r = new this(t.name,t.duration,e,t.blendMode);
                return r.uuid = t.uuid,
                r
            }
            static toJSON(t) {
                const e = []
                  , n = t.tracks
                  , i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid,
                    blendMode: t.blendMode
                };
                for (let t = 0, i = n.length; t !== i; ++t)
                    e.push(am.toJSON(n[t]));
                return i
            }
            static CreateFromMorphTargetSequence(t, e, n, i) {
                const r = e.length
                  , s = [];
                for (let t = 0; t < r; t++) {
                    let o = []
                      , a = [];
                    o.push((t + r - 1) % r, t, (t + 1) % r),
                    a.push(0, 1, 0);
                    const l = nm.getKeyframeOrder(o);
                    o = nm.sortedArray(o, 1, l),
                    a = nm.sortedArray(a, 1, l),
                    i || 0 !== o[0] || (o.push(r),
                    a.push(a[0])),
                    s.push(new um(".morphTargetInfluences[" + e[t].name + "]",o,a).scale(1 / n))
                }
                return new this(t,-1,s)
            }
            static findByName(t, e) {
                let n = t;
                if (!Array.isArray(t)) {
                    const e = t;
                    n = e.geometry && e.geometry.animations || e.animations
                }
                for (let t = 0; t < n.length; t++)
                    if (n[t].name === e)
                        return n[t];
                return null
            }
            static CreateClipsFromMorphTargetSequences(t, e, n) {
                const i = {}
                  , r = /^([\w-]*?)([\d]+)$/;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e]
                      , s = n.name.match(r);
                    if (s && s.length > 1) {
                        const t = s[1];
                        let e = i[t];
                        e || (i[t] = e = []),
                        e.push(n)
                    }
                }
                const s = [];
                for (const t in i)
                    s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                return s
            }
            static parseAnimation(t, e) {
                if (!t)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(t, e, n, i, r) {
                    if (0 !== n.length) {
                        const s = []
                          , o = [];
                        nm.flattenJSON(n, s, o, i),
                        0 !== s.length && r.push(new t(e,s,o))
                    }
                }
                  , i = []
                  , r = t.name || "default"
                  , s = t.fps || 30
                  , o = t.blendMode;
                let a = t.length || -1;
                const l = t.hierarchy || [];
                for (let t = 0; t < l.length; t++) {
                    const r = l[t].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const t = {};
                            let e;
                            for (e = 0; e < r.length; e++)
                                if (r[e].morphTargets)
                                    for (let n = 0; n < r[e].morphTargets.length; n++)
                                        t[r[e].morphTargets[n]] = -1;
                            for (const n in t) {
                                const t = []
                                  , s = [];
                                for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                    const i = r[e];
                                    t.push(i.time),
                                    s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new um(".morphTargetInfluence[" + n + "]",t,s))
                            }
                            a = t.length * (s || 1)
                        } else {
                            const s = ".bones[" + e[t].name + "]";
                            n(fm, s + ".position", r, "pos", i),
                            n(dm, s + ".quaternion", r, "rot", i),
                            n(fm, s + ".scale", r, "scl", i)
                        }
                }
                return 0 === i.length ? null : new this(r,a,i,o)
            }
            resetDuration() {
                let t = 0;
                for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                    const n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t,
                this
            }
            trim() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].trim(0, this.duration);
                return this
            }
            validate() {
                let t = !0;
                for (let e = 0; e < this.tracks.length; e++)
                    t = t && this.tracks[e].validate();
                return t
            }
            optimize() {
                for (let t = 0; t < this.tracks.length; t++)
                    this.tracks[t].optimize();
                return this
            }
            clone() {
                const t = [];
                for (let e = 0; e < this.tracks.length; e++)
                    t.push(this.tracks[e].clone());
                return new this.constructor(this.name,this.duration,t,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function gm(t) {
            if (void 0 === t.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const e = function(t) {
                switch (t.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return um;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return fm;
                case "color":
                    return cm;
                case "quaternion":
                    return dm;
                case "bool":
                case "boolean":
                    return lm;
                case "string":
                    return pm
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                const e = []
                  , n = [];
                nm.flattenJSON(t.keys, e, n, "value"),
                t.times = e,
                t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
        }
        const vm = {
            enabled: !1,
            files: {},
            add: function(t, e) {
                !1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (!1 !== this.enabled)
                    return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        };
        const ym = new class {
            constructor(t, e, n) {
                const i = this;
                let r, s = !1, o = 0, a = 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = t,
                this.onProgress = e,
                this.onError = n,
                this.itemStart = function(t) {
                    a++,
                    !1 === s && void 0 !== i.onStart && i.onStart(t, o, a),
                    s = !0
                }
                ,
                this.itemEnd = function(t) {
                    o++,
                    void 0 !== i.onProgress && i.onProgress(t, o, a),
                    o === a && (s = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }
                ,
                this.resolveURL = function(t) {
                    return r ? r(t) : t
                }
                ,
                this.setURLModifier = function(t) {
                    return r = t,
                    this
                }
                ,
                this.addHandler = function(t, e) {
                    return l.push(t, e),
                    this
                }
                ,
                this.removeHandler = function(t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2),
                    this
                }
                ,
                this.getHandler = function(t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e]
                          , i = l[e + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(t))
                            return i
                    }
                    return null
                }
            }
        }
        ;
        class xm {
            constructor(t) {
                this.manager = void 0 !== t ? t : ym,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(t, i, e, r)
                }
                ))
            }
            parse() {}
            setCrossOrigin(t) {
                return this.crossOrigin = t,
                this
            }
            setWithCredentials(t) {
                return this.withCredentials = t,
                this
            }
            setPath(t) {
                return this.path = t,
                this
            }
            setResourcePath(t) {
                return this.resourcePath = t,
                this
            }
            setRequestHeader(t) {
                return this.requestHeader = t,
                this
            }
        }
        const _m = {};
        class bm extends xm {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = vm.get(t);
                if (void 0 !== r)
                    return this.manager.itemStart(t),
                    setTimeout((()=>{
                        e && e(r),
                        this.manager.itemEnd(t)
                    }
                    ), 0),
                    r;
                if (void 0 !== _m[t])
                    return void _m[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                _m[t] = [],
                _m[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
                const s = new Request(t,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , o = this.mimeType
                  , a = this.responseType;
                fetch(s).then((e=>{
                    if (200 === e.status || 0 === e.status) {
                        if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" == typeof ReadableStream || void 0 === e.body.getReader)
                            return e;
                        const n = _m[t]
                          , i = e.body.getReader()
                          , r = e.headers.get("Content-Length")
                          , s = r ? parseInt(r) : 0
                          , o = 0 !== s;
                        let a = 0;
                        const l = new ReadableStream({
                            start(t) {
                                !function e() {
                                    i.read().then((({done: i, value: r})=>{
                                        if (i)
                                            t.close();
                                        else {
                                            a += r.byteLength;
                                            const i = new ProgressEvent("progress",{
                                                lengthComputable: o,
                                                loaded: a,
                                                total: s
                                            });
                                            for (let t = 0, e = n.length; t < e; t++) {
                                                const e = n[t];
                                                e.onProgress && e.onProgress(i)
                                            }
                                            t.enqueue(r),
                                            e()
                                        }
                                    }
                                    ))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
                }
                )).then((t=>{
                    switch (a) {
                    case "arraybuffer":
                        return t.arrayBuffer();
                    case "blob":
                        return t.blob();
                    case "document":
                        return t.text().then((t=>(new DOMParser).parseFromString(t, o)));
                    case "json":
                        return t.json();
                    default:
                        if (void 0 === o)
                            return t.text();
                        {
                            const e = /charset="?([^;"\s]*)"?/i.exec(o)
                              , n = e && e[1] ? e[1].toLowerCase() : void 0
                              , i = new TextDecoder(n);
                            return t.arrayBuffer().then((t=>i.decode(t)))
                        }
                    }
                }
                )).then((e=>{
                    vm.add(t, e);
                    const n = _m[t];
                    delete _m[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onLoad && i.onLoad(e)
                    }
                }
                )).catch((e=>{
                    const n = _m[t];
                    if (void 0 === n)
                        throw this.manager.itemError(t),
                        e;
                    delete _m[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    this.manager.itemError(t)
                }
                )).finally((()=>{
                    this.manager.itemEnd(t)
                }
                )),
                this.manager.itemStart(t)
            }
            setResponseType(t) {
                return this.responseType = t,
                this
            }
            setMimeType(t) {
                return this.mimeType = t,
                this
            }
        }
        class wm extends xm {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = vm.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const o = ka("img");
                function a() {
                    c(),
                    vm.add(t, this),
                    e && e(this),
                    r.manager.itemEnd(t)
                }
                function l(e) {
                    c(),
                    i && i(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                function c() {
                    o.removeEventListener("load", a, !1),
                    o.removeEventListener("error", l, !1)
                }
                return o.addEventListener("load", a, !1),
                o.addEventListener("error", l, !1),
                "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
                r.manager.itemStart(t),
                o.src = t,
                o
            }
        }
        class Mm extends xm {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new ru
                  , s = new wm(this.manager);
                s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path);
                let o = 0;
                function a(n) {
                    s.load(t[n], (function(t) {
                        r.images[n] = t,
                        o++,
                        6 === o && (r.needsUpdate = !0,
                        e && e(r))
                    }
                    ), void 0, i)
                }
                for (let e = 0; e < t.length; ++e)
                    a(e);
                return r
            }
        }
        class Sm extends xm {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = new Xa
                  , s = new wm(this.manager);
                return s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path),
                s.load(t, (function(t) {
                    r.image = t,
                    r.needsUpdate = !0,
                    void 0 !== e && e(r)
                }
                ), n, i),
                r
            }
        }
        class Tm extends ec {
            constructor(t, e=1) {
                super(),
                this.type = "Light",
                this.color = new Va(t),
                this.intensity = e
            }
            dispose() {}
            copy(t) {
                return super.copy(t),
                this.color.copy(t.color),
                this.intensity = t.intensity,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.color = this.color.getHex(),
                e.object.intensity = this.intensity,
                void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (e.object.distance = this.distance),
                void 0 !== this.angle && (e.object.angle = this.angle),
                void 0 !== this.decay && (e.object.decay = this.decay),
                void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                e
            }
        }
        Tm.prototype.isLight = !0;
        (class extends Tm {
            constructor(t, e, n) {
                super(t, n),
                this.type = "HemisphereLight",
                this.position.copy(ec.DefaultUp),
                this.updateMatrix(),
                this.groundColor = new Va(e)
            }
            copy(t) {
                return Tm.prototype.copy.call(this, t),
                this.groundColor.copy(t.groundColor),
                this
            }
        }
        ).prototype.isHemisphereLight = !0;
        const Em = new Ll
          , Am = new $a
          , Cm = new $a;
        class Rm {
            constructor(t) {
                this.camera = t,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new Ia(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Ll,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new du,
                this._frameExtents = new Ia(1,1),
                this._viewportCount = 1,
                this._viewports = [new Ja(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = this.matrix;
                Am.setFromMatrixPosition(t.matrixWorld),
                e.position.copy(Am),
                Cm.setFromMatrixPosition(t.target.matrixWorld),
                e.lookAt(Cm),
                e.updateMatrixWorld(),
                Em.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Em),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(e.projectionMatrix),
                n.multiply(e.matrixWorldInverse)
            }
            getViewport(t) {
                return this._viewports[t]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                0 !== this.normalBias && (t.normalBias = this.normalBias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                t.camera = this.camera.toJSON(!1).object,
                delete t.camera.matrix,
                t
            }
        }
        class Lm extends Rm {
            constructor() {
                super(new eu(50,1,.5,500)),
                this.focus = 1
            }
            updateMatrices(t) {
                const e = this.camera
                  , n = 2 * Sa * t.angle * this.focus
                  , i = this.mapSize.width / this.mapSize.height
                  , r = t.distance || e.far;
                n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
                e.aspect = i,
                e.far = r,
                e.updateProjectionMatrix()),
                super.updateMatrices(t)
            }
            copy(t) {
                return super.copy(t),
                this.focus = t.focus,
                this
            }
        }
        Lm.prototype.isSpotLightShadow = !0;
        class Pm extends Tm {
            constructor(t, e, n=0, i=Math.PI / 3, r=0, s=1) {
                super(t, e),
                this.type = "SpotLight",
                this.position.copy(ec.DefaultUp),
                this.updateMatrix(),
                this.target = new ec,
                this.distance = n,
                this.angle = i,
                this.penumbra = r,
                this.decay = s,
                this.shadow = new Lm
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.angle = t.angle,
                this.penumbra = t.penumbra,
                this.decay = t.decay,
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        Pm.prototype.isSpotLight = !0;
        const Dm = new Ll
          , Im = new $a
          , Om = new $a;
        class Nm extends Rm {
            constructor() {
                super(new eu(90,1,.5,500)),
                this._frameExtents = new Ia(4,2),
                this._viewportCount = 6,
                this._viewports = [new Ja(2,1,1,1), new Ja(0,1,1,1), new Ja(3,1,1,1), new Ja(1,1,1,1), new Ja(3,0,1,1), new Ja(1,0,1,1)],
                this._cubeDirections = [new $a(1,0,0), new $a(-1,0,0), new $a(0,0,1), new $a(0,0,-1), new $a(0,1,0), new $a(0,-1,0)],
                this._cubeUps = [new $a(0,1,0), new $a(0,1,0), new $a(0,1,0), new $a(0,1,0), new $a(0,0,1), new $a(0,0,-1)]
            }
            updateMatrices(t, e=0) {
                const n = this.camera
                  , i = this.matrix
                  , r = t.distance || n.far;
                r !== n.far && (n.far = r,
                n.updateProjectionMatrix()),
                Im.setFromMatrixPosition(t.matrixWorld),
                n.position.copy(Im),
                Om.copy(n.position),
                Om.add(this._cubeDirections[e]),
                n.up.copy(this._cubeUps[e]),
                n.lookAt(Om),
                n.updateMatrixWorld(),
                i.makeTranslation(-Im.x, -Im.y, -Im.z),
                Dm.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Dm)
            }
        }
        Nm.prototype.isPointLightShadow = !0;
        class km extends Tm {
            constructor(t, e, n=0, i=1) {
                super(t, e),
                this.type = "PointLight",
                this.distance = n,
                this.decay = i,
                this.shadow = new Nm
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(t) {
                this.intensity = t / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.distance = t.distance,
                this.decay = t.decay,
                this.shadow = t.shadow.clone(),
                this
            }
        }
        km.prototype.isPointLight = !0;
        class zm extends Rm {
            constructor() {
                super(new Tu(-5,5,5,-5,.5,500))
            }
        }
        zm.prototype.isDirectionalLightShadow = !0;
        class Hm extends Tm {
            constructor(t, e) {
                super(t, e),
                this.type = "DirectionalLight",
                this.position.copy(ec.DefaultUp),
                this.updateMatrix(),
                this.target = new ec,
                this.shadow = new zm
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(t) {
                return super.copy(t),
                this.target = t.target.clone(),
                this.shadow = t.shadow.clone(),
                this
            }
        }
        Hm.prototype.isDirectionalLight = !0;
        (class extends Tm {
            constructor(t, e) {
                super(t, e),
                this.type = "AmbientLight"
            }
        }
        ).prototype.isAmbientLight = !0;
        (class extends Tm {
            constructor(t, e, n=10, i=10) {
                super(t, e),
                this.type = "RectAreaLight",
                this.width = n,
                this.height = i
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(t) {
                this.intensity = t / (this.width * this.height * Math.PI)
            }
            copy(t) {
                return super.copy(t),
                this.width = t.width,
                this.height = t.height,
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.width = this.width,
                e.object.height = this.height,
                e
            }
        }
        ).prototype.isRectAreaLight = !0;
        class Bm {
            constructor() {
                this.coefficients = [];
                for (let t = 0; t < 9; t++)
                    this.coefficients.push(new $a)
            }
            set(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].copy(t[e]);
                return this
            }
            zero() {
                for (let t = 0; t < 9; t++)
                    this.coefficients[t].set(0, 0, 0);
                return this
            }
            getAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.282095),
                e.addScaledVector(s[1], .488603 * i),
                e.addScaledVector(s[2], .488603 * r),
                e.addScaledVector(s[3], .488603 * n),
                e.addScaledVector(s[4], n * i * 1.092548),
                e.addScaledVector(s[5], i * r * 1.092548),
                e.addScaledVector(s[6], .315392 * (3 * r * r - 1)),
                e.addScaledVector(s[7], n * r * 1.092548),
                e.addScaledVector(s[8], .546274 * (n * n - i * i)),
                e
            }
            getIrradianceAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z
                  , s = this.coefficients;
                return e.copy(s[0]).multiplyScalar(.886227),
                e.addScaledVector(s[1], 1.023328 * i),
                e.addScaledVector(s[2], 1.023328 * r),
                e.addScaledVector(s[3], 1.023328 * n),
                e.addScaledVector(s[4], .858086 * n * i),
                e.addScaledVector(s[5], .858086 * i * r),
                e.addScaledVector(s[6], .743125 * r * r - .247708),
                e.addScaledVector(s[7], .858086 * n * r),
                e.addScaledVector(s[8], .429043 * (n * n - i * i)),
                e
            }
            add(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].add(t.coefficients[e]);
                return this
            }
            addScaledSH(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].addScaledVector(t.coefficients[n], e);
                return this
            }
            scale(t) {
                for (let e = 0; e < 9; e++)
                    this.coefficients[e].multiplyScalar(t);
                return this
            }
            lerp(t, e) {
                for (let n = 0; n < 9; n++)
                    this.coefficients[n].lerp(t.coefficients[n], e);
                return this
            }
            equals(t) {
                for (let e = 0; e < 9; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e]))
                        return !1;
                return !0
            }
            copy(t) {
                return this.set(t.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(t, e=0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].fromArray(t, e + 3 * i);
                return this
            }
            toArray(t=[], e=0) {
                const n = this.coefficients;
                for (let i = 0; i < 9; i++)
                    n[i].toArray(t, e + 3 * i);
                return t
            }
            static getBasisAt(t, e) {
                const n = t.x
                  , i = t.y
                  , r = t.z;
                e[0] = .282095,
                e[1] = .488603 * i,
                e[2] = .488603 * r,
                e[3] = .488603 * n,
                e[4] = 1.092548 * n * i,
                e[5] = 1.092548 * i * r,
                e[6] = .315392 * (3 * r * r - 1),
                e[7] = 1.092548 * n * r,
                e[8] = .546274 * (n * n - i * i)
            }
        }
        Bm.prototype.isSphericalHarmonics3 = !0;
        class Fm extends Tm {
            constructor(t=new Bm, e=1) {
                super(void 0, e),
                this.sh = t
            }
            copy(t) {
                return super.copy(t),
                this.sh.copy(t.sh),
                this
            }
            fromJSON(t) {
                return this.intensity = t.intensity,
                this.sh.fromArray(t.sh),
                this
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.object.sh = this.sh.toArray(),
                e
            }
        }
        Fm.prototype.isLightProbe = !0;
        class Um {
            static decodeText(t) {
                if ("undefined" != typeof TextDecoder)
                    return (new TextDecoder).decode(t);
                let e = "";
                for (let n = 0, i = t.length; n < i; n++)
                    e += String.fromCharCode(t[n]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            }
            static extractUrlBase(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
            static resolveURL(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
            }
        }
        (class extends Rc {
            constructor() {
                super(),
                this.type = "InstancedBufferGeometry",
                this.instanceCount = 1 / 0
            }
            copy(t) {
                return super.copy(t),
                this.instanceCount = t.instanceCount,
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const t = super.toJSON(this);
                return t.instanceCount = this.instanceCount,
                t.isInstancedBufferGeometry = !0,
                t
            }
        }
        ).prototype.isInstancedBufferGeometry = !0;
        class Gm extends xm {
            constructor(t) {
                super(t),
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(t) {
                return this.options = t,
                this
            }
            load(t, e, n, i) {
                void 0 === t && (t = ""),
                void 0 !== this.path && (t = this.path + t),
                t = this.manager.resolveURL(t);
                const r = this
                  , s = vm.get(t);
                if (void 0 !== s)
                    return r.manager.itemStart(t),
                    setTimeout((function() {
                        e && e(s),
                        r.manager.itemEnd(t)
                    }
                    ), 0),
                    s;
                const o = {};
                o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                o.headers = this.requestHeader,
                fetch(t, o).then((function(t) {
                    return t.blob()
                }
                )).then((function(t) {
                    return createImageBitmap(t, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    vm.add(t, n),
                    e && e(n),
                    r.manager.itemEnd(t)
                }
                )).catch((function(e) {
                    i && i(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                )),
                r.manager.itemStart(t)
            }
        }
        let Vm;
        Gm.prototype.isImageBitmapLoader = !0;
        class Wm extends xm {
            constructor(t) {
                super(t)
            }
            load(t, e, n, i) {
                const r = this
                  , s = new bm(this.manager);
                s.setResponseType("arraybuffer"),
                s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(t, (function(n) {
                    try {
                        const t = n.slice(0);
                        (void 0 === Vm && (Vm = new (window.AudioContext || window.webkitAudioContext)),
                        Vm).decodeAudioData(t, (function(t) {
                            e(t)
                        }
                        ))
                    } catch (e) {
                        i ? i(e) : console.error(e),
                        r.manager.itemError(t)
                    }
                }
                ), n, i)
            }
        }
        (class extends Fm {
            constructor(t, e, n=1) {
                super(void 0, n);
                const i = (new Va).set(t)
                  , r = (new Va).set(e)
                  , s = new $a(i.r,i.g,i.b)
                  , o = new $a(r.r,r.g,r.b)
                  , a = Math.sqrt(Math.PI)
                  , l = a * Math.sqrt(.75);
                this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),
                this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
            }
        }
        ).prototype.isHemisphereLightProbe = !0,
        class extends Fm {
            constructor(t, e=1) {
                super(void 0, e);
                const n = (new Va).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
        }
        .prototype.isAmbientLightProbe = !0;
        class jm {
            constructor(t=!0) {
                this.autoStart = t,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            start() {
                this.startTime = qm(),
                this.oldTime = this.startTime,
                this.elapsedTime = 0,
                this.running = !0
            }
            stop() {
                this.getElapsedTime(),
                this.running = !1,
                this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(),
                this.elapsedTime
            }
            getDelta() {
                let t = 0;
                if (this.autoStart && !this.running)
                    return this.start(),
                    0;
                if (this.running) {
                    const e = qm();
                    t = (e - this.oldTime) / 1e3,
                    this.oldTime = e,
                    this.elapsedTime += t
                }
                return t
            }
        }
        function qm() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        class Xm {
            constructor(t, e, n) {
                let i, r, s;
                switch (this.binding = t,
                this.valueSize = n,
                e) {
                case "quaternion":
                    i = this._slerp,
                    r = this._slerpAdditive,
                    s = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * n),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    i = this._select,
                    r = this._select,
                    s = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * n);
                    break;
                default:
                    i = this._lerp,
                    r = this._lerpAdditive,
                    s = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i,
                this._mixBufferRegionAdditive = r,
                this._setIdentity = s,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(t, e) {
                const n = this.buffer
                  , i = this.valueSize
                  , r = t * i + i;
                let s = this.cumulativeWeight;
                if (0 === s) {
                    for (let t = 0; t !== i; ++t)
                        n[r + t] = n[t];
                    s = e
                } else {
                    s += e;
                    const t = e / s;
                    this._mixBufferRegion(n, r, 0, t, i)
                }
                this.cumulativeWeight = s
            }
            accumulateAdditive(t) {
                const e = this.buffer
                  , n = this.valueSize
                  , i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(),
                this._mixBufferRegionAdditive(e, i, 0, t, n),
                this.cumulativeWeightAdditive += t
            }
            apply(t) {
                const e = this.valueSize
                  , n = this.buffer
                  , i = t * e + e
                  , r = this.cumulativeWeight
                  , s = this.cumulativeWeightAdditive
                  , o = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                r < 1) {
                    const t = e * this._origIndex;
                    this._mixBufferRegion(n, i, t, 1 - r, e)
                }
                s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                for (let t = e, r = e + e; t !== r; ++t)
                    if (n[t] !== n[t + e]) {
                        o.setValue(n, i);
                        break
                    }
            }
            saveOriginalState() {
                const t = this.binding
                  , e = this.buffer
                  , n = this.valueSize
                  , i = n * this._origIndex;
                t.getValue(e, i);
                for (let t = n, r = i; t !== r; ++t)
                    e[t] = e[i + t % n];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }
            _setAdditiveIdentityNumeric() {
                const t = this._addIndex * this.valueSize
                  , e = t + this.valueSize;
                for (let n = t; n < e; n++)
                    this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const t = this._origIndex * this.valueSize
                  , e = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++)
                    this.buffer[e + n] = this.buffer[t + n]
            }
            _select(t, e, n, i, r) {
                if (i >= .5)
                    for (let i = 0; i !== r; ++i)
                        t[e + i] = t[n + i]
            }
            _slerp(t, e, n, i) {
                Qa.slerpFlat(t, e, t, e, t, n, i)
            }
            _slerpAdditive(t, e, n, i, r) {
                const s = this._workIndex * r;
                Qa.multiplyQuaternionsFlat(t, s, t, e, t, n),
                Qa.slerpFlat(t, e, t, e, t, s, i)
            }
            _lerp(t, e, n, i, r) {
                const s = 1 - i;
                for (let o = 0; o !== r; ++o) {
                    const r = e + o;
                    t[r] = t[r] * s + t[n + o] * i
                }
            }
            _lerpAdditive(t, e, n, i, r) {
                for (let s = 0; s !== r; ++s) {
                    const r = e + s;
                    t[r] = t[r] + t[n + s] * i
                }
            }
        }
        const Ym = new RegExp("[\\[\\]\\.:\\/]","g")
          , Jm = "[^\\[\\]\\.:\\/]"
          , Zm = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
          , Km = /((?:WC+[\/:])*)/.source.replace("WC", Jm)
          , Qm = /(WCOD+)?/.source.replace("WCOD", Zm)
          , $m = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Jm)
          , tg = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Jm)
          , eg = new RegExp("^" + Km + Qm + $m + tg + "$")
          , ng = ["material", "materials", "bones"];
        class ig {
            constructor(t, e, n) {
                this.path = e,
                this.parsedPath = n || ig.parseTrackName(e),
                this.node = ig.findNode(t, this.parsedPath.nodeName) || t,
                this.rootNode = t,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(t, e, n) {
                return t && t.isAnimationObjectGroup ? new ig.Composite(t,e,n) : new ig(t,e,n)
            }
            static sanitizeNodeName(t) {
                return t.replace(/\s/g, "_").replace(Ym, "")
            }
            static parseTrackName(t) {
                const e = eg.exec(t);
                if (!e)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                const n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }
                  , i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const t = n.nodeName.substring(i + 1);
                    -1 !== ng.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i),
                    n.objectName = t)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
            static findNode(t, e) {
                if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                    return t;
                if (t.skeleton) {
                    const n = t.skeleton.getBoneByName(e);
                    if (void 0 !== n)
                        return n
                }
                if (t.children) {
                    const n = function(t) {
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            if (r.name === e || r.uuid === e)
                                return r;
                            const s = n(r.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                      , i = n(t.children);
                    if (i)
                        return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(t, e) {
                t[e] = this.targetObject[this.propertyName]
            }
            _getValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    t[e++] = n[i]
            }
            _getValue_arrayElement(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(t, e) {
                this.resolvedProperty.toArray(t, e)
            }
            _setValue_direct(t, e) {
                this.targetObject[this.propertyName] = t[e]
            }
            _setValue_direct_setNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                this.targetObject[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++]
            }
            _setValue_array_setNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }
            _setValue_arrayElement_setNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(t, e) {
                this.resolvedProperty.fromArray(t, e)
            }
            _setValue_fromArray_setNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(t, e) {
                this.bind(),
                this.getValue(t, e)
            }
            _setValue_unbound(t, e) {
                this.bind(),
                this.setValue(t, e)
            }
            bind() {
                let t = this.node;
                const e = this.parsedPath
                  , n = e.objectName
                  , i = e.propertyName;
                let r = e.propertyIndex;
                if (t || (t = ig.findNode(this.rootNode, e.nodeName) || this.rootNode,
                this.node = t),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !t)
                    return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    let i = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === i) {
                                i = e;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === t[i])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[i]
                    }
                }
                const s = t[i];
                if (void 0 === s) {
                    const n = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                }
                let o = this.Versioning.None;
                this.targetObject = t,
                void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!t.geometry.isBufferGeometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                        if (!t.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                    }
                    a = this.BindingType.ArrayElement,
                    this.resolvedProperty = s,
                    this.propertyIndex = r
                } else
                    void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray,
                    this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray,
                    this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[a],
                this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        ig.Composite = class {
            constructor(t, e, n) {
                const i = n || ig.parseTrackName(e);
                this._targetGroup = t,
                this._bindings = t.subscribe_(e, i)
            }
            getValue(t, e) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }
            setValue(t, e) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(t, e)
            }
            bind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].bind()
            }
            unbind() {
                const t = this._bindings;
                for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                    t[e].unbind()
            }
        }
        ,
        ig.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        ig.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        ig.prototype.GetterByBindingType = [ig.prototype._getValue_direct, ig.prototype._getValue_array, ig.prototype._getValue_arrayElement, ig.prototype._getValue_toArray],
        ig.prototype.SetterByBindingTypeAndVersioning = [[ig.prototype._setValue_direct, ig.prototype._setValue_direct_setNeedsUpdate, ig.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [ig.prototype._setValue_array, ig.prototype._setValue_array_setNeedsUpdate, ig.prototype._setValue_array_setMatrixWorldNeedsUpdate], [ig.prototype._setValue_arrayElement, ig.prototype._setValue_arrayElement_setNeedsUpdate, ig.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [ig.prototype._setValue_fromArray, ig.prototype._setValue_fromArray_setNeedsUpdate, ig.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class rg {
            constructor(t, e, n=null, i=e.blendMode) {
                this._mixer = t,
                this._clip = e,
                this._localRoot = n,
                this.blendMode = i;
                const r = e.tracks
                  , s = r.length
                  , o = new Array(s)
                  , a = {
                    endingStart: ua,
                    endingEnd: ua
                };
                for (let t = 0; t !== s; ++t) {
                    const e = r[t].createInterpolant(null);
                    o[t] = e,
                    e.settings = a
                }
                this._interpolantSettings = a,
                this._interpolants = o,
                this._propertyBindings = new Array(s),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = 2201,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(t) {
                return this._startTime = t,
                this
            }
            setLoop(t, e) {
                return this.loop = t,
                this.repetitions = e,
                this
            }
            setEffectiveWeight(t) {
                return this.weight = t,
                this._effectiveWeight = this.enabled ? t : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(t) {
                return this._scheduleFading(t, 0, 1)
            }
            fadeOut(t) {
                return this._scheduleFading(t, 1, 0)
            }
            crossFadeFrom(t, e, n) {
                if (t.fadeOut(e),
                this.fadeIn(e),
                n) {
                    const n = this._clip.duration
                      , i = t._clip.duration
                      , r = i / n
                      , s = n / i;
                    t.warp(1, r, e),
                    this.warp(s, 1, e)
                }
                return this
            }
            crossFadeTo(t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }
            stopFading() {
                const t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            setEffectiveTimeScale(t) {
                return this.timeScale = t,
                this._effectiveTimeScale = this.paused ? 0 : t,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(t) {
                return this.timeScale = this._clip.duration / t,
                this.stopWarping()
            }
            syncWith(t) {
                return this.time = t.time,
                this.timeScale = t.timeScale,
                this.stopWarping()
            }
            halt(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }
            warp(t, e, n) {
                const i = this._mixer
                  , r = i.time
                  , s = this.timeScale;
                let o = this._timeScaleInterpolant;
                null === o && (o = i._lendControlInterpolant(),
                this._timeScaleInterpolant = o);
                const a = o.parameterPositions
                  , l = o.sampleValues;
                return a[0] = r,
                a[1] = r + n,
                l[0] = t / s,
                l[1] = e / s,
                this
            }
            stopWarping() {
                const t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(t)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(t, e, n, i) {
                if (!this.enabled)
                    return void this._updateWeight(t);
                const r = this._startTime;
                if (null !== r) {
                    const i = (t - r) * n;
                    if (i < 0 || 0 === n)
                        return;
                    this._startTime = null,
                    e = n * i
                }
                e *= this._updateTimeScale(t);
                const s = this._updateTime(e)
                  , o = this._updateWeight(t);
                if (o > 0) {
                    const t = this._interpolants
                      , e = this._propertyBindings;
                    switch (this.blendMode) {
                    case 2501:
                        for (let n = 0, i = t.length; n !== i; ++n)
                            t[n].evaluate(s),
                            e[n].accumulateAdditive(o);
                        break;
                    case 2500:
                    default:
                        for (let n = 0, r = t.length; n !== r; ++n)
                            t[n].evaluate(s),
                            e[n].accumulate(i, o)
                    }
                }
            }
            _updateWeight(t) {
                let e = 0;
                if (this.enabled) {
                    e = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(t)[0];
                        e *= i,
                        t > n.parameterPositions[1] && (this.stopFading(),
                        0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e,
                e
            }
            _updateTimeScale(t) {
                let e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    null !== n && (e *= n.evaluate(t)[0],
                    t > n.parameterPositions[1] && (this.stopWarping(),
                    0 === e ? this.paused = !0 : this.timeScale = e))
                }
                return this._effectiveTimeScale = e,
                e
            }
            _updateTime(t) {
                const e = this._clip.duration
                  , n = this.loop;
                let i = this.time + t
                  , r = this._loopCount;
                const s = 2202 === n;
                if (0 === t)
                    return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                if (2200 === n) {
                    -1 === r && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    t: {
                        if (i >= e)
                            i = e;
                        else {
                            if (!(i < 0)) {
                                this.time = i;
                                break t
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (t >= 0 ? (r = 0,
                    this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                    i >= e || i < 0) {
                        const n = Math.floor(i / e);
                        i -= e * n,
                        r += Math.abs(n);
                        const o = this.repetitions - r;
                        if (o <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            i = t > 0 ? e : 0,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                        else {
                            if (1 === o) {
                                const e = t < 0;
                                this._setEndings(e, !e, s)
                            } else
                                this._setEndings(!1, !1, s);
                            this._loopCount = r,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else
                        this.time = i;
                    if (s && 1 == (1 & r))
                        return e - i
                }
                return i
            }
            _setEndings(t, e, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = ha,
                i.endingEnd = ha) : (i.endingStart = t ? this.zeroSlopeAtStart ? ha : ua : da,
                i.endingEnd = e ? this.zeroSlopeAtEnd ? ha : ua : da)
            }
            _scheduleFading(t, e, n) {
                const i = this._mixer
                  , r = i.time;
                let s = this._weightInterpolant;
                null === s && (s = i._lendControlInterpolant(),
                this._weightInterpolant = s);
                const o = s.parameterPositions
                  , a = s.sampleValues;
                return o[0] = r,
                a[0] = e,
                o[1] = r + t,
                a[1] = n,
                this
            }
        }
        (class extends _a {
            constructor(t) {
                super(),
                this._root = t,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(t, e) {
                const n = t._localRoot || this._root
                  , i = t._clip.tracks
                  , r = i.length
                  , s = t._propertyBindings
                  , o = t._interpolants
                  , a = n.uuid
                  , l = this._bindingsByRootAndName;
                let c = l[a];
                void 0 === c && (c = {},
                l[a] = c);
                for (let t = 0; t !== r; ++t) {
                    const r = i[t]
                      , l = r.name;
                    let u = c[l];
                    if (void 0 !== u)
                        ++u.referenceCount,
                        s[t] = u;
                    else {
                        if (u = s[t],
                        void 0 !== u) {
                            null === u._cacheIndex && (++u.referenceCount,
                            this._addInactiveBinding(u, a, l));
                            continue
                        }
                        const i = e && e._propertyBindings[t].binding.parsedPath;
                        u = new Xm(ig.create(n, l, i),r.ValueTypeName,r.getValueSize()),
                        ++u.referenceCount,
                        this._addInactiveBinding(u, a, l),
                        s[t] = u
                    }
                    o[t].resultBuffer = u.buffer
                }
            }
            _activateAction(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        const e = (t._localRoot || this._root).uuid
                          , n = t._clip.uuid
                          , i = this._actionsByClip[n];
                        this._bindAction(t, i && i.knownActions[0]),
                        this._addInactiveAction(t, n, e)
                    }
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == n.useCount++ && (this._lendBinding(n),
                        n.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }
            _deactivateAction(t) {
                if (this._isActiveAction(t)) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.useCount && (n.restoreOriginalState(),
                        this._takeBackBinding(n))
                    }
                    this._takeBackAction(t)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(t) {
                const e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }
            _addInactiveAction(t, e, n) {
                const i = this._actions
                  , r = this._actionsByClip;
                let s = r[e];
                if (void 0 === s)
                    s = {
                        knownActions: [t],
                        actionByRoot: {}
                    },
                    t._byClipCacheIndex = 0,
                    r[e] = s;
                else {
                    const e = s.knownActions;
                    t._byClipCacheIndex = e.length,
                    e.push(t)
                }
                t._cacheIndex = i.length,
                i.push(t),
                s.actionByRoot[n] = t
            }
            _removeInactiveAction(t) {
                const e = this._actions
                  , n = e[e.length - 1]
                  , i = t._cacheIndex;
                n._cacheIndex = i,
                e[i] = n,
                e.pop(),
                t._cacheIndex = null;
                const r = t._clip.uuid
                  , s = this._actionsByClip
                  , o = s[r]
                  , a = o.knownActions
                  , l = a[a.length - 1]
                  , c = t._byClipCacheIndex;
                l._byClipCacheIndex = c,
                a[c] = l,
                a.pop(),
                t._byClipCacheIndex = null,
                delete o.actionByRoot[(t._localRoot || this._root).uuid],
                0 === a.length && delete s[r],
                this._removeInactiveBindingsForAction(t)
            }
            _removeInactiveBindingsForAction(t) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            }
            _lendAction(t) {
                const e = this._actions
                  , n = t._cacheIndex
                  , i = this._nActiveActions++
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _takeBackAction(t) {
                const e = this._actions
                  , n = t._cacheIndex
                  , i = --this._nActiveActions
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _addInactiveBinding(t, e, n) {
                const i = this._bindingsByRootAndName
                  , r = this._bindings;
                let s = i[e];
                void 0 === s && (s = {},
                i[e] = s),
                s[n] = t,
                t._cacheIndex = r.length,
                r.push(t)
            }
            _removeInactiveBinding(t) {
                const e = this._bindings
                  , n = t.binding
                  , i = n.rootNode.uuid
                  , r = n.path
                  , s = this._bindingsByRootAndName
                  , o = s[i]
                  , a = e[e.length - 1]
                  , l = t._cacheIndex;
                a._cacheIndex = l,
                e[l] = a,
                e.pop(),
                delete o[r],
                0 === Object.keys(o).length && delete s[i]
            }
            _lendBinding(t) {
                const e = this._bindings
                  , n = t._cacheIndex
                  , i = this._nActiveBindings++
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _takeBackBinding(t) {
                const e = this._bindings
                  , n = t._cacheIndex
                  , i = --this._nActiveBindings
                  , r = e[i];
                t._cacheIndex = i,
                e[i] = t,
                r._cacheIndex = n,
                e[n] = r
            }
            _lendControlInterpolant() {
                const t = this._controlInterpolants
                  , e = this._nActiveControlInterpolants++;
                let n = t[e];
                return void 0 === n && (n = new sm(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                n.__cacheIndex = e,
                t[e] = n),
                n
            }
            _takeBackControlInterpolant(t) {
                const e = this._controlInterpolants
                  , n = t.__cacheIndex
                  , i = --this._nActiveControlInterpolants
                  , r = e[i];
                t.__cacheIndex = i,
                e[i] = t,
                r.__cacheIndex = n,
                e[n] = r
            }
            clipAction(t, e, n) {
                const i = e || this._root
                  , r = i.uuid;
                let s = "string" == typeof t ? mm.findByName(i, t) : t;
                const o = null !== s ? s.uuid : t
                  , a = this._actionsByClip[o];
                let l = null;
                if (void 0 === n && (n = null !== s ? s.blendMode : 2500),
                void 0 !== a) {
                    const t = a.actionByRoot[r];
                    if (void 0 !== t && t.blendMode === n)
                        return t;
                    l = a.knownActions[0],
                    null === s && (s = l._clip)
                }
                if (null === s)
                    return null;
                const c = new rg(this,s,e,n);
                return this._bindAction(c, l),
                this._addInactiveAction(c, o, r),
                c
            }
            existingAction(t, e) {
                const n = e || this._root
                  , i = n.uuid
                  , r = "string" == typeof t ? mm.findByName(n, t) : t
                  , s = r ? r.uuid : t
                  , o = this._actionsByClip[s];
                return void 0 !== o && o.actionByRoot[i] || null
            }
            stopAllAction() {
                const t = this._actions;
                for (let e = this._nActiveActions - 1; e >= 0; --e)
                    t[e].stop();
                return this
            }
            update(t) {
                t *= this.timeScale;
                const e = this._actions
                  , n = this._nActiveActions
                  , i = this.time += t
                  , r = Math.sign(t)
                  , s = this._accuIndex ^= 1;
                for (let o = 0; o !== n; ++o)
                    e[o]._update(i, t, r, s);
                const o = this._bindings
                  , a = this._nActiveBindings;
                for (let t = 0; t !== a; ++t)
                    o[t].apply(s);
                return this
            }
            setTime(t) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++)
                    this._actions[t].time = 0;
                return this.update(t)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(t) {
                const e = this._actions
                  , n = t.uuid
                  , i = this._actionsByClip
                  , r = i[n];
                if (void 0 !== r) {
                    const t = r.knownActions;
                    for (let n = 0, i = t.length; n !== i; ++n) {
                        const i = t[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex
                          , s = e[e.length - 1];
                        i._cacheIndex = null,
                        i._byClipCacheIndex = null,
                        s._cacheIndex = r,
                        e[r] = s,
                        e.pop(),
                        this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            }
            uncacheRoot(t) {
                const e = t.uuid
                  , n = this._actionsByClip;
                for (const t in n) {
                    const i = n[t].actionByRoot[e];
                    void 0 !== i && (this._deactivateAction(i),
                    this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName[e];
                if (void 0 !== i)
                    for (const t in i) {
                        const e = i[t];
                        e.restoreOriginalState(),
                        this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(t, e) {
                const n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
        }
        ).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class sg {
            constructor(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                t = arguments[1]),
                this.value = t
            }
            clone() {
                return new sg(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        (class extends ip {
            constructor(t, e, n=1) {
                super(t, e),
                this.meshPerAttribute = n
            }
            copy(t) {
                return super.copy(t),
                this.meshPerAttribute = t.meshPerAttribute,
                this
            }
            clone(t) {
                const e = super.clone(t);
                return e.meshPerAttribute = this.meshPerAttribute,
                e
            }
            toJSON(t) {
                const e = super.toJSON(t);
                return e.isInstancedInterleavedBuffer = !0,
                e.meshPerAttribute = this.meshPerAttribute,
                e
            }
        }
        ).prototype.isInstancedInterleavedBuffer = !0;
        const og = new Ia;
        class ag {
            constructor(t=new Ia(1 / 0,1 / 0), e=new Ia(-1 / 0,-1 / 0)) {
                this.min = t,
                this.max = e
            }
            set(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            }
            setFromPoints(t) {
                this.makeEmpty();
                for (let e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e]);
                return this
            }
            setFromCenterAndSize(t, e) {
                const n = og.copy(e).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(t) {
                return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(t) {
                return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            }
            expandByPoint(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            }
            expandByVector(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            }
            expandByScalar(t) {
                return this.min.addScalar(-t),
                this.max.addScalar(t),
                this
            }
            containsPoint(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }
            containsBox(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }
            getParameter(t, e) {
                return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }
            clampPoint(t, e) {
                return e.copy(t).clamp(this.min, this.max)
            }
            distanceToPoint(t) {
                return og.copy(t).clamp(this.min, this.max).sub(t).length()
            }
            intersect(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this
            }
            union(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            }
            translate(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            }
            equals(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }
        ag.prototype.isBox2 = !0;
        const lg = new $a
          , cg = new Ll
          , ug = new Ll;
        function hg(t) {
            const e = [];
            t && t.isBone && e.push(t);
            for (let n = 0; n < t.children.length; n++)
                e.push.apply(e, hg(t.children[n]));
            return e
        }
        const dg = new Float32Array(1);
        new Int32Array(dg.buffer),
        ef.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"),
            t.prototype = Object.create(ef.prototype),
            t.prototype.constructor = t,
            t.prototype.getPoint = e,
            t
        }
        ,
        wf.prototype.fromPoints = function(t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(t)
        }
        ,
        class extends qp {
            constructor(t=10, e=10, n=4473924, i=8947848) {
                n = new Va(n),
                i = new Va(i);
                const r = e / 2
                  , s = t / e
                  , o = t / 2
                  , a = []
                  , l = [];
                for (let t = 0, c = 0, u = -o; t <= e; t++,
                u += s) {
                    a.push(-o, 0, u, o, 0, u),
                    a.push(u, 0, -o, u, 0, o);
                    const e = t === r ? n : i;
                    e.toArray(l, c),
                    c += 3,
                    e.toArray(l, c),
                    c += 3,
                    e.toArray(l, c),
                    c += 3,
                    e.toArray(l, c),
                    c += 3
                }
                const c = new Rc;
                c.setAttribute("position", new bc(a,3)),
                c.setAttribute("color", new bc(l,3)),
                super(c, new zp({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "GridHelper"
            }
        }
        .prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }
        ,
        class extends qp {
            constructor(t) {
                const e = hg(t)
                  , n = new Rc
                  , i = []
                  , r = []
                  , s = new Va(0,0,1)
                  , o = new Va(0,1,0);
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    n.parent && n.parent.isBone && (i.push(0, 0, 0),
                    i.push(0, 0, 0),
                    r.push(s.r, s.g, s.b),
                    r.push(o.r, o.g, o.b))
                }
                n.setAttribute("position", new bc(i,3)),
                n.setAttribute("color", new bc(r,3)),
                super(n, new zp({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })),
                this.type = "SkeletonHelper",
                this.isSkeletonHelper = !0,
                this.root = t,
                this.bones = e,
                this.matrix = t.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(t) {
                const e = this.bones
                  , n = this.geometry
                  , i = n.getAttribute("position");
                ug.copy(this.root.matrixWorld).invert();
                for (let t = 0, n = 0; t < e.length; t++) {
                    const r = e[t];
                    r.parent && r.parent.isBone && (cg.multiplyMatrices(ug, r.matrixWorld),
                    lg.setFromMatrixPosition(cg),
                    i.setXYZ(n, lg.x, lg.y, lg.z),
                    cg.multiplyMatrices(ug, r.parent.matrixWorld),
                    lg.setFromMatrixPosition(cg),
                    i.setXYZ(n + 1, lg.x, lg.y, lg.z),
                    n += 2)
                }
                n.getAttribute("position").needsUpdate = !0,
                super.updateMatrixWorld(t)
            }
        }
        .prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }
        ,
        xm.prototype.extractUrlBase = function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            Um.extractUrlBase(t)
        }
        ,
        xm.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        },
        ag.prototype.center = function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        }
        ,
        ag.prototype.empty = function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        ag.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        ag.prototype.size = function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
        ,
        nl.prototype.center = function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        }
        ,
        nl.prototype.empty = function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        nl.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        nl.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
        ,
        nl.prototype.size = function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
        ,
        bl.prototype.empty = function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
        ,
        du.prototype.setFromMatrix = function(t) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
            this.setFromProjectionMatrix(t)
        }
        ,
        Oa.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        }
        ,
        Oa.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        }
        ,
        Oa.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }
        ,
        Oa.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        }
        ,
        Oa.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
        ,
        Oa.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
        ,
        Ll.prototype.extractPosition = function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(t)
        }
        ,
        Ll.prototype.flattenToArrayOffset = function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        }
        ,
        Ll.prototype.getPosition = function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            (new $a).setFromMatrixColumn(this, 3)
        }
        ,
        Ll.prototype.setRotationFromQuaternion = function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(t)
        }
        ,
        Ll.prototype.multiplyToArray = function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }
        ,
        Ll.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Ll.prototype.multiplyVector4 = function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Ll.prototype.multiplyVector3Array = function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }
        ,
        Ll.prototype.rotateAxis = function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            t.transformDirection(this)
        }
        ,
        Ll.prototype.crossVector = function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Ll.prototype.translate = function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }
        ,
        Ll.prototype.rotateX = function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }
        ,
        Ll.prototype.rotateY = function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }
        ,
        Ll.prototype.rotateZ = function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }
        ,
        Ll.prototype.rotateByAxis = function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }
        ,
        Ll.prototype.applyToBufferAttribute = function(t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        }
        ,
        Ll.prototype.applyToVector3Array = function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }
        ,
        Ll.prototype.makeFrustum = function(t, e, n, i, r, s) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(t, e, i, n, r, s)
        }
        ,
        Ll.prototype.getInverse = function(t) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
        ,
        cu.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
            this.intersectsLine(t)
        }
        ,
        Qa.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
            t.applyQuaternion(this)
        }
        ,
        Qa.prototype.inverse = function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
            this.invert()
        }
        ,
        Rl.prototype.isIntersectionBox = function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        }
        ,
        Rl.prototype.isIntersectionPlane = function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(t)
        }
        ,
        Rl.prototype.isIntersectionSphere = function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
        ,
        dc.prototype.area = function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        }
        ,
        dc.prototype.barycoordFromPoint = function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(t, e)
        }
        ,
        dc.prototype.midpoint = function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(t)
        }
        ,
        dc.prototypenormal = function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(t)
        }
        ,
        dc.prototype.plane = function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(t)
        }
        ,
        dc.barycoordFromPoint = function(t, e, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            dc.getBarycoord(t, e, n, i, r)
        }
        ,
        dc.normal = function(t, e, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            dc.getNormal(t, e, n, i)
        }
        ,
        Mf.prototype.extractAllPoints = function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(t)
        }
        ,
        Mf.prototype.extrude = function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new Kf(this,t)
        }
        ,
        Mf.prototype.makeGeometry = function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new $f(this,t)
        }
        ,
        Ia.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        }
        ,
        Ia.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        }
        ,
        Ia.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        $a.prototype.setEulerFromRotationMatrix = function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }
        ,
        $a.prototype.setEulerFromQuaternion = function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }
        ,
        $a.prototype.getPositionFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(t)
        }
        ,
        $a.prototype.getScaleFromMatrix = function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(t)
        }
        ,
        $a.prototype.getColumnFromMatrix = function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(e, t)
        }
        ,
        $a.prototype.applyProjection = function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(t)
        }
        ,
        $a.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        }
        ,
        $a.prototype.distanceToManhattan = function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        }
        ,
        $a.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        Ja.prototype.fromAttribute = function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        }
        ,
        Ja.prototype.lengthManhattan = function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
        ,
        ec.prototype.getChildByName = function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(t)
        }
        ,
        ec.prototype.renderDepth = function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }
        ,
        ec.prototype.translate = function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(e, t)
        }
        ,
        ec.prototype.getWorldRotation = function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
        ,
        ec.prototype.applyMatrix = function(t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
        ,
        Object.defineProperties(ec.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                    this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }),
        Xc.prototype.setDrawMode = function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
        ,
        Object.defineProperties(Xc.prototype, {
            drawMode: {
                get: function() {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                    0
                },
                set: function() {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }),
        Ep.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }
        ,
        eu.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
            void 0 !== e && (this.filmGauge = e),
            this.setFocalLength(t)
        }
        ,
        Object.defineProperties(Tm.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                    this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                    this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                    this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                    this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                    this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                    this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                    this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                    this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                    this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                    this.shadow.mapSize.height = t
                }
            }
        }),
        Object.defineProperties(yc.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                    this.array.length
                }
            },
            dynamic: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                    this.usage === va
                },
                set: function() {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                    this.setUsage(va)
                }
            }
        }),
        yc.prototype.setDynamic = function(t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? va : ga),
            this
        }
        ,
        yc.prototype.copyIndicesArray = function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
        ,
        yc.prototype.setArray = function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
        ,
        Rc.prototype.addIndex = function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(t)
        }
        ,
        Rc.prototype.addAttribute = function(t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
            e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(e),
            this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.setAttribute(t, new yc(arguments[1],arguments[2])))
        }
        ,
        Rc.prototype.addDrawCall = function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(t, e)
        }
        ,
        Rc.prototype.clearDrawCalls = function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        }
        ,
        Rc.prototype.computeOffsets = function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
        ,
        Rc.prototype.removeAttribute = function(t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
            this.deleteAttribute(t)
        }
        ,
        Rc.prototype.applyMatrix = function(t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
        ,
        Object.defineProperties(Rc.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                    this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                    this.groups
                }
            }
        }),
        ip.prototype.setDynamic = function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? va : ga),
            this
        }
        ,
        ip.prototype.setArray = function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
        ,
        Kf.prototype.getArrays = function() {
            console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
        }
        ,
        Kf.prototype.addShapeList = function() {
            console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
        }
        ,
        Kf.prototype.addShape = function() {
            console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
        }
        ,
        np.prototype.dispose = function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }
        ,
        sg.prototype.onUpdate = function() {
            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
            this
        }
        ,
        Object.defineProperties(fc.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."),
                    new Va
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                    this.stencilFuncMask
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                    this.stencilFuncMask = t
                }
            },
            vertexTangents: {
                get: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                },
                set: function() {
                    console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                }
            }
        }),
        Object.defineProperties($c.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                    this.extensions.derivatives = t
                }
            }
        }),
        $d.prototype.clearTarget = function(t, e, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(t),
            this.clear(e, n, i)
        }
        ,
        $d.prototype.animate = function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(t)
        }
        ,
        $d.prototype.getCurrentRenderTarget = function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        }
        ,
        $d.prototype.getMaxAnisotropy = function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        }
        ,
        $d.prototype.getPrecision = function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        }
        ,
        $d.prototype.resetGLState = function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        }
        ,
        $d.prototype.supportsFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        }
        ,
        $d.prototype.supportsHalfFloatTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        }
        ,
        $d.prototype.supportsStandardDerivatives = function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        }
        ,
        $d.prototype.supportsCompressedTextureS3TC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        }
        ,
        $d.prototype.supportsCompressedTexturePVRTC = function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }
        ,
        $d.prototype.supportsBlendMinMax = function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        }
        ,
        $d.prototype.supportsVertexTextures = function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        }
        ,
        $d.prototype.supportsInstancedArrays = function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        }
        ,
        $d.prototype.enableScissorTest = function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(t)
        }
        ,
        $d.prototype.initMaterial = function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }
        ,
        $d.prototype.addPrePlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }
        ,
        $d.prototype.addPostPlugin = function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }
        ,
        $d.prototype.updateShadowMap = function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
        ,
        $d.prototype.setFaceCulling = function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
        ,
        $d.prototype.allocTextureUnit = function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        }
        ,
        $d.prototype.setTexture = function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        }
        ,
        $d.prototype.setTexture2D = function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        }
        ,
        $d.prototype.setTextureCube = function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        }
        ,
        $d.prototype.getActiveMipMapLevel = function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
            this.getActiveMipmapLevel()
        }
        ,
        Object.defineProperties($d.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                    this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                    this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                    this.getContext()
                }
            },
            vr: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                    this.xr
                }
            },
            gammaInput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                    !1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                    !1
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                    this.outputEncoding = !0 === t ? fa : pa
                }
            },
            toneMappingWhitePoint: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                    1
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                }
            },
            gammaFactor: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
                    2
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                }
            }
        }),
        Object.defineProperties(Gd.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }),
        Object.defineProperties(Za.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                    this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                    this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                    this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                    this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                    this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                    this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                    this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                    this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                    this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                    this.texture.generateMipmaps = t
                }
            }
        }),
        class extends ec {
            constructor(t) {
                super(),
                this.type = "Audio",
                this.listener = t,
                this.context = t.context,
                this.gain = this.context.createGain(),
                this.gain.connect(t.getInput()),
                this.autoplay = !1,
                this.buffer = null,
                this.detune = 0,
                this.loop = !1,
                this.loopStart = 0,
                this.loopEnd = 0,
                this.offset = 0,
                this.duration = void 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.source = null,
                this.sourceType = "empty",
                this._startedAt = 0,
                this._progress = 0,
                this._connected = !1,
                this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "audioNode",
                this.source = t,
                this.connect(),
                this
            }
            setMediaElementSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaNode",
                this.source = this.context.createMediaElementSource(t),
                this.connect(),
                this
            }
            setMediaStreamSource(t) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaStreamNode",
                this.source = this.context.createMediaStreamSource(t),
                this.connect(),
                this
            }
            setBuffer(t) {
                return this.buffer = t,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            }
            play(t=0) {
                if (!0 === this.isPlaying)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + t;
                const e = this.context.createBufferSource();
                return e.buffer = this.buffer,
                e.loop = this.loop,
                e.loopStart = this.loopStart,
                e.loopEnd = this.loopEnd,
                e.onended = this.onEnded.bind(this),
                e.start(this._startedAt, this._progress + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = e,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl)
                    return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                    !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl)
                    return this._progress = 0,
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1,
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                this
            }
            disconnect() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (let t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else
                    this.source.disconnect(this.getOutput());
                return this._connected = !1,
                this
            }
            getFilters() {
                return this.filters
            }
            setFilters(t) {
                return t || (t = []),
                !0 === this._connected ? (this.disconnect(),
                this.filters = t.slice(),
                this.connect()) : this.filters = t.slice(),
                this
            }
            setDetune(t) {
                if (this.detune = t,
                void 0 !== this.source.detune)
                    return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                    this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(t) {
                return this.setFilters(t ? [t] : [])
            }
            setPlaybackRate(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.playbackRate = t,
                    !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
                !1) : this.loop
            }
            setLoop(t) {
                if (!1 !== this.hasPlaybackControl)
                    return this.loop = t,
                    !0 === this.isPlaying && (this.source.loop = this.loop),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(t) {
                return this.loopStart = t,
                this
            }
            setLoopEnd(t) {
                return this.loopEnd = t,
                this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
                this
            }
        }
        .prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            const e = this;
            return (new Wm).load(t, (function(t) {
                e.setBuffer(t)
            }
            )),
            this
        }
        ,
        iu.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
            this.update(t, e)
        }
        ,
        iu.prototype.clear = function(t, e, n, i) {
            return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
            this.renderTarget.clear(t, e, n, i)
        }
        ,
        ja.crossOrigin = void 0,
        ja.loadTexture = function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            const r = new Sm;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e),
            s
        }
        ,
        ja.loadTextureCube = function(t, e, n, i) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            const r = new Mm;
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e),
            s
        }
        ,
        ja.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }
        ,
        ja.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: "137"
            }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "137");
        class pg extends xm {
            constructor(t) {
                super(t),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(t) {
                    return new yg(t)
                }
                )),
                this.register((function(t) {
                    return new Sg(t)
                }
                )),
                this.register((function(t) {
                    return new Tg(t)
                }
                )),
                this.register((function(t) {
                    return new xg(t)
                }
                )),
                this.register((function(t) {
                    return new _g(t)
                }
                )),
                this.register((function(t) {
                    return new bg(t)
                }
                )),
                this.register((function(t) {
                    return new wg(t)
                }
                )),
                this.register((function(t) {
                    return new Mg(t)
                }
                )),
                this.register((function(t) {
                    return new gg(t)
                }
                )),
                this.register((function(t) {
                    return new Eg(t)
                }
                ))
            }
            load(t, e, n, i) {
                const r = this;
                let s;
                s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Um.extractUrlBase(t),
                this.manager.itemStart(t);
                const o = function(e) {
                    i ? i(e) : console.error(e),
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                  , a = new bm(this.manager);
                a.setPath(this.path),
                a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(t, (function(n) {
                    try {
                        r.parse(n, s, (function(n) {
                            e(n),
                            r.manager.itemEnd(t)
                        }
                        ), o)
                    } catch (t) {
                        o(t)
                    }
                }
                ), n, o)
            }
            setDRACOLoader(t) {
                return this.dracoLoader = t,
                this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(t) {
                return this.ktx2Loader = t,
                this
            }
            setMeshoptDecoder(t) {
                return this.meshoptDecoder = t,
                this
            }
            register(t) {
                return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t),
                this
            }
            unregister(t) {
                return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
                this
            }
            parse(t, e, n, i) {
                let r;
                const s = {}
                  , o = {};
                if ("string" == typeof t)
                    r = t;
                else if (Um.decodeText(new Uint8Array(t,0,4)) === Ag) {
                    try {
                        s[mg.KHR_BINARY_GLTF] = new Cg(t)
                    } catch (t) {
                        return void (i && i(t))
                    }
                    r = s[mg.KHR_BINARY_GLTF].content
                } else
                    r = Um.decodeText(new Uint8Array(t));
                const a = JSON.parse(r);
                if (void 0 === a.asset || a.asset.version[0] < 2)
                    return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new Zg(a,{
                    path: e || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let t = 0; t < this.pluginCallbacks.length; t++) {
                    const e = this.pluginCallbacks[t](l);
                    o[e.name] = e,
                    s[e.name] = !0
                }
                if (a.extensionsUsed)
                    for (let t = 0; t < a.extensionsUsed.length; ++t) {
                        const e = a.extensionsUsed[t]
                          , n = a.extensionsRequired || [];
                        switch (e) {
                        case mg.KHR_MATERIALS_UNLIT:
                            s[e] = new vg;
                            break;
                        case mg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            s[e] = new Dg;
                            break;
                        case mg.KHR_DRACO_MESH_COMPRESSION:
                            s[e] = new Rg(a,this.dracoLoader);
                            break;
                        case mg.KHR_TEXTURE_TRANSFORM:
                            s[e] = new Lg;
                            break;
                        case mg.KHR_MESH_QUANTIZATION:
                            s[e] = new Ig;
                            break;
                        default:
                            n.indexOf(e) >= 0 && void 0 === o[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                l.setExtensions(s),
                l.setPlugins(o),
                l.parse(n, i)
            }
            parseAsync(t, e) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(t, e, i, r)
                }
                ))
            }
        }
        function fg() {
            let t = {};
            return {
                get: function(e) {
                    return t[e]
                },
                add: function(e, n) {
                    t[e] = n
                },
                remove: function(e) {
                    delete t[e]
                },
                removeAll: function() {
                    t = {}
                }
            }
        }
        const mg = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
        };
        class gg {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const t = this.parser
                  , e = this.parser.json.nodes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && t._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(t) {
                const e = this.parser
                  , n = "light:" + t;
                let i = e.cache.get(n);
                if (i)
                    return i;
                const r = e.json
                  , s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[t];
                let o;
                const a = new Va(16777215);
                void 0 !== s.color && a.fromArray(s.color);
                const l = void 0 !== s.range ? s.range : 0;
                switch (s.type) {
                case "directional":
                    o = new Hm(a),
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                case "point":
                    o = new km(a),
                    o.distance = l;
                    break;
                case "spot":
                    o = new Pm(a),
                    o.distance = l,
                    s.spot = s.spot || {},
                    s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
                    s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
                    o.angle = s.spot.outerConeAngle,
                    o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                }
                return o.position.set(0, 0, 0),
                o.decay = 2,
                void 0 !== s.intensity && (o.intensity = s.intensity),
                o.name = e.createUniqueName(s.name || "light_" + t),
                i = Promise.resolve(o),
                e.cache.add(n, i),
                i
            }
            createNodeAttachment(t) {
                const e = this
                  , n = this.parser
                  , i = n.json.nodes[t]
                  , r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function(t) {
                    return n._getNodeRef(e.cache, r, t)
                }
                ))
            }
        }
        class vg {
            constructor() {
                this.name = mg.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return mc
            }
            extendParams(t, e, n) {
                const i = [];
                t.color = new Va(1,1,1),
                t.opacity = 1;
                const r = e.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const e = r.baseColorFactor;
                        t.color.fromArray(e),
                        t.opacity = e[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture))
                }
                return Promise.all(i)
            }
        }
        class yg {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? em : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor),
                void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)),
                void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor),
                void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
                void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)),
                void 0 !== s.clearcoatNormalTexture.scale)) {
                    const t = s.clearcoatNormalTexture.scale;
                    e.clearcoatNormalScale = new Ia(t,t)
                }
                return Promise.all(r)
            }
        }
        class xg {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_MATERIALS_SHEEN
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? em : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = [];
                e.sheenColor = new Va(0,0,0),
                e.sheenRoughness = 0,
                e.sheen = 1;
                const s = i.extensions[this.name];
                return void 0 !== s.sheenColorFactor && e.sheenColor.fromArray(s.sheenColorFactor),
                void 0 !== s.sheenRoughnessFactor && (e.sheenRoughness = s.sheenRoughnessFactor),
                void 0 !== s.sheenColorTexture && r.push(n.assignTexture(e, "sheenColorMap", s.sheenColorTexture)),
                void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(e, "sheenRoughnessMap", s.sheenRoughnessTexture)),
                Promise.all(r)
            }
        }
        class _g {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? em : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor),
                void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)),
                Promise.all(r)
            }
        }
        class bg {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_MATERIALS_VOLUME
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? em : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                e.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0,
                void 0 !== s.thicknessTexture && r.push(n.assignTexture(e, "thicknessMap", s.thicknessTexture)),
                e.attenuationDistance = s.attenuationDistance || 0;
                const o = s.attenuationColor || [1, 1, 1];
                return e.attenuationColor = new Va(o[0],o[1],o[2]),
                Promise.all(r)
            }
        }
        class wg {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_MATERIALS_IOR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? em : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser.json.materials[t];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return e.ior = void 0 !== i.ior ? i.ior : 1.5,
                Promise.resolve()
            }
        }
        class Mg {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(t) {
                const e = this.parser.json.materials[t];
                return e.extensions && e.extensions[this.name] ? em : null
            }
            extendMaterialParams(t, e) {
                const n = this.parser
                  , i = n.json.materials[t];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                e.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1,
                void 0 !== s.specularTexture && r.push(n.assignTexture(e, "specularIntensityMap", s.specularTexture));
                const o = s.specularColorFactor || [1, 1, 1];
                return e.specularColor = new Va(o[0],o[1],o[2]),
                void 0 !== s.specularColorTexture && r.push(n.assignTexture(e, "specularColorMap", s.specularColorTexture).then((function(t) {
                    t.encoding = fa
                }
                ))),
                Promise.all(r)
            }
        }
        class Sg {
            constructor(t) {
                this.parser = t,
                this.name = mg.KHR_TEXTURE_BASISU
            }
            loadTexture(t) {
                const e = this.parser
                  , n = e.json
                  , i = n.textures[t];
                if (!i.extensions || !i.extensions[this.name])
                    return null;
                const r = i.extensions[this.name]
                  , s = n.images[r.source]
                  , o = e.options.ktx2Loader;
                if (!o) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return e.loadTextureImage(t, s, o)
            }
        }
        class Tg {
            constructor(t) {
                this.parser = t,
                this.name = mg.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(t) {
                const e = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[t];
                if (!r.extensions || !r.extensions[e])
                    return null;
                const s = r.extensions[e]
                  , o = i.images[s.source];
                let a = n.textureLoader;
                if (o.uri) {
                    const t = n.options.manager.getHandler(o.uri);
                    null !== t && (a = t)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(t, o, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(t)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(t) {
                    const e = new Image;
                    e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    e.onload = e.onerror = function() {
                        t(1 === e.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class Eg {
            constructor(t) {
                this.name = mg.EXT_MESHOPT_COMPRESSION,
                this.parser = t
            }
            loadBufferView(t) {
                const e = this.parser.json
                  , n = e.bufferViews[t];
                if (n.extensions && n.extensions[this.name]) {
                    const t = n.extensions[this.name]
                      , i = this.parser.getDependency("buffer", t.buffer)
                      , r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return Promise.all([i, r.ready]).then((function(e) {
                        const n = t.byteOffset || 0
                          , i = t.byteLength || 0
                          , s = t.count
                          , o = t.byteStride
                          , a = new ArrayBuffer(s * o)
                          , l = new Uint8Array(e[0],n,i);
                        return r.decodeGltfBuffer(new Uint8Array(a), s, o, l, t.mode, t.filter),
                        a
                    }
                    ))
                }
                return null
            }
        }
        const Ag = "glTF";
        class Cg {
            constructor(t) {
                this.name = mg.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const e = new DataView(t,0,12);
                if (this.header = {
                    magic: Um.decodeText(new Uint8Array(t.slice(0, 4))),
                    version: e.getUint32(4, !0),
                    length: e.getUint32(8, !0)
                },
                this.header.magic !== Ag)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const n = this.header.length - 12
                  , i = new DataView(t,12);
                let r = 0;
                for (; r < n; ) {
                    const e = i.getUint32(r, !0);
                    r += 4;
                    const n = i.getUint32(r, !0);
                    if (r += 4,
                    1313821514 === n) {
                        const n = new Uint8Array(t,12 + r,e);
                        this.content = Um.decodeText(n)
                    } else if (5130562 === n) {
                        const n = 12 + r;
                        this.body = t.slice(n, n + e)
                    }
                    r += e
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class Rg {
            constructor(t, e) {
                if (!e)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = mg.KHR_DRACO_MESH_COMPRESSION,
                this.json = t,
                this.dracoLoader = e,
                this.dracoLoader.preload()
            }
            decodePrimitive(t, e) {
                const n = this.json
                  , i = this.dracoLoader
                  , r = t.extensions[this.name].bufferView
                  , s = t.extensions[this.name].attributes
                  , o = {}
                  , a = {}
                  , l = {};
                for (const t in s) {
                    const e = Ug[t] || t.toLowerCase();
                    o[e] = s[t]
                }
                for (const e in t.attributes) {
                    const i = Ug[e] || e.toLowerCase();
                    if (void 0 !== s[e]) {
                        const r = n.accessors[t.attributes[e]]
                          , s = zg[r.componentType];
                        l[i] = s,
                        a[i] = !0 === r.normalized
                    }
                }
                return e.getDependency("bufferView", r).then((function(t) {
                    return new Promise((function(e) {
                        i.decodeDracoFile(t, (function(t) {
                            for (const e in t.attributes) {
                                const n = t.attributes[e]
                                  , i = a[e];
                                void 0 !== i && (n.normalized = i)
                            }
                            e(t)
                        }
                        ), o, l)
                    }
                    ))
                }
                ))
            }
        }
        class Lg {
            constructor() {
                this.name = mg.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(t, e) {
                return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
                void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(),
                void 0 !== e.offset && t.offset.fromArray(e.offset),
                void 0 !== e.rotation && (t.rotation = e.rotation),
                void 0 !== e.scale && t.repeat.fromArray(e.scale),
                t.needsUpdate = !0),
                t
            }
        }
        class Pg extends tm {
            constructor(t) {
                super(),
                this.isGLTFSpecularGlossinessMaterial = !0;
                const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
                  , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
                  , i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
                  , r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
                  , s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
                  , o = {
                    specular: {
                        value: (new Va).setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
                this._extraUniforms = o,
                this.onBeforeCompile = function(t) {
                    for (const e in o)
                        t.uniforms[e] = o[e];
                    t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
                }
                ,
                Object.defineProperties(this, {
                    specular: {
                        get: function() {
                            return o.specular.value
                        },
                        set: function(t) {
                            o.specular.value = t
                        }
                    },
                    specularMap: {
                        get: function() {
                            return o.specularMap.value
                        },
                        set: function(t) {
                            o.specularMap.value = t,
                            t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                        }
                    },
                    glossiness: {
                        get: function() {
                            return o.glossiness.value
                        },
                        set: function(t) {
                            o.glossiness.value = t
                        }
                    },
                    glossinessMap: {
                        get: function() {
                            return o.glossinessMap.value
                        },
                        set: function(t) {
                            o.glossinessMap.value = t,
                            t ? (this.defines.USE_GLOSSINESSMAP = "",
                            this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                            delete this.defines.USE_UV)
                        }
                    }
                }),
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this.setValues(t)
            }
            copy(t) {
                return super.copy(t),
                this.specularMap = t.specularMap,
                this.specular.copy(t.specular),
                this.glossinessMap = t.glossinessMap,
                this.glossiness = t.glossiness,
                delete this.metalness,
                delete this.roughness,
                delete this.metalnessMap,
                delete this.roughnessMap,
                this
            }
        }
        class Dg {
            constructor() {
                this.name = mg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
            }
            getMaterialType() {
                return Pg
            }
            extendParams(t, e, n) {
                const i = e.extensions[this.name];
                t.color = new Va(1,1,1),
                t.opacity = 1;
                const r = [];
                if (Array.isArray(i.diffuseFactor)) {
                    const e = i.diffuseFactor;
                    t.color.fromArray(e),
                    t.opacity = e[3]
                }
                if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, "map", i.diffuseTexture)),
                t.emissive = new Va(0,0,0),
                t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1,
                t.specular = new Va(1,1,1),
                Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor),
                void 0 !== i.specularGlossinessTexture) {
                    const e = i.specularGlossinessTexture;
                    r.push(n.assignTexture(t, "glossinessMap", e)),
                    r.push(n.assignTexture(t, "specularMap", e))
                }
                return Promise.all(r)
            }
            createMaterial(t) {
                const e = new Pg(t);
                return e.fog = !0,
                e.color = t.color,
                e.map = void 0 === t.map ? null : t.map,
                e.lightMap = null,
                e.lightMapIntensity = 1,
                e.aoMap = void 0 === t.aoMap ? null : t.aoMap,
                e.aoMapIntensity = 1,
                e.emissive = t.emissive,
                e.emissiveIntensity = 1,
                e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap,
                e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap,
                e.bumpScale = 1,
                e.normalMap = void 0 === t.normalMap ? null : t.normalMap,
                e.normalMapType = 0,
                t.normalScale && (e.normalScale = t.normalScale),
                e.displacementMap = null,
                e.displacementScale = 1,
                e.displacementBias = 0,
                e.specularMap = void 0 === t.specularMap ? null : t.specularMap,
                e.specular = t.specular,
                e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap,
                e.glossiness = t.glossiness,
                e.alphaMap = null,
                e.envMap = void 0 === t.envMap ? null : t.envMap,
                e.envMapIntensity = 1,
                e.refractionRatio = .98,
                e
            }
        }
        class Ig {
            constructor() {
                this.name = mg.KHR_MESH_QUANTIZATION
            }
        }
        class Og extends im {
            constructor(t, e, n, i) {
                super(t, e, n, i)
            }
            copySampleValue_(t) {
                const e = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = t * i * 3 + i;
                for (let t = 0; t !== i; t++)
                    e[t] = n[r + t];
                return e
            }
        }
        Og.prototype.beforeStart_ = Og.prototype.copySampleValue_,
        Og.prototype.afterEnd_ = Og.prototype.copySampleValue_,
        Og.prototype.interpolate_ = function(t, e, n, i) {
            const r = this.resultBuffer
              , s = this.sampleValues
              , o = this.valueSize
              , a = 2 * o
              , l = 3 * o
              , c = i - e
              , u = (n - e) / c
              , h = u * u
              , d = h * u
              , p = t * l
              , f = p - l
              , m = -2 * d + 3 * h
              , g = d - h
              , v = 1 - m
              , y = g - h + u;
            for (let t = 0; t !== o; t++) {
                const e = s[f + t + o]
                  , n = s[f + t + a] * c
                  , i = s[p + t + o]
                  , l = s[p + t] * c;
                r[t] = v * e + y * n + m * i + g * l
            }
            return r
        }
        ;
        const Ng = new Qa;
        class kg extends Og {
            interpolate_(t, e, n, i) {
                const r = super.interpolate_(t, e, n, i);
                return Ng.fromArray(r).normalize().toArray(r),
                r
            }
        }
        const zg = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , Hg = {
            9728: Vo,
            9729: qo,
            9984: Wo,
            9985: 1007,
            9986: jo,
            9987: Xo
        }
          , Bg = {
            33071: Uo,
            33648: Go,
            10497: Fo
        }
          , Fg = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , Ug = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , Gg = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , Vg = {
            CUBICSPLINE: void 0,
            LINEAR: la,
            STEP: aa
        };
        function Wg(t, e, n) {
            for (const i in n.extensions)
                void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
                e.userData.gltfExtensions[i] = n.extensions[i])
        }
        function jg(t, e) {
            void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
        }
        function qg(t, e) {
            if (t.updateMorphTargets(),
            void 0 !== e.weights)
                for (let n = 0, i = e.weights.length; n < i; n++)
                    t.morphTargetInfluences[n] = e.weights[n];
            if (e.extras && Array.isArray(e.extras.targetNames)) {
                const n = e.extras.targetNames;
                if (t.morphTargetInfluences.length === n.length) {
                    t.morphTargetDictionary = {};
                    for (let e = 0, i = n.length; e < i; e++)
                        t.morphTargetDictionary[n[e]] = e
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function Xg(t) {
            const e = t.extensions && t.extensions[mg.KHR_DRACO_MESH_COMPRESSION];
            let n;
            return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + Yg(e.attributes) : t.indices + ":" + Yg(t.attributes) + ":" + t.mode,
            n
        }
        function Yg(t) {
            let e = "";
            const n = Object.keys(t).sort();
            for (let i = 0, r = n.length; i < r; i++)
                e += n[i] + ":" + t[n[i]] + ";";
            return e
        }
        function Jg(t) {
            switch (t) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        class Zg {
            constructor(t={}, e={}) {
                this.json = t,
                this.extensions = {},
                this.plugins = {},
                this.options = e,
                this.cache = new fg,
                this.associations = new Map,
                this.primitiveCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.textureCache = {},
                this.nodeNamesUsed = {},
                "undefined" != typeof createImageBitmap && !1 === /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? this.textureLoader = new Gm(this.options.manager) : this.textureLoader = new Sm(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new bm(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(t) {
                this.extensions = t
            }
            setPlugins(t) {
                this.plugins = t
            }
            parse(t, e) {
                const n = this
                  , i = this.json
                  , r = this.extensions;
                this.cache.removeAll(),
                this._invokeAll((function(t) {
                    return t._markDefs && t._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(t) {
                    return t.beforeRoot && t.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(e) {
                    const s = {
                        scene: e[0][i.scene || 0],
                        scenes: e[0],
                        animations: e[1],
                        cameras: e[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    Wg(r, s, i),
                    jg(s, i),
                    Promise.all(n._invokeAll((function(t) {
                        return t.afterRoot && t.afterRoot(s)
                    }
                    ))).then((function() {
                        t(s)
                    }
                    ))
                }
                )).catch(e)
            }
            _markDefs() {
                const t = this.json.nodes || []
                  , e = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n].joints;
                    for (let e = 0, n = i.length; e < n; e++)
                        t[i[e]].isBone = !0
                }
                for (let e = 0, i = t.length; e < i; e++) {
                    const i = t[e];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                    void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                    void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(t, e) {
                void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
                t.refs[e]++)
            }
            _getNodeRef(t, e, n) {
                if (t.refs[e] <= 1)
                    return n;
                const i = n.clone()
                  , r = (t,e)=>{
                    const n = this.associations.get(t);
                    null != n && this.associations.set(e, n);
                    for (const [n,i] of t.children.entries())
                        r(i, e.children[n])
                }
                ;
                return r(n, i),
                i.name += "_instance_" + t.uses[e]++,
                i
            }
            _invokeOne(t) {
                const e = Object.values(this.plugins);
                e.push(this);
                for (let n = 0; n < e.length; n++) {
                    const i = t(e[n]);
                    if (i)
                        return i
                }
                return null
            }
            _invokeAll(t) {
                const e = Object.values(this.plugins);
                e.unshift(this);
                const n = [];
                for (let i = 0; i < e.length; i++) {
                    const r = t(e[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(t, e) {
                const n = t + ":" + e;
                let i = this.cache.get(n);
                if (!i) {
                    switch (t) {
                    case "scene":
                        i = this.loadScene(e);
                        break;
                    case "node":
                        i = this.loadNode(e);
                        break;
                    case "mesh":
                        i = this._invokeOne((function(t) {
                            return t.loadMesh && t.loadMesh(e)
                        }
                        ));
                        break;
                    case "accessor":
                        i = this.loadAccessor(e);
                        break;
                    case "bufferView":
                        i = this._invokeOne((function(t) {
                            return t.loadBufferView && t.loadBufferView(e)
                        }
                        ));
                        break;
                    case "buffer":
                        i = this.loadBuffer(e);
                        break;
                    case "material":
                        i = this._invokeOne((function(t) {
                            return t.loadMaterial && t.loadMaterial(e)
                        }
                        ));
                        break;
                    case "texture":
                        i = this._invokeOne((function(t) {
                            return t.loadTexture && t.loadTexture(e)
                        }
                        ));
                        break;
                    case "skin":
                        i = this.loadSkin(e);
                        break;
                    case "animation":
                        i = this.loadAnimation(e);
                        break;
                    case "camera":
                        i = this.loadCamera(e);
                        break;
                    default:
                        throw new Error("Unknown type: " + t)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(t) {
                let e = this.cache.get(t);
                if (!e) {
                    const n = this
                      , i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                    e = Promise.all(i.map((function(e, i) {
                        return n.getDependency(t, i)
                    }
                    ))),
                    this.cache.add(t, e)
                }
                return e
            }
            loadBuffer(t) {
                const e = this.json.buffers[t]
                  , n = this.fileLoader;
                if (e.type && "arraybuffer" !== e.type)
                    throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                if (void 0 === e.uri && 0 === t)
                    return Promise.resolve(this.extensions[mg.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function(t, r) {
                    n.load(Um.resolveURL(e.uri, i.path), t, void 0, (function() {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(t) {
                const e = this.json.bufferViews[t];
                return this.getDependency("buffer", e.buffer).then((function(t) {
                    const n = e.byteLength || 0
                      , i = e.byteOffset || 0;
                    return t.slice(i, i + n)
                }
                ))
            }
            loadAccessor(t) {
                const e = this
                  , n = this.json
                  , i = this.json.accessors[t];
                if (void 0 === i.bufferView && void 0 === i.sparse)
                    return Promise.resolve(null);
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
                void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
                r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
                Promise.all(r).then((function(t) {
                    const r = t[0]
                      , s = Fg[i.type]
                      , o = zg[i.componentType]
                      , a = o.BYTES_PER_ELEMENT
                      , l = a * s
                      , c = i.byteOffset || 0
                      , u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0
                      , h = !0 === i.normalized;
                    let d, p;
                    if (u && u !== l) {
                        const t = Math.floor(c / u)
                          , n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                        let l = e.cache.get(n);
                        l || (d = new o(r,t * u,i.count * u / a),
                        l = new ip(d,u / a),
                        e.cache.add(n, l)),
                        p = new sp(l,s,c % u / a,h)
                    } else
                        d = null === r ? new o(i.count * s) : new o(r,c,i.count * s),
                        p = new yc(d,s,h);
                    if (void 0 !== i.sparse) {
                        const e = Fg.SCALAR
                          , n = zg[i.sparse.indices.componentType]
                          , a = i.sparse.indices.byteOffset || 0
                          , l = i.sparse.values.byteOffset || 0
                          , c = new n(t[1],a,i.sparse.count * e)
                          , u = new o(t[2],l,i.sparse.count * s);
                        null !== r && (p = new yc(p.array.slice(),p.itemSize,p.normalized));
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            if (p.setX(e, u[t * s]),
                            s >= 2 && p.setY(e, u[t * s + 1]),
                            s >= 3 && p.setZ(e, u[t * s + 2]),
                            s >= 4 && p.setW(e, u[t * s + 3]),
                            s >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }
                ))
            }
            loadTexture(t) {
                const e = this.json
                  , n = this.options
                  , i = e.textures[t]
                  , r = e.images[i.source];
                let s = this.textureLoader;
                if (r.uri) {
                    const t = n.manager.getHandler(r.uri);
                    null !== t && (s = t)
                }
                return this.loadTextureImage(t, r, s)
            }
            loadTextureImage(t, e, n) {
                const i = this
                  , r = this.json
                  , s = this.options
                  , o = r.textures[t]
                  , a = (e.uri || e.bufferView) + ":" + o.sampler;
                if (this.textureCache[a])
                    return this.textureCache[a];
                const l = self.URL || self.webkitURL;
                let c = e.uri || ""
                  , u = !1;
                if (void 0 !== e.bufferView)
                    c = i.getDependency("bufferView", e.bufferView).then((function(t) {
                        u = !0;
                        const n = new Blob([t],{
                            type: e.mimeType
                        });
                        return c = l.createObjectURL(n),
                        c
                    }
                    ));
                else if (void 0 === e.uri)
                    throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                const h = Promise.resolve(c).then((function(t) {
                    return new Promise((function(e, i) {
                        let r = e;
                        !0 === n.isImageBitmapLoader && (r = function(t) {
                            const n = new Xa(t);
                            n.needsUpdate = !0,
                            e(n)
                        }
                        ),
                        n.load(Um.resolveURL(t, s.path), r, void 0, i)
                    }
                    ))
                }
                )).then((function(e) {
                    !0 === u && l.revokeObjectURL(c),
                    e.flipY = !1,
                    o.name && (e.name = o.name);
                    const n = (r.samplers || {})[o.sampler] || {};
                    return e.magFilter = Hg[n.magFilter] || qo,
                    e.minFilter = Hg[n.minFilter] || Xo,
                    e.wrapS = Bg[n.wrapS] || Fo,
                    e.wrapT = Bg[n.wrapT] || Fo,
                    i.associations.set(e, {
                        textures: t
                    }),
                    e
                }
                )).catch((function() {
                    return console.error("THREE.GLTFLoader: Couldn't load texture", c),
                    null
                }
                ));
                return this.textureCache[a] = h,
                h
            }
            assignTexture(t, e, n) {
                const i = this;
                return this.getDependency("texture", n.index).then((function(r) {
                    if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."),
                    i.extensions[mg.KHR_TEXTURE_TRANSFORM]) {
                        const t = void 0 !== n.extensions ? n.extensions[mg.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (t) {
                            const e = i.associations.get(r);
                            r = i.extensions[mg.KHR_TEXTURE_TRANSFORM].extendTexture(r, t),
                            i.associations.set(r, e)
                        }
                    }
                    return t[e] = r,
                    r
                }
                ))
            }
            assignFinalMaterial(t) {
                const e = t.geometry;
                let n = t.material;
                const i = void 0 === e.attributes.tangent
                  , r = void 0 !== e.attributes.color
                  , s = void 0 === e.attributes.normal;
                if (t.isPoints) {
                    const t = "PointsMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new Yp,
                    fc.prototype.copy.call(e, n),
                    e.color.copy(n.color),
                    e.map = n.map,
                    e.sizeAttenuation = !1,
                    this.cache.add(t, e)),
                    n = e
                } else if (t.isLine) {
                    const t = "LineBasicMaterial:" + n.uuid;
                    let e = this.cache.get(t);
                    e || (e = new zp,
                    fc.prototype.copy.call(e, n),
                    e.color.copy(n.color),
                    this.cache.add(t, e)),
                    n = e
                }
                if (i || r || s) {
                    let t = "ClonedMaterial:" + n.uuid + ":";
                    n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"),
                    i && (t += "derivative-tangents:"),
                    r && (t += "vertex-colors:"),
                    s && (t += "flat-shading:");
                    let e = this.cache.get(t);
                    e || (e = n.clone(),
                    r && (e.vertexColors = !0),
                    s && (e.flatShading = !0),
                    i && (e.normalScale && (e.normalScale.y *= -1),
                    e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                    this.cache.add(t, e),
                    this.associations.set(e, this.associations.get(n))),
                    n = e
                }
                n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv),
                t.material = n
            }
            getMaterialType() {
                return tm
            }
            loadMaterial(t) {
                const e = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.materials[t];
                let s;
                const o = {}
                  , a = r.extensions || {}
                  , l = [];
                if (a[mg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                    const t = i[mg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    s = t.getMaterialType(),
                    l.push(t.extendParams(o, r, e))
                } else if (a[mg.KHR_MATERIALS_UNLIT]) {
                    const t = i[mg.KHR_MATERIALS_UNLIT];
                    s = t.getMaterialType(),
                    l.push(t.extendParams(o, r, e))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (o.color = new Va(1,1,1),
                    o.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const t = n.baseColorFactor;
                        o.color.fromArray(t),
                        o.opacity = t[3]
                    }
                    void 0 !== n.baseColorTexture && l.push(e.assignTexture(o, "map", n.baseColorTexture)),
                    o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (l.push(e.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)),
                    l.push(e.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))),
                    s = this._invokeOne((function(e) {
                        return e.getMaterialType && e.getMaterialType(t)
                    }
                    )),
                    l.push(Promise.all(this._invokeAll((function(e) {
                        return e.extendMaterialParams && e.extendMaterialParams(t, o)
                    }
                    ))))
                }
                !0 === r.doubleSided && (o.side = 2);
                const c = r.alphaMode || "OPAQUE";
                if ("BLEND" === c ? (o.transparent = !0,
                o.depthWrite = !1) : (o.transparent = !1,
                "MASK" === c && (o.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
                void 0 !== r.normalTexture && s !== mc && (l.push(e.assignTexture(o, "normalMap", r.normalTexture)),
                o.normalScale = new Ia(1,1),
                void 0 !== r.normalTexture.scale)) {
                    const t = r.normalTexture.scale;
                    o.normalScale.set(t, t)
                }
                return void 0 !== r.occlusionTexture && s !== mc && (l.push(e.assignTexture(o, "aoMap", r.occlusionTexture)),
                void 0 !== r.occlusionTexture.strength && (o.aoMapIntensity = r.occlusionTexture.strength)),
                void 0 !== r.emissiveFactor && s !== mc && (o.emissive = (new Va).fromArray(r.emissiveFactor)),
                void 0 !== r.emissiveTexture && s !== mc && l.push(e.assignTexture(o, "emissiveMap", r.emissiveTexture)),
                Promise.all(l).then((function() {
                    let n;
                    return n = s === Pg ? i[mg.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new s(o),
                    r.name && (n.name = r.name),
                    n.map && (n.map.encoding = fa),
                    n.emissiveMap && (n.emissiveMap.encoding = fa),
                    jg(n, r),
                    e.associations.set(n, {
                        materials: t
                    }),
                    r.extensions && Wg(i, n, r),
                    n
                }
                ))
            }
            createUniqueName(t) {
                const e = ig.sanitizeNodeName(t || "");
                let n = e;
                for (let t = 1; this.nodeNamesUsed[n]; ++t)
                    n = e + "_" + t;
                return this.nodeNamesUsed[n] = !0,
                n
            }
            loadGeometries(t) {
                const e = this
                  , n = this.extensions
                  , i = this.primitiveCache;
                function r(t) {
                    return n[mg.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                        return Qg(n, t, e)
                    }
                    ))
                }
                const s = [];
                for (let n = 0, o = t.length; n < o; n++) {
                    const o = t[n]
                      , a = Xg(o)
                      , l = i[a];
                    if (l)
                        s.push(l.promise);
                    else {
                        let t;
                        t = o.extensions && o.extensions[mg.KHR_DRACO_MESH_COMPRESSION] ? r(o) : Qg(new Rc, o, e),
                        i[a] = {
                            primitive: o,
                            promise: t
                        },
                        s.push(t)
                    }
                }
                return Promise.all(s)
            }
            loadMesh(t) {
                const e = this
                  , n = this.json
                  , i = this.extensions
                  , r = n.meshes[t]
                  , s = r.primitives
                  , o = [];
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = void 0 === s[t].material ? (void 0 === (a = this.cache).DefaultMaterial && (a.DefaultMaterial = new tm({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0
                    })),
                    a.DefaultMaterial) : this.getDependency("material", s[t].material);
                    o.push(e)
                }
                var a;
                return o.push(e.loadGeometries(s)),
                Promise.all(o).then((function(n) {
                    const o = n.slice(0, n.length - 1)
                      , a = n[n.length - 1]
                      , l = [];
                    for (let n = 0, c = a.length; n < c; n++) {
                        const c = a[n]
                          , u = s[n];
                        let h;
                        const d = o[n];
                        if (4 === u.mode || 5 === u.mode || 6 === u.mode || void 0 === u.mode)
                            h = !0 === r.isSkinnedMesh ? new Ep(c,d) : new Xc(c,d),
                            !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(),
                            5 === u.mode ? h.geometry = $g(h.geometry, 1) : 6 === u.mode && (h.geometry = $g(h.geometry, 2));
                        else if (1 === u.mode)
                            h = new qp(c,d);
                        else if (3 === u.mode)
                            h = new Vp(c,d);
                        else if (2 === u.mode)
                            h = new Xp(c,d);
                        else {
                            if (0 !== u.mode)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                            h = new $p(c,d)
                        }
                        Object.keys(h.geometry.morphAttributes).length > 0 && qg(h, r),
                        h.name = e.createUniqueName(r.name || "mesh_" + t),
                        jg(h, r),
                        u.extensions && Wg(i, h, u),
                        e.assignFinalMaterial(h),
                        l.push(h)
                    }
                    for (let n = 0, i = l.length; n < i; n++)
                        e.associations.set(l[n], {
                            meshes: t,
                            primitives: n
                        });
                    if (1 === l.length)
                        return l[0];
                    const c = new Xd;
                    e.associations.set(c, {
                        meshes: t
                    });
                    for (let t = 0, e = l.length; t < e; t++)
                        c.add(l[t]);
                    return c
                }
                ))
            }
            loadCamera(t) {
                let e;
                const n = this.json.cameras[t]
                  , i = n[n.type];
                if (i)
                    return "perspective" === n.type ? e = new eu(Da.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (e = new Tu(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
                    n.name && (e.name = this.createUniqueName(n.name)),
                    jg(e, n),
                    Promise.resolve(e);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(t) {
                const e = this.json.skins[t]
                  , n = {
                    joints: e.joints
                };
                return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                    return n.inverseBindMatrices = t,
                    n
                }
                ))
            }
            loadAnimation(t) {
                const e = this.json.animations[t]
                  , n = []
                  , i = []
                  , r = []
                  , s = []
                  , o = [];
                for (let t = 0, a = e.channels.length; t < a; t++) {
                    const a = e.channels[t]
                      , l = e.samplers[a.sampler]
                      , c = a.target
                      , u = void 0 !== c.node ? c.node : c.id
                      , h = void 0 !== e.parameters ? e.parameters[l.input] : l.input
                      , d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                    n.push(this.getDependency("node", u)),
                    i.push(this.getDependency("accessor", h)),
                    r.push(this.getDependency("accessor", d)),
                    s.push(l),
                    o.push(c)
                }
                return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o)]).then((function(n) {
                    const i = n[0]
                      , r = n[1]
                      , s = n[2]
                      , o = n[3]
                      , a = n[4]
                      , l = [];
                    for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t]
                          , n = r[t]
                          , c = s[t]
                          , u = o[t]
                          , h = a[t];
                        if (void 0 === e)
                            continue;
                        let d;
                        switch (e.updateMatrix(),
                        e.matrixAutoUpdate = !0,
                        Gg[h.path]) {
                        case Gg.weights:
                            d = um;
                            break;
                        case Gg.rotation:
                            d = dm;
                            break;
                        case Gg.position:
                        case Gg.scale:
                        default:
                            d = fm
                        }
                        const p = e.name ? e.name : e.uuid
                          , f = void 0 !== u.interpolation ? Vg[u.interpolation] : la
                          , m = [];
                        Gg[h.path] === Gg.weights ? e.traverse((function(t) {
                            t.morphTargetInfluences && m.push(t.name ? t.name : t.uuid)
                        }
                        )) : m.push(p);
                        let g = c.array;
                        if (c.normalized) {
                            const t = Jg(g.constructor)
                              , e = new Float32Array(g.length);
                            for (let n = 0, i = g.length; n < i; n++)
                                e[n] = g[n] * t;
                            g = e
                        }
                        for (let t = 0, e = m.length; t < e; t++) {
                            const e = new d(m[t] + "." + Gg[h.path],n.array,g,f);
                            "CUBICSPLINE" === u.interpolation && (e.createInterpolant = function(t) {
                                return new (this instanceof dm ? kg : Og)(this.times,this.values,this.getValueSize() / 3,t)
                            }
                            ,
                            e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                            l.push(e)
                        }
                    }
                    const c = e.name ? e.name : "animation_" + t;
                    return new mm(c,void 0,l)
                }
                ))
            }
            createNodeMesh(t) {
                const e = this.json
                  , n = this
                  , i = e.nodes[t];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(t) {
                    const e = n._getNodeRef(n.meshCache, i.mesh, t);
                    return void 0 !== i.weights && e.traverse((function(t) {
                        if (t.isMesh)
                            for (let e = 0, n = i.weights.length; e < n; e++)
                                t.morphTargetInfluences[e] = i.weights[e]
                    }
                    )),
                    e
                }
                ))
            }
            loadNode(t) {
                const e = this.json
                  , n = this.extensions
                  , i = this
                  , r = e.nodes[t]
                  , s = r.name ? i.createUniqueName(r.name) : "";
                return function() {
                    const e = []
                      , n = i._invokeOne((function(e) {
                        return e.createNodeMesh && e.createNodeMesh(t)
                    }
                    ));
                    return n && e.push(n),
                    void 0 !== r.camera && e.push(i.getDependency("camera", r.camera).then((function(t) {
                        return i._getNodeRef(i.cameraCache, r.camera, t)
                    }
                    ))),
                    i._invokeAll((function(e) {
                        return e.createNodeAttachment && e.createNodeAttachment(t)
                    }
                    )).forEach((function(t) {
                        e.push(t)
                    }
                    )),
                    Promise.all(e)
                }().then((function(e) {
                    let o;
                    if (o = !0 === r.isBone ? new Ap : e.length > 1 ? new Xd : 1 === e.length ? e[0] : new ec,
                    o !== e[0])
                        for (let t = 0, n = e.length; t < n; t++)
                            o.add(e[t]);
                    if (r.name && (o.userData.name = r.name,
                    o.name = s),
                    jg(o, r),
                    r.extensions && Wg(n, o, r),
                    void 0 !== r.matrix) {
                        const t = new Ll;
                        t.fromArray(r.matrix),
                        o.applyMatrix4(t)
                    } else
                        void 0 !== r.translation && o.position.fromArray(r.translation),
                        void 0 !== r.rotation && o.quaternion.fromArray(r.rotation),
                        void 0 !== r.scale && o.scale.fromArray(r.scale);
                    return i.associations.has(o) || i.associations.set(o, {}),
                    i.associations.get(o).nodes = t,
                    o
                }
                ))
            }
            loadScene(t) {
                const e = this.json
                  , n = this.extensions
                  , i = this.json.scenes[t]
                  , r = this
                  , s = new Xd;
                i.name && (s.name = r.createUniqueName(i.name)),
                jg(s, i),
                i.extensions && Wg(n, s, i);
                const o = i.nodes || []
                  , a = [];
                for (let t = 0, n = o.length; t < n; t++)
                    a.push(Kg(o[t], s, e, r));
                return Promise.all(a).then((function() {
                    return r.associations = (t=>{
                        const e = new Map;
                        for (const [t,n] of r.associations)
                            (t instanceof fc || t instanceof Xa) && e.set(t, n);
                        return t.traverse((t=>{
                            const n = r.associations.get(t);
                            null != n && e.set(t, n)
                        }
                        )),
                        e
                    }
                    )(s),
                    s
                }
                ))
            }
        }
        function Kg(t, e, n, i) {
            const r = n.nodes[t];
            return i.getDependency("node", t).then((function(t) {
                if (void 0 === r.skin)
                    return t;
                let e;
                return i.getDependency("skin", r.skin).then((function(t) {
                    e = t;
                    const n = [];
                    for (let t = 0, r = e.joints.length; t < r; t++)
                        n.push(i.getDependency("node", e.joints[t]));
                    return Promise.all(n)
                }
                )).then((function(n) {
                    return t.traverse((function(t) {
                        if (!t.isMesh)
                            return;
                        const i = []
                          , r = [];
                        for (let t = 0, s = n.length; t < s; t++) {
                            const s = n[t];
                            if (s) {
                                i.push(s);
                                const n = new Ll;
                                void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t),
                                r.push(n)
                            } else
                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                        }
                        t.bind(new Pp(i,r), t.matrixWorld)
                    }
                    )),
                    t
                }
                ))
            }
            )).then((function(t) {
                e.add(t);
                const s = [];
                if (r.children) {
                    const e = r.children;
                    for (let r = 0, o = e.length; r < o; r++) {
                        const o = e[r];
                        s.push(Kg(o, t, n, i))
                    }
                }
                return Promise.all(s)
            }
            ))
        }
        function Qg(t, e, n) {
            const i = e.attributes
              , r = [];
            function s(e, i) {
                return n.getDependency("accessor", e).then((function(e) {
                    t.setAttribute(i, e)
                }
                ))
            }
            for (const e in i) {
                const n = Ug[e] || e.toLowerCase();
                n in t.attributes || r.push(s(i[e], n))
            }
            if (void 0 !== e.indices && !t.index) {
                const i = n.getDependency("accessor", e.indices).then((function(e) {
                    t.setIndex(e)
                }
                ));
                r.push(i)
            }
            return jg(t, e),
            function(t, e, n) {
                const i = e.attributes
                  , r = new nl;
                if (void 0 === i.POSITION)
                    return;
                {
                    const t = n.json.accessors[i.POSITION]
                      , e = t.min
                      , s = t.max;
                    if (void 0 === e || void 0 === s)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (r.set(new $a(e[0],e[1],e[2]), new $a(s[0],s[1],s[2])),
                    t.normalized) {
                        const e = Jg(zg[t.componentType]);
                        r.min.multiplyScalar(e),
                        r.max.multiplyScalar(e)
                    }
                }
                const s = e.targets;
                if (void 0 !== s) {
                    const t = new $a
                      , e = new $a;
                    for (let i = 0, r = s.length; i < r; i++) {
                        const r = s[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION]
                              , s = i.min
                              , o = i.max;
                            if (void 0 !== s && void 0 !== o) {
                                if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))),
                                e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))),
                                e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))),
                                i.normalized) {
                                    const t = Jg(zg[i.componentType]);
                                    e.multiplyScalar(t)
                                }
                                t.max(e)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    r.expandByVector(t)
                }
                t.boundingBox = r;
                const o = new bl;
                r.getCenter(o.center),
                o.radius = r.min.distanceTo(r.max) / 2,
                t.boundingSphere = o
            }(t, e, n),
            Promise.all(r).then((function() {
                return void 0 !== e.targets ? function(t, e, n) {
                    let i = !1
                      , r = !1;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        if (void 0 !== n.POSITION && (i = !0),
                        void 0 !== n.NORMAL && (r = !0),
                        i && r)
                            break
                    }
                    if (!i && !r)
                        return Promise.resolve(t);
                    const s = []
                      , o = [];
                    for (let a = 0, l = e.length; a < l; a++) {
                        const l = e[a];
                        if (i) {
                            const e = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position;
                            s.push(e)
                        }
                        if (r) {
                            const e = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                            o.push(e)
                        }
                    }
                    return Promise.all([Promise.all(s), Promise.all(o)]).then((function(e) {
                        const n = e[0]
                          , s = e[1];
                        return i && (t.morphAttributes.position = n),
                        r && (t.morphAttributes.normal = s),
                        t.morphTargetsRelative = !0,
                        t
                    }
                    ))
                }(t, e.targets, n) : t
            }
            ))
        }
        function $g(t, e) {
            let n = t.getIndex();
            if (null === n) {
                const e = []
                  , i = t.getAttribute("position");
                if (void 0 === i)
                    return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                    t;
                for (let t = 0; t < i.count; t++)
                    e.push(t);
                t.setIndex(e),
                n = t.getIndex()
            }
            const i = n.count - 2
              , r = [];
            if (2 === e)
                for (let t = 1; t <= i; t++)
                    r.push(n.getX(0)),
                    r.push(n.getX(t)),
                    r.push(n.getX(t + 1));
            else
                for (let t = 0; t < i; t++)
                    t % 2 == 0 ? (r.push(n.getX(t)),
                    r.push(n.getX(t + 1)),
                    r.push(n.getX(t + 2))) : (r.push(n.getX(t + 2)),
                    r.push(n.getX(t + 1)),
                    r.push(n.getX(t)));
            r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
            const s = t.clone();
            return s.setIndex(r),
            s
        }
        const tv = new WeakMap;
        class ev extends xm {
            constructor(t) {
                super(t),
                this.decoderPath = "",
                this.decoderConfig = {},
                this.decoderBinary = null,
                this.decoderPending = null,
                this.workerLimit = 4,
                this.workerPool = [],
                this.workerNextTaskID = 1,
                this.workerSourceURL = "",
                this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                },
                this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(t) {
                return this.decoderPath = t,
                this
            }
            setDecoderConfig(t) {
                return this.decoderConfig = t,
                this
            }
            setWorkerLimit(t) {
                return this.workerLimit = t,
                this
            }
            load(t, e, n, i) {
                const r = new bm(this.manager);
                r.setPath(this.path),
                r.setResponseType("arraybuffer"),
                r.setRequestHeader(this.requestHeader),
                r.setWithCredentials(this.withCredentials),
                r.load(t, (t=>{
                    const n = {
                        attributeIDs: this.defaultAttributeIDs,
                        attributeTypes: this.defaultAttributeTypes,
                        useUniqueIDs: !1
                    };
                    this.decodeGeometry(t, n).then(e).catch(i)
                }
                ), n, i)
            }
            decodeDracoFile(t, e, n, i) {
                const r = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: i || this.defaultAttributeTypes,
                    useUniqueIDs: !!n
                };
                this.decodeGeometry(t, r).then(e)
            }
            decodeGeometry(t, e) {
                for (const t in e.attributeTypes) {
                    const n = e.attributeTypes[t];
                    void 0 !== n.BYTES_PER_ELEMENT && (e.attributeTypes[t] = n.name)
                }
                const n = JSON.stringify(e);
                if (tv.has(t)) {
                    const e = tv.get(t);
                    if (e.key === n)
                        return e.promise;
                    if (0 === t.byteLength)
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let i;
                const r = this.workerNextTaskID++
                  , s = t.byteLength
                  , o = this._getWorker(r, s).then((n=>(i = n,
                new Promise(((n,s)=>{
                    i._callbacks[r] = {
                        resolve: n,
                        reject: s
                    },
                    i.postMessage({
                        type: "decode",
                        id: r,
                        taskConfig: e,
                        buffer: t
                    }, [t])
                }
                ))))).then((t=>this._createGeometry(t.geometry)));
                return o.catch((()=>!0)).then((()=>{
                    i && r && this._releaseTask(i, r)
                }
                )),
                tv.set(t, {
                    key: n,
                    promise: o
                }),
                o
            }
            _createGeometry(t) {
                const e = new Rc;
                t.index && e.setIndex(new yc(t.index.array,1));
                for (let n = 0; n < t.attributes.length; n++) {
                    const i = t.attributes[n]
                      , r = i.name
                      , s = i.array
                      , o = i.itemSize;
                    e.setAttribute(r, new yc(s,o))
                }
                return e
            }
            _loadLibrary(t, e) {
                const n = new bm(this.manager);
                return n.setPath(this.decoderPath),
                n.setResponseType(e),
                n.setWithCredentials(this.withCredentials),
                new Promise(((e,i)=>{
                    n.load(t, e, void 0, i)
                }
                ))
            }
            preload() {
                return this._initDecoder(),
                this
            }
            _initDecoder() {
                if (this.decoderPending)
                    return this.decoderPending;
                const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
                  , e = [];
                return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                this.decoderPending = Promise.all(e).then((e=>{
                    const n = e[0];
                    t || (this.decoderConfig.wasmBinary = e[1]);
                    const i = nv.toString()
                      , r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                }
                )),
                this.decoderPending
            }
            _getWorker(t, e) {
                return this._initDecoder().then((()=>{
                    if (this.workerPool.length < this.workerLimit) {
                        const t = new Worker(this.workerSourceURL);
                        t._callbacks = {},
                        t._taskCosts = {},
                        t._taskLoad = 0,
                        t.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }),
                        t.onmessage = function(e) {
                            const n = e.data;
                            switch (n.type) {
                            case "decode":
                                t._callbacks[n.id].resolve(n);
                                break;
                            case "error":
                                t._callbacks[n.id].reject(n);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }
                        ,
                        this.workerPool.push(t)
                    } else
                        this.workerPool.sort((function(t, e) {
                            return t._taskLoad > e._taskLoad ? -1 : 1
                        }
                        ));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[t] = e,
                    n._taskLoad += e,
                    n
                }
                ))
            }
            _releaseTask(t, e) {
                t._taskLoad -= t._taskCosts[e],
                delete t._callbacks[e],
                delete t._taskCosts[e]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((t=>t._taskLoad)))
            }
            dispose() {
                for (let t = 0; t < this.workerPool.length; ++t)
                    this.workerPool[t].terminate();
                return this.workerPool.length = 0,
                this
            }
        }
        function nv() {
            let t, e;
            function n(t, e, n, i, r, s) {
                const o = s.num_components()
                  , a = n.num_points() * o
                  , l = a * r.BYTES_PER_ELEMENT
                  , c = function(t, e) {
                    switch (e) {
                    case Float32Array:
                        return t.DT_FLOAT32;
                    case Int8Array:
                        return t.DT_INT8;
                    case Int16Array:
                        return t.DT_INT16;
                    case Int32Array:
                        return t.DT_INT32;
                    case Uint8Array:
                        return t.DT_UINT8;
                    case Uint16Array:
                        return t.DT_UINT16;
                    case Uint32Array:
                        return t.DT_UINT32
                    }
                }(t, r)
                  , u = t._malloc(l);
                e.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
                const h = new r(t.HEAPF32.buffer,u,a).slice();
                return t._free(u),
                {
                    name: i,
                    array: h,
                    itemSize: o
                }
            }
            onmessage = function(i) {
                const r = i.data;
                switch (r.type) {
                case "init":
                    t = r.decoderConfig,
                    e = new Promise((function(e) {
                        t.onModuleLoaded = function(t) {
                            e({
                                draco: t
                            })
                        }
                        ,
                        DracoDecoderModule(t)
                    }
                    ));
                    break;
                case "decode":
                    const i = r.buffer
                      , s = r.taskConfig;
                    e.then((t=>{
                        const e = t.draco
                          , o = new e.Decoder
                          , a = new e.DecoderBuffer;
                        a.Init(new Int8Array(i), i.byteLength);
                        try {
                            const t = function(t, e, i, r) {
                                const s = r.attributeIDs
                                  , o = r.attributeTypes;
                                let a, l;
                                const c = e.GetEncodedGeometryType(i);
                                if (c === t.TRIANGULAR_MESH)
                                    a = new t.Mesh,
                                    l = e.DecodeBufferToMesh(i, a);
                                else {
                                    if (c !== t.POINT_CLOUD)
                                        throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                    a = new t.PointCloud,
                                    l = e.DecodeBufferToPointCloud(i, a)
                                }
                                if (!l.ok() || 0 === a.ptr)
                                    throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                const u = {
                                    index: null,
                                    attributes: []
                                };
                                for (const i in s) {
                                    const l = self[o[i]];
                                    let c, h;
                                    if (r.useUniqueIDs)
                                        h = s[i],
                                        c = e.GetAttributeByUniqueId(a, h);
                                    else {
                                        if (h = e.GetAttributeId(a, t[s[i]]),
                                        -1 === h)
                                            continue;
                                        c = e.GetAttribute(a, h)
                                    }
                                    u.attributes.push(n(t, e, a, i, l, c))
                                }
                                return c === t.TRIANGULAR_MESH && (u.index = function(t, e, n) {
                                    const i = 3 * n.num_faces()
                                      , r = 4 * i
                                      , s = t._malloc(r);
                                    e.GetTrianglesUInt32Array(n, r, s);
                                    const o = new Uint32Array(t.HEAPF32.buffer,s,i).slice();
                                    return t._free(s),
                                    {
                                        array: o,
                                        itemSize: 1
                                    }
                                }(t, e, a)),
                                t.destroy(a),
                                u
                            }(e, o, a, s)
                              , i = t.attributes.map((t=>t.array.buffer));
                            t.index && i.push(t.index.array.buffer),
                            self.postMessage({
                                type: "decode",
                                id: r.id,
                                geometry: t
                            }, i)
                        } catch (t) {
                            console.error(t),
                            self.postMessage({
                                type: "error",
                                id: r.id,
                                error: t.message
                            })
                        } finally {
                            e.destroy(a),
                            e.destroy(o)
                        }
                    }
                    ))
                }
            }
        }
        function iv(t, e) {
            var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!n) {
                if (Array.isArray(t) || (n = function(t, e) {
                    if (t) {
                        if ("string" == typeof t)
                            return rv(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name),
                        "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? rv(t, e) : void 0
                    }
                }(t)) || e && t && "number" == typeof t.length) {
                    n && (t = n);
                    var i = 0
                      , r = function() {};
                    return {
                        s: r,
                        n: function() {
                            return i >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[i++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: r
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var s, o = !0, a = !1;
            return {
                s: function() {
                    n = n.call(t)
                },
                n: function() {
                    var t = n.next();
                    return o = t.done,
                    t
                },
                e: function(t) {
                    a = !0,
                    s = t
                },
                f: function() {
                    try {
                        o || null == n.return || n.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
            }
        }
        function rv(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++)
                i[n] = t[n];
            return i
        }
        function sv(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        var ov = function() {
            function t(e) {
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                this.DOM = {
                    animationElems: Array.isArray(e) ? e : [e]
                },
                this.SplitTypeInstances = [],
                this.lines = [];
                var n, i = iv(this.DOM.animationElems);
                try {
                    for (i.s(); !(n = i.n()).done; ) {
                        var r = n.value
                          , s = new wo(r,{
                            types: "lines"
                        });
                        Mo(s.lines, "span", "split"),
                        this.lines.push(s.lines),
                        this.SplitTypeInstances.push(s)
                    }
                } catch (t) {
                    i.e(t)
                } finally {
                    i.f()
                }
                this.initEvents()
            }
            var e, n;
            return e = t,
            (n = [{
                key: "in",
                value: function() {
                    return this.isVisible = !0,
                    ji.killTweensOf(this.lines),
                    ji.timeline({
                        defaults: {
                            duration: 1.2,
                            ease: "expo"
                        }
                    }).set(this.lines, {
                        y: "150%",
                        opacity: 0,
                        rotate: 15
                    }).to(this.lines, {
                        y: "0%",
                        rotate: 0,
                        opacity: 1,
                        stagger: .04
                    })
                }
            }, {
                key: "out",
                value: function() {
                    return this.isVisible = !1,
                    ji.killTweensOf(this.lines),
                    ji.timeline({
                        defaults: {
                            duration: .7,
                            ease: "power2"
                        }
                    }).to(this.lines, {
                        y: "-150%",
                        rotate: -5,
                        opacity: 0,
                        stagger: .02
                    })
                }
            }, {
                key: "initEvents",
                value: function() {
                    var t = this;
                    window.addEventListener("resize", (function() {
                        t.lines = [];
                        var e, n = iv(t.SplitTypeInstances);
                        try {
                            for (n.s(); !(e = n.n()).done; ) {
                                var i = e.value;
                                i.split(),
                                Mo(i.lines, "span", "split"),
                                t.lines.push(i.lines)
                            }
                        } catch (t) {
                            n.e(t)
                        } finally {
                            n.f()
                        }
                        t.isVisible || ji.set(t.lines, {
                            y: "-150%",
                            opacity: 0
                        })
                    }
                    ))
                }
            }]) && sv(e.prototype, n),
            t
        }();
        function av(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++)
                i[n] = t[n];
            return i
        }
        function lv(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n,
            t
        }
        var cv = function t(e) {
            var n;
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            lv(this, "DOM", {
                el: null
            }),
            lv(this, "textReveal", null),
            lv(this, "textLinesReveal", null),
            this.DOM.el = e,
            this.DOM.nav = {
                prev: this.DOM.el.querySelector(".slide-nav__img--prev"),
                next: this.DOM.el.querySelector(".slide-nav__img--next")
            },
            this.textReveal = new ov(function(t) {
                if (Array.isArray(t))
                    return av(t)
            }(n = this.DOM.el.querySelectorAll("#cases .animation-title")) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"])
                    return Array.from(t)
            }(n) || function(t, e) {
                if (t) {
                    if ("string" == typeof t)
                        return av(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === n && t.constructor && (n = t.constructor.name),
                    "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? av(t, e) : void 0
                }
            }(n) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()),
            this.textLinesReveal = new Co(this.DOM.el.querySelector("#cases .content__item-text"))
        }
          , uv = function t(e) {
            var n;
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            n = {
                el: null,
                inner: null,
                contentId: null,
                contentItem: null
            },
            "DOM"in this ? Object.defineProperty(this, "DOM", {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : this.DOM = n,
            this.DOM.el = e,
            this.DOM.inner = this.DOM.el.querySelector("#cases .grid__cell-img-inner"),
            this.contentId = this.DOM.inner.dataset.item,
            this.contentItem = new cv(document.querySelector("#".concat(this.contentId)))
        };
        function hv(t) {
            return function(t) {
                if (Array.isArray(t))
                    return pv(t)
            }(t) || function(t) {
                if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"])
                    return Array.from(t)
            }(t) || dv(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }
        function dv(t, e) {
            if (t) {
                if ("string" == typeof t)
                    return pv(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === n && t.constructor && (n = t.constructor.name),
                "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? pv(t, e) : void 0
            }
        }
        function pv(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var n = 0, i = new Array(e); n < e; n++)
                i[n] = t[n];
            return i
        }
        function fv(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1,
                i.configurable = !0,
                "value"in i && (i.writable = !0),
                Object.defineProperty(t, i.key, i)
            }
        }
        function mv(t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n,
            t
        }
        var gv = document.body
          , vv = So();
        window.addEventListener("resize", (function() {
            return vv = So()
        }
        ));
        var yv, xv, _v, bv, wv, Mv, Sv, Tv, Ev, Av = function() {
            function t(e) {
                var n = this;
                !function(t, e) {
                    if (!(t instanceof e))
                        throw new TypeError("Cannot call a class as a function")
                }(this, t),
                mv(this, "DOM", {
                    el: null,
                    imageCells: null,
                    content: null,
                    backCtrl: null,
                    miniGrid: {
                        el: null,
                        cells: null
                    }
                }),
                mv(this, "imageCellArr", []),
                mv(this, "currentCell", -1),
                mv(this, "isGridView", !0),
                mv(this, "isAnimating", !1),
                mv(this, "textReveal", null),
                this.DOM.el = e,
                this.DOM.imageCells = hv(this.DOM.el.querySelectorAll("#cases .grid__cell-img")),
                this.DOM.imageCells.forEach((function(t) {
                    return n.imageCellArr.push(new uv(t))
                }
                )),
                this.DOM.content = document.querySelector("#cases .content"),
                this.DOM.backCtrl = this.DOM.content.querySelectorAll("#cases .back"),
                this.DOM.miniGrid.el = this.DOM.content.querySelector("#cases .grid--mini"),
                this.DOM.miniGrid.cells = hv(this.DOM.miniGrid.el.querySelectorAll("#cases .grid__cell")),
                this.textReveal = new ov(hv(this.DOM.el.querySelectorAll("#cases .split"))),
                this.initEvents()
            }
            var e, n;
            return e = t,
            (n = [{
                key: "trackVisibleCells",
                value: function() {
                    var t = new IntersectionObserver((function(t, e) {
                        t.forEach((function(t) {
                            t.intersectionRatio > 0 ? t.target.classList.add("in-view") : t.target.classList.remove("in-view")
                        }
                        ))
                    }
                    ));
                    this.DOM.imageCells.forEach((function(e) {
                        return t.observe(e)
                    }
                    ))
                }
            }, {
                key: "initEvents",
                value: function() {
                    var t, e = this, n = function(t, e) {
                        var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!n) {
                            if (Array.isArray(t) || (n = dv(t))) {
                                n && (t = n);
                                var i = 0
                                  , r = function() {};
                                return {
                                    s: r,
                                    n: function() {
                                        return i >= t.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: t[i++]
                                        }
                                    },
                                    e: function(t) {
                                        throw t
                                    },
                                    f: r
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var s, o = !0, a = !1;
                        return {
                            s: function() {
                                n = n.call(t)
                            },
                            n: function() {
                                var t = n.next();
                                return o = t.done,
                                t
                            },
                            e: function(t) {
                                a = !0,
                                s = t
                            },
                            f: function() {
                                try {
                                    o || null == n.return || n.return()
                                } finally {
                                    if (a)
                                        throw s
                                }
                            }
                        }
                    }(this.imageCellArr.entries());
                    try {
                        var i = function() {
                            var n, i, r = (n = t.value,
                            i = 2,
                            function(t) {
                                if (Array.isArray(t))
                                    return t
                            }(n) || function(t, e) {
                                var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                                if (null != n) {
                                    var i, r, s = [], o = !0, a = !1;
                                    try {
                                        for (n = n.call(t); !(o = (i = n.next()).done) && (s.push(i.value),
                                        !e || s.length !== e); o = !0)
                                            ;
                                    } catch (t) {
                                        a = !0,
                                        r = t
                                    } finally {
                                        try {
                                            o || null == n.return || n.return()
                                        } finally {
                                            if (a)
                                                throw r
                                        }
                                    }
                                    return s
                                }
                            }(n, i) || dv(n, i) || function() {
                                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                            }()), s = r[0], o = r[1];
                            o.DOM.el.addEventListener("click", (function() {
                                if (!e.isGridView || e.isAnimating)
                                    return !1;
                                e.isAnimating = !0,
                                e.isGridView = !1,
                                -1 !== e.currentCell && e.DOM.miniGrid.cells[e.currentCell].classList.remove("grid__cell--current"),
                                e.currentCell = s,
                                e.DOM.miniGrid.cells[e.currentCell].classList.add("grid__cell--current"),
                                e.showContent(o)
                            }
                            )),
                            o.DOM.el.addEventListener("mouseenter", (function() {
                                if (o.DOM.el.classList.contains("loaded")) {
                                    if (!e.isGridView)
                                        return !1;
                                    ji.killTweensOf([o.DOM.el, o.DOM.inner]),
                                    ji.timeline({
                                        defaults: {
                                            duration: 2.4,
                                            ease: "expo"
                                        }
                                    }).to(o.DOM.el, {
                                        scale: .95
                                    }, 0).to(o.DOM.inner, {
                                        scale: 1.4
                                    }, 0)
                                }
                            }
                            )),
                            o.DOM.el.addEventListener("mouseleave", (function() {
                                if (o.DOM.el.classList.contains("loaded")) {
                                    if (!e.isGridView)
                                        return !1;
                                    ji.killTweensOf([o.DOM.el, o.DOM.inner]),
                                    ji.timeline({
                                        defaults: {
                                            duration: 2.4,
                                            ease: "expo"
                                        }
                                    }).to([o.DOM.el, o.DOM.inner], {
                                        scale: 1
                                    }, 0)
                                }
                            }
                            ))
                        };
                        for (n.s(); !(t = n.n()).done; )
                            i()
                    } catch (t) {
                        n.e(t)
                    } finally {
                        n.f()
                    }
                    this.DOM.backCtrl.forEach((function(t, n) {
                        t.addEventListener("click", (function() {
                            if (e.isAnimating)
                                return !1;
                            e.isAnimating = !0,
                            e.isGridView = !0,
                            e.closeContent()
                        }
                        ))
                    }
                    )),
                    this.DOM.miniGrid.cells.forEach((function(t, n) {
                        t.addEventListener("click", (function() {
                            if (e.isAnimating || e.currentCell === n)
                                return !1;
                            e.isAnimating = !0
                        }
                        ))
                    }
                    )),
                    window.addEventListener("resize", (function() {
                        if (e.isGridView)
                            return !1;
                        var t = e.calcTransformImage();
                        ji.set(e.imageCellArr[e.currentCell].DOM.el, {
                            scale: t.scale,
                            x: t.x,
                            y: t.y
                        })
                    }
                    ))
                }
            }, {
                key: "showContent",
                value: function(t) {
                    var e = this
                      , n = this.calcTransformImage();
                    this.otherImageCells = this.DOM.imageCells.filter((function(e) {
                        return e != t.DOM.el
                    }
                    )),
                    ji.killTweensOf([t.DOM.el, t.DOM.inner, this.otherImageCells]),
                    ji.timeline({
                        defaults: {
                            duration: 1.2,
                            ease: "expo.inOut"
                        },
                        onStart: function() {
                            return gv.classList.add("no-scroll")
                        },
                        onComplete: function() {
                            e.isAnimating = !1
                        }
                    }).addLabel("start", 0).add((function() {
                        e.textReveal.out()
                    }
                    ), "start").set(this.DOM.el, {
                        pointerEvents: "none"
                    }, "start").set(t.DOM.el, {
                        zIndex: 100
                    }, "start").set([t.DOM.el, t.DOM.inner, this.otherImageCells], {
                        willChange: "transform, opacity"
                    }, "start").to(t.DOM.el, {
                        scale: n.scale,
                        x: n.x,
                        y: n.y,
                        onComplete: function() {
                            return ji.set(t.DOM.el, {
                                willChange: ""
                            })
                        }
                    }, "start").to(t.DOM.el.querySelector(".grid__cell-img-inner"), {
                        filter: "grayscale(0) sepia(0) saturate(1) contrast(1) brightness(1)",
                        webkitFilter: "grayscale(0) sepia(0) saturate(1) contrast(1) brightness(1)"
                    }, "start").to(t.DOM.inner, {
                        scale: 1,
                        onComplete: function() {
                            return ji.set(t.DOM.inner, {
                                willChange: ""
                            })
                        }
                    }, "start").to(this.otherImageCells, {
                        opacity: 0,
                        scale: .8,
                        onComplete: function() {
                            return ji.set(e.otherImageCells, {
                                willChange: ""
                            })
                        },
                        stagger: {
                            grid: "auto",
                            amount: .17,
                            from: this.currentCell
                        }
                    }, "start").to("#header", {
                        opacity: 0,
                        y: "-100%"
                    }, "start").to('section[class*="section-title"]', {
                        opacity: 0
                    }, "start").to("section#intro", {
                        opacity: 0
                    }, "start").to("section#awards", {
                        opacity: 0
                    }, "start").to("#cases .wrapper h3", {
                        opacity: 0,
                        y: "50%"
                    }, "start").to("#cases .wrapper p", {
                        opacity: 0,
                        y: "50%"
                    }, "start").to("#cases .footer p", {
                        opacity: 1
                    }, "start").to("#cases .footer a", {
                        opacity: 1
                    }, "start").to("#cases .footer .line", {
                        width: "100%",
                        opacity: 1
                    }, "start").to("#footer-bg", {
                        autoAlpha: .2,
                        ease: "Power1.in",
                        visibility: "visible"
                    }, "start").addLabel("showContent", "start+=0.45").to(this.DOM.backCtrl, {
                        ease: "expo",
                        startAt: {
                            x: "50%"
                        },
                        x: "0%",
                        opacity: 1
                    }, "showContent").set(this.DOM.miniGrid.cells, {
                        opacity: 0
                    }, "showContent").to(this.DOM.miniGrid.cells, {
                        duration: 1,
                        ease: "expo",
                        opacity: 1,
                        startAt: {
                            scale: .8
                        },
                        scale: 1,
                        stagger: {
                            grid: "auto",
                            amount: .3,
                            from: this.currentCell
                        }
                    }, "showContent+=0.2").add((function() {
                        t.contentItem.textReveal.in(),
                        t.contentItem.textLinesReveal.in(),
                        e.DOM.content.classList.add("content--open")
                    }
                    ), "showContent").add((function() {
                        return t.contentItem.DOM.el.classList.add("content__item--current")
                    }
                    ), "showContent+=0.02")
                }
            }, {
                key: "closeContent",
                value: function() {
                    var t = this
                      , e = this.imageCellArr[this.currentCell];
                    this.otherImageCells = this.DOM.imageCells.filter((function(t) {
                        return t != e.DOM.el
                    }
                    )),
                    ji.timeline({
                        defaults: {
                            duration: 1,
                            ease: "expo.inOut"
                        },
                        onStart: function() {
                            return gv.classList.remove("no-scroll")
                        },
                        onComplete: function() {
                            t.isAnimating = !1
                        }
                    }).addLabel("start", 0).to(this.DOM.backCtrl, {
                        x: "50%",
                        opacity: 0
                    }, "start").to(this.DOM.miniGrid.cells, {
                        duration: .5,
                        ease: "expo.in",
                        opacity: 0,
                        scale: .8,
                        stagger: {
                            grid: "auto",
                            amount: .1,
                            from: -this.currentCell
                        },
                        onComplete: function() {}
                    }, "start").to("#header", {
                        opacity: 1,
                        y: "0%"
                    }, "start").to('section[class*="section-title"]', {
                        opacity: 1
                    }, "start").to("section#intro", {
                        opacity: 1
                    }, "start").to("section#awards", {
                        opacity: 1
                    }, "start").to("#cases .wrapper h3", {
                        opacity: 1,
                        y: "0%"
                    }, "start").to("#cases .wrapper p", {
                        opacity: 1,
                        y: "0%"
                    }, "start").to("#cases .footer p", {
                        opacity: 0
                    }, "start").to("#cases .footer a", {
                        opacity: 0
                    }, "start").to("#cases .footer .line", {
                        width: "0%",
                        opacity: 0
                    }, "start").to("#footer-bg", {
                        autoAlpha: 0,
                        ease: "Power1.in",
                        visibility: "hidden"
                    }, "start").add((function() {
                        e.contentItem.textReveal.out(),
                        e.contentItem.textLinesReveal.out(),
                        t.DOM.content.classList.remove("content--open")
                    }
                    ), "start").add((function() {
                        return e.contentItem.DOM.el.classList.remove("content__item--current")
                    }
                    )).addLabel("showGrid", 0).set([e.DOM.el, this.otherImageCells], {
                        willChange: "transform, opacity"
                    }, "showGrid").to(e.DOM.el, {
                        scale: 1,
                        x: 0,
                        y: 0,
                        onComplete: function() {
                            return ji.set(e.DOM.el, {
                                willChange: "",
                                zIndex: 1
                            })
                        }
                    }, "showGrid").to(e.DOM.el.querySelector(".grid__cell-img-inner"), {
                        filter: "grayscale(1) sepia(1) saturate(0.5) contrast(0.6) brightness(0.8)",
                        webkitFilter: "grayscale(1) sepia(1) saturate(0.5) contrast(0.6) brightness(0.8)"
                    }, "start").to(this.otherImageCells, {
                        opacity: 1,
                        scale: 1,
                        onComplete: function() {
                            ji.set(t.otherImageCells, {
                                willChange: ""
                            }),
                            ji.set(t.DOM.el, {
                                pointerEvents: "auto"
                            })
                        },
                        stagger: {
                            grid: "auto",
                            amount: .17,
                            from: -this.currentCell
                        }
                    }, "showGrid").add((function() {
                        t.textReveal.in()
                    }
                    ), "showGrid+=0.3")
                }
            }, {
                key: "calcTransformImage",
                value: function() {
                    var t = function(t) {
                        var e = t.getBoundingClientRect()
                          , n = getComputedStyle(t)
                          , i = n.transform;
                        if (i) {
                            var r, s, o, a;
                            if (i.startsWith("matrix3d("))
                                r = +(l = i.slice(9, -1).split(/, /))[0],
                                s = +l[5],
                                o = +l[12],
                                a = +l[13];
                            else {
                                if (!i.startsWith("matrix("))
                                    return e;
                                var l;
                                r = +(l = i.slice(7, -1).split(/, /))[0],
                                s = +l[3],
                                o = +l[4],
                                a = +l[5]
                            }
                            var c = n.transformOrigin
                              , u = e.x - o - (1 - r) * parseFloat(c)
                              , h = e.y - a - (1 - s) * parseFloat(c.slice(c.indexOf(" ") + 1))
                              , d = r ? e.width / r : t.offsetWidth
                              , p = s ? e.height / s : t.offsetHeight;
                            return {
                                x: u,
                                y: h,
                                width: d,
                                height: p,
                                top: h,
                                right: u + d,
                                bottom: h + p,
                                left: u
                            }
                        }
                        return e
                    }(this.imageCellArr[this.currentCell].DOM.el);
                    return vv.width >= 768 ? {
                        scale: .54 * vv.width / t.width,
                        x: .65 * vv.width - (t.left + t.width / 2),
                        y: .5 * vv.height - (t.top + t.height / 2)
                    } : vv.width < 768 && vv.width > 420 ? {
                        scale: .7 * vv.width / t.width,
                        x: .5 * vv.width - (t.left + t.width / 2),
                        y: .6 * vv.height - (t.top + t.height / 2)
                    } : {
                        scale: 1 * vv.width / t.width,
                        x: .5 * vv.width - (t.left + t.width / 2),
                        y: .5 * vv.height - (t.top + t.height / 2)
                    }
                }
            }]) && fv(e.prototype, n),
            t
        }();
        console.log("Hello Developers!"),
        Io().cfg.customMedia = {
            "--4k": "(min-width: 2561px)",
            "--2k": "(min-width: 1930px)",
            "--hd": "(min-width: 1441px)",
            "--pi": "(min-width: 1281px)",
            "--md": "(min-width: 481px)",
            "--mobileplus": "(min-width: 415px)",
            "--mobile": "(max-width: 414px)"
        },
        document && document.fonts ? setTimeout((function() {
            document.fonts.load('16px "Tusker Grotesk"').then((function() {
                document.documentElement.classList.add("font-loaded")
            }
            ))
        }
        ), 0) : document.documentElement.classList.add("font-loaded"),
        _v = document.querySelector("[data-day] span:first-of-type"),
        bv = document.querySelector("[data-day] span:nth-of-type(2)"),
        wv = document.querySelector("[data-month]"),
        Sv = (Mv = new Date).getDate(),
        Tv = Mv.getMonth(),
        Sv < 10 ? (yv = "0",
        xv = Sv = "0" + Sv) : (yv = Math.trunc(Sv / 10),
        xv = 10 == Sv || 20 == Sv || 30 == Sv ? "0" : (Sv / 10 + "").split(".")[1]),
        _v.setAttribute("data-count-to", yv),
        bv.setAttribute("data-count-to", xv),
        wv.setAttribute("data-count-to", Tv),
        function() {
            var t = ji.timeline({
                scrollTrigger: {
                    trigger: "#hero",
                    start: "top top",
                    end: "bottom top",
                    scrub: !0
                }
            });
            window.innerWidth >= 1024 && ji.utils.toArray("#hero .parallax").forEach((function(e) {
                var n = -.1 * e.offsetHeight;
                e.offsetHeight,
                t.to(e, {
                    y: n,
                    ease: "Power1.in"
                }, 0)
            }
            )),
            ji.utils.toArray(".main-bg").forEach((function(e) {
                if (t.to(e, {
                    autoAlpha: 0,
                    ease: "Power1.in"
                }),
                window.innerWidth >= 1024) {
                    var n = -.1 * e.offsetHeight;
                    t.to(e, {
                        y: n,
                        ease: "Power1.in"
                    }, 0)
                }
            }
            ));
            var e = ji.timeline({
                scrollTrigger: {
                    trigger: "#hero",
                    start: "top top",
                    end: "center top",
                    scrub: !0
                }
            });
            ji.utils.toArray(".scroller").forEach((function(t) {
                e.to(t, {
                    opacity: 1,
                    ease: "Power1.in"
                })
            }
            ));
            var n = ji.timeline({
                scrollTrigger: {
                    trigger: "#awards",
                    start: "top top",
                    end: "center top",
                    scrub: !0
                }
            });
            ji.utils.toArray("#footer-bg").forEach((function(t) {
                n.to(t, {
                    autoAlpha: 1,
                    ease: "Power1.in",
                    visibility: "visible"
                })
            }
            ));
            var i = ji.timeline({
                scrollTrigger: {
                    trigger: "#main-wrap",
                    start: "top top",
                    end: "bottom top",
                    scrub: !0
                }
            });
            ji.utils.toArray(".page-header .scaling-svg").forEach((function(t) {
                var e = -10 * t.offsetHeight;
                i.to(t, {
                    rotation: e,
                    ease: "Power1.in"
                })
            }
            ));
            var r = ji.timeline({
                scrollTrigger: {
                    trigger: ".page-content",
                    start: "top top",
                    end: "bottom top",
                    scrub: !0
                }
            });
            ji.utils.toArray("[class*='section-title'] .scaling-svg").forEach((function(t) {
                var e = -10 * t.offsetHeight;
                r.to(t, {
                    rotation: e,
                    ease: "Power1.in"
                })
            }
            )),
            ji.to("progress", {
                value: 100,
                ease: "none",
                scrollTrigger: {
                    scrub: .3
                }
            });
            var s = document.querySelectorAll(".animation-line")
              , o = document.querySelectorAll(".item-fade");
            window.innerWidth >= 481 ? new Co(s).out() : document.querySelectorAll(".animation-line").forEach((function(t) {
                t.style.opacity = 0
            }
            )),
            s.forEach((function(t) {
                new IntersectionObserver((function(e, n) {
                    e.forEach((function(e) {
                        e.isIntersecting && (window.innerWidth >= 481 ? new Co(t).in() : ji.fromTo(t, {
                            opacity: 0,
                            y: "10%"
                        }, {
                            opacity: 1,
                            y: "0%",
                            stagger: .04,
                            ease: "Power1.in",
                            duration: 1
                        }),
                        n.disconnect())
                    }
                    ))
                }
                ),{
                    threshold: [.7]
                }).observe(t)
            }
            )),
            new Po(o).out(),
            o.forEach((function(t) {
                new IntersectionObserver((function(e, n) {
                    e.forEach((function(e) {
                        e.isIntersecting && (new Po(t).in(),
                        n.disconnect())
                    }
                    ))
                }
                ),{
                    threshold: [.7]
                }).observe(t)
            }
            )),
            document.querySelector("#intro h2 .split .line").style.opacity = 0,
            document.querySelectorAll("#intro h2").forEach((function(t) {
                new IntersectionObserver((function(t, e) {
                    t.forEach((function(t) {
                        if (t.isIntersecting) {
                            var n = ji.timeline();
                            ji.utils.toArray("#intro h2 .split .line").forEach((function(t) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "50%"
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    stagger: .04,
                                    ease: "Power1.in",
                                    duration: .5
                                }, "start")
                            }
                            )),
                            n.fromTo("#intro h2 [class*='symbol']", {
                                opacity: 0
                            }, {
                                opacity: 1,
                                ease: "Power1.in",
                                duration: 1.5
                            }, ">"),
                            e.disconnect()
                        }
                    }
                    ))
                }
                ),{
                    threshold: [.7]
                }).observe(t)
            }
            )),
            document.querySelectorAll("#cases h3 .div .line")[0].style.opacity = 0,
            document.querySelectorAll("#cases h3 .div .line")[1].style.opacity = 0,
            document.querySelectorAll("#cases h3 .div .line")[2].style.opacity = 0,
            document.querySelectorAll("#cases h3 .div .line")[3].style.opacity = 0,
            document.querySelectorAll("#cases h3 .div .line")[4].style.opacity = 0,
            document.querySelectorAll("#cases .grid__cell-img-inner")[0].style.opacity = 0,
            document.querySelectorAll("#cases .grid__cell-img-inner")[1].style.opacity = 0,
            document.querySelectorAll("#cases .grid__cell-img-inner")[2].style.opacity = 0,
            document.querySelectorAll("#cases .grid__cell-img-inner")[3].style.opacity = 0,
            document.querySelectorAll("#cases .grid__cell-img-inner")[4].style.opacity = 0,
            document.querySelectorAll("#cases h3").forEach((function(t) {
                new IntersectionObserver((function(t, e) {
                    t.forEach((function(t) {
                        if (t.isIntersecting) {
                            var n = ji.timeline();
                            ji.utils.toArray(t.target.querySelectorAll(".div .line")).forEach((function(t) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "50%"
                                }, {
                                    opacity: 1,
                                    y: "5%",
                                    stagger: .04,
                                    ease: "Power1.in",
                                    duration: .5
                                }, "start")
                            }
                            )),
                            e.disconnect()
                        }
                    }
                    ))
                }
                ),{
                    threshold: [.7]
                }).observe(t)
            }
            )),
            document.querySelectorAll("#cases .grid__cell").forEach((function(t) {
                new IntersectionObserver((function(t, e) {
                    t.forEach((function(t) {
                        if (t.isIntersecting) {
                            var n = ji.timeline();
                            ji.utils.toArray(t.target.querySelectorAll(".grid__cell-img-inner")).forEach((function(t) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "100%"
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    stagger: .04,
                                    ease: "Power1.in",
                                    duration: .5
                                }, "start")
                            }
                            )),
                            ji.utils.toArray(t.target).forEach((function(t) {
                                n.set(t, {
                                    onComplete: function() {
                                        t.querySelector(".grid__cell-img") && t.querySelector(".grid__cell-img").classList.add("loaded")
                                    }
                                })
                            }
                            ), "start=+0.5"),
                            e.disconnect()
                        }
                    }
                    ))
                }
                ),{
                    threshold: [.7]
                }).observe(t)
            }
            )),
            document.querySelectorAll("#awards h3 .split .line")[0].style.opacity = 0,
            document.querySelectorAll("#awards h3 .split .line")[1].style.opacity = 0,
            document.querySelectorAll("#awards h3 .split .line")[2].style.opacity = 0,
            document.querySelectorAll("#awards .content [class*='list']")[0].style.opacity = 0,
            document.querySelectorAll("#awards .content [class*='list']")[1].style.opacity = 0,
            document.querySelectorAll("#awards .content [class*='list']")[2].style.opacity = 0,
            document.querySelectorAll("#awards .content [class*='list']")[3].style.opacity = 0,
            document.querySelectorAll("#awards .content [class*='list']")[4].style.opacity = 0,
            document.querySelectorAll("#awards .content [class*='list']")[5].style.opacity = 0,
            document.querySelectorAll("#awards .content [class*='list']")[6].style.opacity = 0,
            document.querySelector("#awards .cta").style.opacity = 0,
            document.querySelector("#awards .awards").style.opacity = 0,
            document.querySelector("#awards svg").style.opacity = 0,
            document.querySelectorAll("#awards h3").forEach((function(t) {
                new IntersectionObserver((function(t, e) {
                    t.forEach((function(t) {
                        if (t.isIntersecting) {
                            var n = ji.timeline();
                            ji.utils.toArray("#awards h3 .split .line").forEach((function(t) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "50%"
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    stagger: .02,
                                    ease: "Power1.in",
                                    duration: .5
                                }, "start")
                            }
                            )),
                            n.fromTo("#awards h3 [class*='symbol']", {
                                opacity: 0
                            }, {
                                opacity: 1,
                                ease: "Power1.in",
                                duration: 1.5
                            }, ">"),
                            ji.utils.toArray("#awards .content [class*='list']").forEach((function(t, e) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "50%"
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    ease: "Power1.in",
                                    duration: .5,
                                    delay: .2 * e
                                }, 1),
                                n.fromTo(t.querySelector(".line"), {
                                    opacity: 0,
                                    width: "0%"
                                }, {
                                    opacity: 1,
                                    width: "100%",
                                    ease: "Power1.in",
                                    duration: .5,
                                    delay: .3 * e
                                }, 1)
                            }
                            )),
                            n.fromTo("#awards .cta", {
                                opacity: 0
                            }, {
                                opacity: 1,
                                ease: "Power1.in",
                                duration: .5
                            }, 2),
                            n.fromTo("#awards .awards", {
                                opacity: 0
                            }, {
                                opacity: 1,
                                ease: "Power1.in",
                                duration: .5
                            }, 2),
                            n.fromTo("#awards svg", {
                                opacity: 0,
                                scale: .5
                            }, {
                                duration: 1,
                                opacity: 1,
                                scale: 1,
                                stagger: .1
                            }, 1),
                            ji.utils.toArray("#awards .content [class*='title-text'] img.lazyloaded").forEach((function(t) {
                                Io().loader.unveil(t),
                                t.classList.add("lazypreload")
                            }
                            )),
                            window.innerWidth <= 480 && document.querySelectorAll("#awards .content [class*='title-text'] img").forEach((function(t) {
                                Io().loader.unveil(t)
                            }
                            )),
                            e.disconnect()
                        }
                    }
                    ))
                }
                ),{
                    threshold: [.7]
                }).observe(t)
            }
            )),
            document.querySelectorAll("#footer h3 .split .line")[0].style.opacity = 0,
            document.querySelectorAll("#footer h3 .split .line")[1].style.opacity = 0,
            document.querySelector("#footer .text p[class*='h2']").style.opacity = 0,
            document.querySelector("#footer .content p[class*='h2']").style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[0].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[1].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[2].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[3].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[4].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[5].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[6].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[7].style.opacity = 0,
            document.querySelectorAll("#footer a[class*='btn']")[8].style.opacity = 0,
            document.querySelector("#footer .copy").style.opacity = 0,
            document.querySelectorAll("#footer .copy ul li")[0].style.opacity = 0,
            document.querySelectorAll("#footer .copy ul li")[1].style.opacity = 0,
            document.querySelectorAll("#footer .copy ul li")[2].style.opacity = 0,
            document.querySelectorAll("#footer .copy ul li")[3].style.opacity = 0,
            document.querySelectorAll("#footer .copy ul li")[4].style.opacity = 0,
            document.querySelectorAll("#footer .copy ul li")[5].style.opacity = 0,
            document.querySelectorAll("#footer h3").forEach((function(t) {
                new IntersectionObserver((function(t, e) {
                    t.forEach((function(t) {
                        if (t.isIntersecting) {
                            var n = ji.timeline();
                            ji.utils.toArray("#footer h3 .split .line").forEach((function(t) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "150%",
                                    rotate: 15
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    rotate: 0,
                                    stagger: .04,
                                    ease: "Power1.in",
                                    duration: .5
                                }, "start")
                            }
                            )),
                            n.fromTo("#footer .text p[class*='h2']", {
                                opacity: 0
                            }, {
                                opacity: 1,
                                ease: "Power1.in",
                                duration: 1.5
                            }, ">"),
                            ji.utils.toArray("#footer a[class*='btn']").forEach((function(t, e) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "50%"
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    ease: "Power1.in",
                                    duration: .5,
                                    delay: .2 * e
                                }, .5)
                            }
                            )),
                            n.fromTo("#footer .content p[class*='h2']", {
                                opacity: 0
                            }, {
                                opacity: 1,
                                ease: "Power1.in",
                                duration: 1.5
                            }, 1.5),
                            n.fromTo("#footer .content .copy", {
                                opacity: 0
                            }, {
                                opacity: 1,
                                ease: "Power1.in",
                                duration: 1.5
                            }, 1.4),
                            ji.utils.toArray("#footer .copy ul:first-of-type li").forEach((function(t, e) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "50%"
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    ease: "Power1.in",
                                    duration: .5,
                                    delay: .2 * e
                                }, 1.5)
                            }
                            )),
                            ji.utils.toArray("#footer .copy ul:last-of-type li").forEach((function(t, e) {
                                n.fromTo(t, {
                                    opacity: 0,
                                    y: "50%"
                                }, {
                                    opacity: 1,
                                    y: "0%",
                                    ease: "Power1.in",
                                    duration: .5,
                                    delay: .2 * e
                                }, 2)
                            }
                            )),
                            e.disconnect()
                        }
                    }
                    ))
                }
                ),{
                    threshold: [.7]
                }).observe(t)
            }
            ));
            var a = document.querySelector("#main-wrap .page-header .plane")
              , l = document.querySelector("#main-wrap .page-header .availability");
            l.addEventListener("mouseenter", (function(t) {
                document.querySelector("#main-wrap.loaded") && (l.classList.add("enter"),
                ji.to(a, {
                    clipPath: "polygon(50% 10%, 60% 50%, 50% 90%, 40% 50%)",
                    webkitClipPath: "polygon(50% 10%, 60% 50%, 50% 90%, 40% 50%)",
                    duration: 1,
                    ease: "easeInOut"
                }, 1))
            }
            )),
            l.addEventListener("mouseleave", (function(t) {
                document.querySelector("#main-wrap.loaded") && (l.classList.remove("enter"),
                ji.fromTo(a, {
                    clipPath: "polygon(50% 10%, 60% 50%, 50% 90%, 40% 50%)",
                    webkitClipPath: "polygon(50% 10%, 60% 50%, 50% 90%, 40% 50%)"
                }, {
                    clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                    webkitClipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                    duration: 1,
                    ease: "easeInOut"
                }, 1))
            }
            ));
            var c = document.querySelectorAll("#main-menu ul li a");
            c.forEach((function(t) {
                t.addEventListener("click", (function(e) {
                    c.forEach((function(t) {
                        t.classList.remove("active")
                    }
                    )),
                    t.classList.toggle("active")
                }
                ))
            }
            )),
            ji.utils.toArray("a[href*=\\#]:not([href=\\#])").forEach((function(t) {
                t.addEventListener("click", (function(t) {
                    t.preventDefault();
                    var e = t.srcElement.hash;
                    window.innerWidth > 480 ? "#cases" == this.hash ? ji.to(window, {
                        duration: .3,
                        delay: 0,
                        scrollTo: {
                            y: this.hash,
                            offsetY: 300
                        },
                        ease: "power4.inOut"
                    }) : ji.to(window, {
                        duration: .3,
                        delay: 0,
                        scrollTo: {
                            y: this.hash,
                            offsetY: 0
                        },
                        ease: "power4.inOut"
                    }) : "#footer" == this.hash || "#cases" == e ? ji.to(window, {
                        duration: .3,
                        delay: 0,
                        scrollTo: {
                            y: this.hash,
                            offsetY: 150
                        },
                        ease: "power4.inOut"
                    }) : ji.to(window, {
                        duration: .3,
                        delay: 0,
                        scrollTo: {
                            y: this.hash,
                            offsetY: 0
                        },
                        ease: "power4.inOut"
                    })
                }
                ))
            }
            ));
            var u = document.querySelector("[data-work]")
              , h = document.querySelector("#full-projects")
              , d = document.querySelector("#full-projects #close");
            u.addEventListener("click", (function(t) {
                t.preventDefault(),
                h.classList.toggle("is-active"),
                document.body.classList.toggle("no-scroll")
            }
            )),
            d.addEventListener("click", (function(t) {
                t.preventDefault(),
                h.classList.toggle("is-active"),
                document.body.classList.toggle("no-scroll")
            }
            ));
            var p = document.querySelector("[data-awards]")
              , f = document.querySelector("#full-awards")
              , m = document.querySelector("#full-awards #close");
            p.addEventListener("click", (function(t) {
                t.preventDefault(),
                f.classList.toggle("is-active"),
                document.body.classList.toggle("no-scroll")
            }
            )),
            m.addEventListener("click", (function(t) {
                t.preventDefault(),
                f.classList.toggle("is-active"),
                document.body.classList.toggle("no-scroll")
            }
            ));
            var g = document.querySelector("[data-credits]")
              , v = document.querySelector("#full-credits")
              , y = document.querySelector("#full-credits #close");
            g.addEventListener("click", (function(t) {
                t.preventDefault(),
                v.classList.toggle("is-active"),
                document.body.classList.toggle("no-scroll")
            }
            )),
            y.addEventListener("click", (function(t) {
                t.preventDefault(),
                v.classList.toggle("is-active"),
                document.body.classList.toggle("no-scroll")
            }
            ))
        }(),
        document.querySelector("body").classList.add((Ev = navigator.userAgent || navigator.vendor || window.opera,
        /windows phone/i.test(Ev) ? "mobile-windows-phone" : /android/i.test(Ev) ? "mobile-android" : /iPad|iPhone|iPod/.test(Ev) && !window.MSStream ? "mobile-ios" : "unknown")),
        document.documentElement.style.setProperty("--viewport-height", "".concat(window.innerHeight, "px")),
        function() {
            document.querySelectorAll(".page-header h1 .split .line");
            var t, e = document.querySelector(".page-header h1 .symbol div"), n = document.querySelectorAll(".page-header .hero-animation-line"), i = document.querySelectorAll(".page-header .availability"), r = document.querySelector(".page-header .content [class*='btn']");
            window.innerWidth >= 481 && (t = new Co(n));
            var s = {
                val: 0
            }
              , o = {
                val: 0
            }
              , a = {
                val: 0
            }
              , l = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]
              , c = No()("[data-day] span:first-of-type")
              , u = No()("[data-day] span:nth-of-type(2)")
              , h = No()("[data-month]")
              , d = c.attr("data-count-to")
              , p = u.attr("data-count-to")
              , f = h.attr("data-count-to")
              , m = ji.timeline();
            ji.utils.toArray("h1 .split .line").forEach((function(t) {
                m.fromTo(t, {
                    opacity: 0,
                    y: "150%",
                    rotate: 15
                }, {
                    opacity: 1,
                    y: "0%",
                    rotate: 0,
                    stagger: .04,
                    ease: "Power1.in",
                    duration: .5,
                    delay: .5
                }, "start")
            }
            ));
            var g = document.querySelectorAll(".page-header .plane");
            window.innerWidth >= 481 && ji.fromTo(g, {
                clipPath: "polygon(50% 10%, 60% 50%, 50% 90%, 40% 50%)",
                webkitClipPath: "polygon(50% 10%, 60% 50%, 50% 90%, 40% 50%)"
            }, {
                clipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                webkitClipPath: "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                duration: 1,
                ease: "easeInOut"
            }, "start+=0.25"),
            window.innerWidth <= 480 && m.to("#main-wrap", {
                duration: .01,
                className: "+=loaded"
            }, "<"),
            m.fromTo(e, {
                opacity: 0
            }, {
                opacity: 1,
                ease: "Power1.in",
                duration: 1
            }, "<"),
            window.innerWidth >= 481 && m.fromTo(".main-bg", {
                opacity: 0
            }, {
                opacity: 1,
                ease: "Power1.in",
                duration: 1
            }, "start+=1"),
            m.fromTo(i, {
                opacity: 0
            }, {
                opacity: 1,
                ease: "Power1.in",
                duration: 1
            }, "start+=1"),
            m.fromTo("#header", {
                opacity: 0,
                y: "-150%"
            }, {
                opacity: 1,
                y: "0%",
                ease: "Power1.in",
                duration: .5
            }, "start+=1"),
            window.innerWidth >= 481 ? m.add(t.in(), "start+=2.5") : ji.utils.toArray(n).forEach((function(t) {
                m.fromTo(t, {
                    opacity: 0,
                    y: "10%"
                }, {
                    opacity: 1,
                    y: "0%",
                    stagger: .04,
                    ease: "Power1.in",
                    duration: 1
                }, "start+=2.5")
            }
            )),
            m.to(r, {
                opacity: 1,
                y: "0%",
                ease: "Power1.in",
                duration: 1
            }, "start+=1.9"),
            m.to(s, {
                duration: .5,
                ease: "Power1.in",
                val: parseInt(d),
                roundProps: "val",
                onUpdate: function() {
                    c.text(s.val)
                }
            }, "start+=2.5"),
            m.to(o, {
                duration: .5,
                val: parseInt(p),
                roundProps: "val",
                onUpdate: function() {
                    u.text(o.val)
                }
            }, "start+=3"),
            m.to(a, {
                duration: .5,
                val: parseInt(f),
                roundProps: "val",
                onUpdate: function() {
                    h.text(l[a.val])
                }
            }, "start+=3.5"),
            m.to("#full-projects", {
                visibility: "visible",
                ease: "Power1.in",
                duration: .1
            }, "start+=1"),
            m.to("#full-awards", {
                visibility: "visible",
                ease: "Power1.in",
                duration: .1
            }, "start+=1"),
            m.to("#full-credits", {
                visibility: "visible",
                ease: "Power1.in",
                duration: .1
            }, "start+=1"),
            window.innerWidth >= 481 && m.to("#main-wrap", {
                duration: .01,
                className: "+=loaded"
            }, "start+=3")
        }(),
        new Promise((function(t, e) {
            setTimeout((function() {
                t("Success!")
            }
            ), 250)
        }
        )).then((function(t) {
            !function() {
                var t, e, n, i, r, s = document.querySelector("canvas.webgl"), o = document.querySelector("#model-wrapper"), a = new jm, l = 0, c = {
                    width: o.offsetWidth,
                    height: o.offsetHeight,
                    windowWidth: window.innerWidth,
                    windowHeight: window.innerHeight
                };
                r = 40,
                n = new np;
                var u = new ev;
                u.setDecoderPath("/draco/");
                var h = new pg;
                function d() {
                    c.width = o.offsetWidth,
                    c.height = o.offsetHeight,
                    c.windowWidth = window.innerWidth,
                    c.windowHeight = window.innerHeight,
                    e.aspect = c.width / c.height,
                    e.updateProjectionMatrix(),
                    i.setSize(c.width, c.height),
                    i.setPixelRatio(Math.min(window.devicePixelRatio, 2))
                }
                h.setDRACOLoader(u),
                function() {
                    switch (n = new np,
                    !0) {
                    case c.windowWidth > 481 && c.windowWidth < 1200:
                    case c.windowWidth <= 480:
                        r = 55;
                        break;
                    default:
                        r = 40
                    }
                    (e = new eu(r,c.width / c.height,.01,100)).position.set(0, 0, 40),
                    n.add(e),
                    h.load("/models/untitled.glb", (function(e) {
                        (t = e.scene.children[0]).position.x = .5,
                        t.castShadow = !0,
                        t.receiveShadow = !0,
                        n.add(t)
                    }
                    ));
                    var o = new Hm(new Va("#F3DBC7"),1);
                    o.castShadow = !0,
                    o.shadow.mapSize.set(1024, 1024),
                    o.shadow.camera.far = 15,
                    o.shadow.camera.left = -7,
                    o.shadow.camera.top = 7,
                    o.shadow.camera.right = 7,
                    o.shadow.camera.bottom = -7,
                    o.position.set(-3, 5, 0),
                    n.add(o),
                    (i = new $d({
                        canvas: s,
                        alpha: !0
                    })).shadowMap.enabled = !0,
                    i.shadowMap.type = 2,
                    i.setSize(c.width, c.height),
                    i.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
                    window.addEventListener("resize", d)
                }(),
                function r() {
                    var s = a.getElapsedTime()
                      , o = s - l;
                    l = s,
                    t && (t.rotation.z -= .5 * o),
                    i.render(n, e),
                    window.requestAnimationFrame(r)
                }()
            }(),
            new Av(document.querySelector(".grid--large"))
        }
        ))
    }()
}();
